[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The OpenAP Handbook",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#synopsis",
    "href": "index.html#synopsis",
    "title": "The OpenAP Handbook",
    "section": "Synopsis",
    "text": "Synopsis\nWelcome to the OpenAP handbook, a comprehensive guide to unlocking the full potential of the OpenAP aircraft performance library. This book is designed to help you navigate the vast capabilities of OpenAP, an open-source initiative that has been revolutionizing air transport research since its inception in 2019.\nThe first part of this book takes you through the core components that form the foundation of OpenAP. From the fundamentals of aircraft and engine data (Chapter 1) to the intricacies of drag and maximum thrust calculations (Chapter 2), kinematic models (Chapter 3), and flight phase identification (Chapter 4), we delve into the key components that make OpenAP an indispensable tool for researchers, developers, and aviation professionals. You will also learn how to harness OpenAP’s trajectory generation capabilities (Chapter 5) and analyze fuel and emission data (Chapter 6).\nThe second part focuses on the Trajectory Optimizer Package (TOP), an extension of OpenAP. Here, you will learn how to generate fuel-optimal and other types of optimal trajectories (Chapter 7). You will discover how to incorporate wind data into your optimizations (Chapter 8). Additionally, you will learn how to use TOP to handle more complex four-dimensional grid costs in your optimization problems, such as contrail formation (Chapter 9).\nEach chapter provides detailed insights into the underlying concepts, methodologies, and best practices, empowering you to make the most of OpenAP. Whether you’re a seasoned expert or new to the field, this manual will help you navigate the OpenAP library effectively. The goal is to equip you with the knowledge and skills necessary to leverage OpenAP in your research. Let’s embark on this journey together and explore the possibilities that OpenAP has to offer.\nEnjoy the reading!\nJunzi",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "The OpenAP Handbook",
    "section": "About the Author",
    "text": "About the Author\nJunzi Sun is an assistant professor at TU Delft, currently working in the CNS/ATM group of the Aerospace Engineering Faculty. He is passionate about open-source, open science, and making air transportation more sustainable.\nHe was born in China and completed his bachelor’s degree in telecommunication in Beijing. After that, he moved to Europe and obtained his master’s degree in aerospace engineering from the Polytechnic University of Catalonia. After working in Spain and France for several years, he pursued doctoral research in the Netherlands, where he obtained his Ph.D. and currently works and lives.\n\nThis online book is created with Quarto. To learn more about Quarto books, visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "openap.html",
    "href": "openap.html",
    "title": "🚀 OpenAP",
    "section": "",
    "text": "Data\nOpenAP library has two parts: OpenAP model data and Python modules.\nFollow model datasets are all made public, under GPL open-source license:",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#data",
    "href": "openap.html#data",
    "title": "🚀 OpenAP",
    "section": "",
    "text": "Aircraft data: Collected from open literature.\nEngines data: Primarily from the ICAO emission data bank, including fuel flow and emissions.\nDrag polar data: Exclusively derived from open data (reference).\nKinematic data: Kinematic model (formally WRAP) describe speed, altitude, and vertical rate.\nNavigation data: Airport and waypoints obtained from X-plane.",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#modules",
    "href": "openap.html#modules",
    "title": "🚀 OpenAP",
    "section": "Modules",
    "text": "Modules\nOpenAP Python library includes the following modules, which support a variety of functionalities, including performance models, emission models, trajectory generation, and trajectory optimization:\n\nprop: module for accessing aircraft and engine data\nthrust: module for computing aircraft maximum thrust\ndrag: module for computing aircraft drag\nfuel: module for computing fuel flow\nemission: module for computing aircraft emissions\nkinematic: module for accessing kinematic data\naero: module for common aeronautical conversions\nnav: module for accessing navigation information\nphase: module for determining climb, cruise, descent, level flight\ntraj: module for generating trajectories based on the kinematic model\n\nOther modules that can be installed separately:\n\ntop: a package for generating optimal trajectories (see Trajectory Optimization chapter)",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#install",
    "href": "openap.html#install",
    "title": "🚀 OpenAP",
    "section": "Install",
    "text": "Install\n\nopenap\nInstall the latest stable release from pypi:\npip install --upgrade openap\nInstall the development version from GitHub:\npip install --upgrade git+https://github.com/junzis/openap\nOpenAP is also published to conde-forge repository; you can install the release for conda-forge:\nmamba install openap -c conda-forge\n\n\nopenap-top\nIf you want to use the optimization function, you need to install openap-top in addition to openap, Install the stable release as:\npip install --upgrade openap-top\nOr, install the development version from my GitHub:\npip install --upgrade git+https://github.com/junzis/openap-top",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#import",
    "href": "openap.html#import",
    "title": "🚀 OpenAP",
    "section": "Import",
    "text": "Import\nMost of the functionalities (except aircraft and engine properties) in OpenAP are provided as Python classes. You can import these as follows:\n\nfrom openap.prop import aircraft, engine\nfrom openap.drag import Drag\nfrom openap.thrust import Thrust\nfrom openap.kinematic import WRAP\nfrom openap.phase import FlightPhase\nfrom openap.gen import FlightGenerator\nfrom openap.fuel import FuelFlow\nfrom openap.emission import Emission\n\n# when opeap-top is installed\nfrom openap.top import CompleteFlight, Climb, Cruise, Descent, MultiPhase\n\nYou can also import these Classes directly from the openap package as:\n\nfrom openap import (\n    Drag,\n    Thrust,\n    WRAP,\n    FlightPhase,\n    FlightGenerator,\n    FuelFlow,\n    Emission,\n)",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "aircraft_engine.html",
    "href": "aircraft_engine.html",
    "title": "1  🪬 Aircraft and engines",
    "section": "",
    "text": "1.1 Supported aircraft type codes\nThe prop package in openap allows users to obtain aircraft and engine-related data quickly. We will demonstrate usage through the following example.\nFirst, we need to import the prop package from the OpenAP library.\nfrom openap import prop\nfrom pprint import pprint\nWe can get a list of available aircraft openap.prop.available_aircraft() function:\navaiable_aircraft = prop.available_aircraft()\n\nprint(f\"Supports {len(avaiable_aircraft)} aircraft types\")\nprint(avaiable_aircraft)\n\nSupports 36 aircraft types\n['a19n', 'a20n', 'a21n', 'a318', 'a319', 'a320', 'a321', 'a332', 'a333', 'a343', 'a359', 'a388', 'b37m', 'b38m', 'b39m', 'b3xm', 'b734', 'b737', 'b738', 'b739', 'b744', 'b748', 'b752', 'b763', 'b772', 'b773', 'b77w', 'b788', 'b789', 'c550', 'e145', 'e170', 'e190', 'e195', 'e75l', 'glf6']",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#aircraft-data",
    "href": "aircraft_engine.html#aircraft-data",
    "title": "1  🪬 Aircraft and engines",
    "section": "1.2 Aircraft data",
    "text": "1.2 Aircraft data\nWe can get the parameters for one aircraft using openap.prop.aircraft() function:\n\naircraft = prop.aircraft(\"A320\")\npprint(aircraft)\n\n{'aircraft': 'Airbus A320',\n 'ceiling': 12500,\n 'cruise': {'height': 11000, 'mach': 0.78},\n 'drag': {'cd0': 0.018, 'e': 0.799, 'gears': 0.017, 'k': 0.039},\n 'engine': {'default': 'CFM56-5B4',\n            'mount': 'wing',\n            'number': 2,\n            'options': {'A320-111': 'CFM56-5-A1',\n                        'A320-211': 'CFM56-5-A1',\n                        'A320-212': 'CFM56-5A3',\n                        'A320-214': 'CFM56-5B4',\n                        'A320-215': 'CFM56-5B5',\n                        'A320-216': 'CFM56-5B6',\n                        'A320-231': 'V2500-A1',\n                        'A320-232': 'V2527-A5',\n                        'A320-233': 'V2527E-A5'},\n            'type': 'turbofan'},\n 'flaps': {'Sf/S': 0.17,\n           'area': 21.1,\n           'bf/b': 0.78,\n           'cf/c': 0.176,\n           'lambda_f': 0.9,\n           'type': 'single-slotted'},\n 'fuel': {'engine': 'CFM56-5B4/P', 'fuel_coef': 2.65942225},\n 'fuselage': {'height': 4.14, 'length': 37.57, 'width': 3.95},\n 'limits': {'MFC': 24210,\n            'MLW': 66000,\n            'MMO': 0.82,\n            'MTOW': 78000,\n            'OEW': 42600,\n            'VMO': 350,\n            'ceiling': 12500},\n 'mfc': 24210,\n 'mlw': 66000,\n 'mmo': 0.82,\n 'mtow': 78000,\n 'oew': 42600,\n 'pax': {'high': 170, 'low': 140, 'max': 180},\n 'vmo': 350,\n 'wing': {'area': 124, 'mac': 4.1935, 'span': 35.8, 'sweep': 25, 't/c': None}}",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#engine-data",
    "href": "aircraft_engine.html#engine-data",
    "title": "1  🪬 Aircraft and engines",
    "section": "1.3 Engine data",
    "text": "1.3 Engine data\nThe engine data can be obtained with openap.prop.engine() function:\n\nengine = prop.engine(\"CFM56-5B4\")\nengine\n\n{'uid': '2CM014',\n 'name': 'CFM56-5B4',\n 'manufacturer': 'CFM International',\n 'type': 'TF',\n 'bpr': 5.9,\n 'pr': 27.1,\n 'max_thrust': 117900,\n 'ei_hc_to': 0.1,\n 'ei_hc_co': 0.1,\n 'ei_hc_app': 0.13,\n 'ei_hc_idl': 3.87,\n 'ei_co_to': 0.5,\n 'ei_co_co': 0.5,\n 'ei_co_app': 2.33,\n 'ei_co_idl': 31.9,\n 'ei_nox_to': 28.7,\n 'ei_nox_co': 23.3,\n 'ei_nox_app': 10.0,\n 'ei_nox_idl': 4.3,\n 'ff_to': 1.166,\n 'ff_co': 0.961,\n 'ff_app': 0.326,\n 'ff_idl': 0.107,\n 'fuel_lto': 421.0,\n 'fuel_c3': 0.0468598,\n 'fuel_c2': 0.202282,\n 'fuel_c1': 0.871899,\n 'fuel_a': 0.587855,\n 'fuel_b': 0.417561,\n 'cruise_thrust': 22241.0,\n 'cruise_sfc': 0.0154,\n 'cruise_mach': 0.8,\n 'cruise_alt': 35000.0,\n 'fuel_ch': 5.2e-07}",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html",
    "href": "drag_thrust.html",
    "title": "2  ☯️ Drag and thrust",
    "section": "",
    "text": "2.1 Compute the aircraft drag\nThe OpenAP provides two modules, drag and thrust, for the calculation of drag force and maximum available thrust force during the flight.\nThe drag calculation is based on the OpenAP’s drag polar model, which is obtained based on open trajectory data and methodology from the paper: Sun et al. (2020).\nKnowing the drag polar coefficients - \\(C_{d0}\\) (zero-lift drag coefficient) and \\(k\\) (lift-induced drag coefficient) - of the aircraft, the drag force can be calculated based on the point-mass aircraft performance model:\n\\[\n\\begin{aligned}\nC_l &= \\frac{L}{1/2~\\rho v^2 S} = \\frac{mg}{1/2~\\rho v^2 S} \\\\\nC_d &= C_{d0} + k C_l^2 \\\\\nD &= C_d \\cdot \\frac{1}{2} \\rho v^2 S\n\\end{aligned}\n\\]\nWhen an aircraft is climbing and descending, the flight path angle is also considered to calculate the lift force. Hence, by including the vertical speed, the estimation of drag can be different.\nAn example calculation using the OpenAP’s drag module is:\nfrom openap.drag import Drag\n\ntypecode = \"A320\"\n\nmass = 62_000  # kg\nTAS = 250  # kts\nALT = 20_000  # ft\nVS = 1000  # ft/min\n\ndrag = Drag(ac=typecode)\n\n# clean configuration\nD = drag.clean(mass=mass, tas=TAS, alt=ALT, vs=VS)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nClean configuration \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:250  ALT:20000  VS:1000 \nClean configuration \n\nTotal drag is 33.0 kN\nThe drag.clean() function estimates the drag force when the aircraft is at the clean configuration, which means no flaps or landing gear are deployed.\nDuring the initial climb and approach, we can also calculate drag considering flaps (providing the flaps setting angle in degrees) and whether the landing gears are extended.\nmass = 62_000  # kg\nTAS = 150  # kts\nALT = 1000  # ft\nVS = 1500  # ft/min\nflap_angle = 20  # degree\n\n# with flaps and landing gears\nD = drag.nonclean(\n    mass=mass,\n    tas=TAS,\n    alt=ALT,\n    flap_angle=flap_angle,\n    vs=VS,\n    landing_gear=True,\n)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nFlap:{flap_angle} deg,  Landing Gear extended \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:150  ALT:1000  VS:1500 \nFlap:20 deg,  Landing Gear extended \n\nTotal drag is 46.0 kN",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "href": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "title": "2  ☯️ Drag and thrust",
    "section": "2.2 Compute maximum aircraft engine thrust",
    "text": "2.2 Compute maximum aircraft engine thrust\nOpenAP implements the engine thrust model proposed by Bartel & Young (2008). Small adjustments to the model was made to improve the computational efficiency.\nTo calculate the maximum net thrust of an aircraft, we first instantiate the thrust.Thrust object:\n\nfrom openap.thrust import Thrust\n\nthr_a320 = Thrust(ac=\"A320\", eng=\"CFM56-5B4\")\n\nThe function Thrust.takeoff() function is used to calculate maximum thrust during the take-off at different speed (kts) and altitude (ft) conditions, for example:\n\nT = thr_a320.takeoff(tas=100, alt=0)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 200.72 kN\n\n\nThe Thrust.climb() function estimates the maximum net thrust during the climb, which requires TAS (kts), altitude (ft), and rate of climb (ft/min).\nAn example for A320 climbing at 1000 ft/min at 10,000 ft with TAS 250 kts:\n\nT = thr_a320.climb(tas=250, alt=10000, roc=1000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 89.23 kN\n\n\nThe Thrust.cruise() function estimates the maximum net thrust during the cruise at different speeds and altitudes. An example is shown as follows.\n\nT = thr_a320.cruise(tas=300, alt=32000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 53.68 kN",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#idle-thrust",
    "href": "drag_thrust.html#idle-thrust",
    "title": "2  ☯️ Drag and thrust",
    "section": "2.3 Idle thrust",
    "text": "2.3 Idle thrust\nFurthermore, we can use the Thrust.descent_ide() function to estimate the idle thrust during the descent at different altitude and speed conditions.\nThe idle thrust is modeled as approximately 7% of the maximum thrust at the same altitude and speed.\nAn example is shown as follows:\n\nT = thr_a320.descent_idle(tas=250, alt=10000)\nprint(f\"Idle thrust: {round(T/1000, 2)} kN\")\n\nIdle thrust: 9.31 kN\n\n\n\n\n\n\nBartel, M., & Young, T. M. (2008). Simplified thrust and fuel consumption models for modern two-shaft turbofan engines. Journal of Aircraft, 45(4), 1450–1456.\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft drag polar using open flight surveillance data and a stochastic total energy model. Transportation Research Part C: Emerging Technologies, 114, 391–404. https://doi.org/10.1016/j.trc.2020.01.026",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "kinematic.html",
    "href": "kinematic.html",
    "title": "3  🌯 Kinematic models",
    "section": "",
    "text": "3.1 Parametric models\nOpenAP includes a set of kinematic models that describe speeds, vertical rates, altitudes, distance, and other parameters during different phases of a flight. The kinematic model, named WRAP, is constructed based on the method from the paper: Sun et al. (2019)\nFollowing is a list of functions that can be used to access parameters at different phases of flight, for example, flight type code A320:\nfrom openap.kinematic import WRAP\n\nwrap = WRAP(ac=\"A320\")\n\nparams = wrap.takeoff_speed()\nparams = wrap.takeoff_distance()\nparams = wrap.takeoff_acceleration()\nparams = wrap.initclimb_vcas()\nparams = wrap.initclimb_vs()\nparams = wrap.climb_range()\nparams = wrap.climb_const_vcas()\nparams = wrap.climb_const_mach()\nparams = wrap.climb_cross_alt_concas()\nparams = wrap.climb_cross_alt_conmach()\nparams = wrap.climb_vs_pre_concas()\nparams = wrap.climb_vs_concas()\nparams = wrap.climb_vs_conmach()\nparams = wrap.cruise_range()\nparams = wrap.cruise_alt()\nparams = wrap.cruise_init_alt()\nparams = wrap.cruise_mach()\nparams = wrap.descent_range()\nparams = wrap.descent_const_mach()\nparams = wrap.descent_const_vcas()\nparams = wrap.descent_cross_alt_conmach()\nparams = wrap.descent_cross_alt_concas()\nparams = wrap.descent_vs_conmach()\nparams = wrap.descent_vs_concas()\nparams = wrap.descent_vs_post_concas()\nparams = wrap.finalapp_vcas()\nparams = wrap.finalapp_vs()\nparams = wrap.landing_speed()\nparams = wrap.landing_distance()\nparams = wrap.landing_acceleration()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-normal-distribution",
    "href": "kinematic.html#example-normal-distribution",
    "title": "3  🌯 Kinematic models",
    "section": "3.2 Example, normal distribution",
    "text": "3.2 Example, normal distribution\nLet’s take an example of the take-off distance, which is obtained using the takeoff_distance() function:\n\nwrap.takeoff_distance()\n\n{'default': 1.65,\n 'minimum': 1.06,\n 'maximum': 2.24,\n 'statmodel': 'norm',\n 'statmodel_params': [1.65, 0.36]}\n\n\nHere, we can see that the mean (default) value is 1.65 km, while the minimum and maximum take-off distances are 1.06 km and 2.24 km. The parameter can be described with a normal distribution, with a mean of 1.65 and a standard deviation of 0.36.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\nparams = wrap.takeoff_distance()\n\nmean, std = params[\"statmodel_params\"]\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\ny = stats.norm.pdf(x, mean, std)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"take-off distance (km)\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-other-distributions",
    "href": "kinematic.html#example-other-distributions",
    "title": "3  🌯 Kinematic models",
    "section": "3.3 Example, other distributions",
    "text": "3.3 Example, other distributions\nWe can take another example where the distribution is not a normal distribution, such as Mach number during the cruise:\n\nparams = wrap.cruise_mach()\ndisplay(params)\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\n\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\n\ny = model.pdf(x)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"curise Mach number\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()\n\n{'default': 0.78,\n 'minimum': 0.75,\n 'maximum': 0.8,\n 'statmodel': 'beta',\n 'statmodel_params': [17.82, 5.05, 0.62, 0.2]}\n\n\n\n\n\n\n\n\n\nThe plot shows a bete distribution. However, in this example code, we do not need to specify how the model should be constructed. The following code does the trick:\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\nWith this code, we can automatically generate a parametric model using parameters from the wrap.cruise_mach() function.",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#units",
    "href": "kinematic.html#units",
    "title": "3  🌯 Kinematic models",
    "section": "3.4 Units",
    "text": "3.4 Units\nThe units of kinematic models are all in SI units, hence:\n\ndistance: in km\naltitude: in km\nspeed: in m/s\nacceleration: in m^2/s\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source kinematic aircraft performance model. Transportation Research Part C: Emerging Technologies, 98, 118–138. https://doi.org/10.1016/j.trc.2018.11.009",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "flight_phases.html",
    "href": "flight_phases.html",
    "title": "4  ㊙️ Flight phase identification",
    "section": "",
    "text": "4.1 Phase labeling\nOpenAP includes a module to identify flight phases based on flight data, such as ADS-B data. It uses the fuzzy logic, which is defined in my paper: Sun et al. (2017)\nNote that the paper was published a while ago; some improvements have been made in the logic since then. I also added a new phase to indicate level segments in the flight during the climb and descent.\nWe can use FlightPhase.phaselabel(ts, alt, spd, roc) function to identify the labels of a given set of flight states. The following flight phases are supported:\nNote that the unit for all required parameters is:\nFollowing is an example labeling process based on a real flight:\nimport pandas as pd\nfrom openap.phase import FlightPhase\n\ndf = pd.read_csv(\"assets/data/flight_a319_opensky.csv\", parse_dates=[\"timestamp\"])\n\nts = (df.timestamp - df.timestamp.iloc[0]).dt.total_seconds()  # second\nalt = df.altitude.values  # ft\nspd = df.groundspeed.values  # kts\nroc = df.vertical_rate.values  # ft/min\n\nfp = FlightPhase()\n\nfp.set_trajectory(ts, alt, spd, roc)\n\nlabels = fp.phaselabel()\nprint(labels)\n\n['CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CL', 'CL', 'CR', 'CR', 'CL', 'CR', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'NA']\nWe can visualize the identified flight phases:\nimport matplotlib.pyplot as plt\n\nphasecolors = {\n    \"GND\": \"black\",\n    \"CL\": \"green\",\n    \"DE\": \"blue\",\n    \"LVL\": \"cyan\",\n    \"CR\": \"purple\",\n    \"NA\": \"red\",\n}\n\ncolors = [phasecolors[lbl] for lbl in labels]\n\nplt.subplot(311)\nplt.scatter(ts, alt, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"altitude (ft)\")\n\nplt.subplot(312)\nplt.scatter(ts, spd, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"speed (kt)\")\n\nplt.subplot(313)\nplt.scatter(ts, roc, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"roc (fpm)\")\n\nplt.show()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>㊙️ Flight phase identification</span>"
    ]
  },
  {
    "objectID": "flight_phases.html#phase-labeling",
    "href": "flight_phases.html#phase-labeling",
    "title": "4  ㊙️ Flight phase identification",
    "section": "",
    "text": "GND: on-ground  \nCL:  climb\nDE:  descend\nLVL: level flight\nCR:  cruise\nNA:  unlabeled\n\nts:  timestamp      second\nalt: altitude       ft\nspd: speed          kts\nroc: vertical rate  ft/min\n\n\n\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction and phase identification for large automatic dependent surveillance–broadcast datasets. Journal of Aerospace Information Systems, 14(10), 566–571. https://doi.org/10.2514/1.I010520",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>㊙️ Flight phase identification</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html",
    "href": "trajectory_gen.html",
    "title": "5  💅 Trajectory generation",
    "section": "",
    "text": "5.1 Complete flight\nBased on the kinematic module from the OpenAP package, we can conveniently generate realistic flight trajectories for different flight phases, knowing the distribution of speed, vertical rates, and altitudes.\nThe gen module provides FlightGenerator class to facilitate the generation of flight trajectories.\nTo use the flight generator, we need to instantiate the FlightGenerator object by providing the aircraft typecode, as in the following example:\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom openap.gen import FlightGenerator\n\nfgen = FlightGenerator(ac=\"a320\")\nThe following blocks of code are functions for plotting the trajectories later on.\nShow the plot_traj(flight) code\nimport matplotlib\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef plot_traj(flights: pd.DataFrame | list[pd.DataFrame], lw=2):\n    if isinstance(flights, pd.DataFrame):\n        flights = [flights]\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 4))\n\n    for f in flights:\n        ax1.plot(f.t, f.altitude, lw=lw)\n        ax2.plot(f.t, f.groundspeed, lw=lw)\n        ax3.plot(f.t, f.vertical_rate, lw=lw)\n        ax4.plot(f.t, f.s / 1000, lw=lw)\n\n        ax1.set_ylabel(\"altitude (ft)\")\n        ax2.set_ylabel(\"groundspeed (kt)\")\n        ax3.set_ylabel(\"vertical rate (ft/min)\")\n        ax4.set_ylabel(\"distance flown (km)\")\n\n        ax1.set_ylim(-1000, 40_000)\n        ax2.set_ylim(0, 600)\n        ax3.set_ylim(-3000, 3000)\n\n    for ax in (ax1, ax2, ax3, ax4):\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"top\"].set_visible(False)\n        ax.yaxis.set_label_coords(-0.1, 1.05)\n        ax.yaxis.label.set_rotation(0)\n        ax.yaxis.label.set_ha(\"left\")\n        ax.grid()\n\n        plt.tight_layout()\n        plt.show()\nTo generate a complete trajectory, we can call the FlightGenerator.complete() function by specifying the time step size in seconds. The function outputs a pandas dataframe, containing altitude, flight distance, speed, and vertical_rate.\nSee an example as follows:\nflight = fgen.complete(dt=10)\ndisplay(flight)\n\nplot_traj(flight)\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\naltitude\nvertical_rate\ngroundspeed\n\n\n\n\n0\n0\n0.0\n0.000000e+00\n0.0\n0.0\n0\n0\n0\n\n\n1\n10\n0.0\n0.000000e+00\n19.3\n0.0\n0\n0\n37\n\n\n2\n20\n0.0\n1.930000e+02\n38.6\n0.0\n0\n0\n75\n\n\n3\n30\n0.0\n5.790000e+02\n57.9\n0.0\n0\n0\n112\n\n\n4\n40\n0.0\n1.158000e+03\n77.2\n0.0\n0\n0\n150\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n681\n6790\n0.0\n1.386008e+06\n59.8\n0.0\n0\n0\n116\n\n\n682\n6800\n0.0\n1.386606e+06\n47.6\n0.0\n0\n0\n92\n\n\n683\n6810\n0.0\n1.387082e+06\n35.4\n0.0\n0\n0\n68\n\n\n684\n6820\n0.0\n1.387436e+06\n23.2\n0.0\n0\n0\n45\n\n\n685\n6830\n0.0\n1.387668e+06\n11.0\n0.0\n0\n0\n21\n\n\n\n\n686 rows × 8 columns\n\n\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#flight-segments-at-different-phases",
    "href": "trajectory_gen.html#flight-segments-at-different-phases",
    "title": "5  💅 Trajectory generation",
    "section": "5.2 Flight segments at different phases",
    "text": "5.2 Flight segments at different phases\nWe can also generate partial trajectories for only climb, descent, or cruise segments of the flight. The following are three examples.\n\nflight_climb = fgen.climb(dt=10)\nplot_traj(flight_climb)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_descent = fgen.descent(dt=10)\nplot_traj(flight_descent)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_cruise = fgen.cruise(dt=10)\nplot_traj(flight_cruise)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "href": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "title": "5  💅 Trajectory generation",
    "section": "5.3 Generate flight with specific parameters",
    "text": "5.3 Generate flight with specific parameters\nPreviously, we generated the most typical flight profile based on the default values in the WRAP kinematic model. However, we can customize the generation by providing specific parameters.\nFor example, with the following code, we can specify CAS/Mach setting during the climb and the top of the climb altitude for the trajectory.\n\nflight_climb_with_params = fgen.climb(\n    dt=10,\n    cas_const_cl=280,\n    mach_const_cl=0.78,\n    alt_cr=32000,\n)\n\nplot_traj(flight_climb_with_params)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "href": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "title": "5  💅 Trajectory generation",
    "section": "5.4 Generate flights randomly sampled using the kinematic model",
    "text": "5.4 Generate flights randomly sampled using the kinematic model\nIn many use cases, we want to generate a wide range of flight trajectories. The FlightGenerator allows such a possibility. We can generate random and yet realistic trajectories like a breeze.\nYou simply need to provide the radom=True argument when generating trajectories. The generator will randomly sample parameters from the proper distribution of each parameter in the WRAP model.\nThe following example shows several randomly generated flights at different flight phases and randomly sampled complete trajectories.\n\nclimb_flights= [fgen.climb(dt=10, random=True) for i in range(5)]\n\nplot_traj(climb_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ndescent_flights = [fgen.descent(dt=10, random=True) for i in range(5)]\n\nplot_traj(descent_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncruise_flights = [fgen.cruise(dt=10, random=True) for i in range(5)]\n\nplot_traj(cruise_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#add-noise-to-the-flight-data",
    "href": "trajectory_gen.html#add-noise-to-the-flight-data",
    "title": "5  💅 Trajectory generation",
    "section": "5.5 Add noise to the flight data",
    "text": "5.5 Add noise to the flight data\nSometimes, we may also want to add some random noises to the trajectory data. With the FlightGenerator.enable_noise() function, we can make sure Gaussian noises are added to all trajectory points.\nThe noise model is based on ADS-B Version 1 and 2, with a NACv (navigation accuracy category - velocity) value of 3 and a NACp (navigation accuracy category - position) value of 10. More details can be found in Sun (2021, Chapter 9).\n\nfgen.enable_noise()  # enable Gaussian noise in trajectory data\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\n\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode s and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html",
    "href": "fuel_emission.html",
    "title": "6  🔥 Fuel and Emission",
    "section": "",
    "text": "6.1 Accuracy of the fuel model\nOpenAP provides estimations of fuel consumption and emissions based on actual flight trajectory data. The models are based on the following work:\nThe accuracy of the fuel estimation is greatly improved in the new OpenAP (v2), which is comparable to the BADA 3 fuel model. This is due to the better tuning using data-driven model, acropole, shared by @JarryGabriel.\nIn best cases, we see errors below 3%, and in the following A320 example shows an accuracy of 1% compared to the QAR data.\nFor the in-depth analysis of the accuracy affected by mass, wind, and other parameters for this flight, please see the example from the traffic library.",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#accuracy-of-the-fuel-model",
    "href": "fuel_emission.html#accuracy-of-the-fuel-model",
    "title": "6  🔥 Fuel and Emission",
    "section": "",
    "text": "fuel estimation accuracy",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "href": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "title": "6  🔥 Fuel and Emission",
    "section": "6.2 Basic usage of the fuel and emission modules",
    "text": "6.2 Basic usage of the fuel and emission modules\n\n6.2.1 Compute aircraft fuel flow:\nTo estimate fuel flow, you need to provide the aircraft type (e.g., ‘A320’) through the openap.FuelFlow object. The fuel flow model is based on: - aircraft’s mass (in kg), - true airspeed (TAS, in kts), - altitude (in ft), - and vertical speed (optional, in ft/min).\n\nfrom openap import FuelFlow\n\n# create a fuel flow model for A320\nfuelflow = FuelFlow(ac='A320')\n\n# estimate fuel flow during cruise\nFF = fuelflow.enroute(mass=60000, tas=230, alt=32000)\n\n# estimate fuel flow at climb, with vertical speed (feet/min)\nFF = fuelflow.enroute(mass=60000, tas=200, alt=20000, vs=1000)\n\n# estimate fuel flow at with a given thrust (e.g., derived from drag model)\nFF = fuelflow.at_thrust(acthr=50000, alt=30000)\n\n# estimate fuel flow at takeoff\nFF = fuelflow.takeoff(tas=100, alt=0, throttle=1)\n\n\n\n6.2.2 Compute aircraft emissions:\nThe emission model is based on the fuel flow and aircraft’s true airspeed (TAS) and altitude. The input fuel flow is in kg/s The emissions include CO2, H2O, NOx, CO, and HC, with units in g/s.\n\nfrom openap import FuelFlow, Emission\n\nfuelflow = FuelFlow(ac=\"A320\")\nemission = Emission(ac=\"A320\")\n\nTAS = 350\nALT = 30000\n\nFF = fuelflow.enroute(mass=60000, tas=TAS, alt=ALT, vs=0)  # kg/s\n\nCO2 = emission.co2(FF)  # g/s\nH2O = emission.h2o(FF)  # g/s\nNOx = emission.nox(FF, tas=TAS, alt=ALT)  # g/s\nCO = emission.co(FF, tas=TAS, alt=ALT)  # g/s\nHC = emission.hc(FF, tas=TAS, alt=ALT)  # g/s",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "href": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "title": "6  🔥 Fuel and Emission",
    "section": "6.3 Estimate fuel and emission from flight data",
    "text": "6.3 Estimate fuel and emission from flight data\nIn the following example, we estimate the fuel consumption for a given flight trajectory data obtained from the OpenSky Network. The sample data can be downloaded from https://github.com/junzis/openap/tree/master/examples.\nThe following code snippets show how to estimate fuel flow and emissions for this example flight trajectory data.\n\n6.3.1 Data exploration\nFirst, we need to import openap, pandas, and matplotlib libraries.\n\nimport pandas as pd\nimport openap\nimport matplotlib.pyplot as plt\n\nWe also need to define aircraft parameters and import data.\n\nmass_takeoff_assumed = 66300  # kg\n\nfuelflow = openap.FuelFlow(\"A319\")\n\n# Load the data\ndf = pd.read_csv(\n    \"assets/data/flight_a319_opensky.csv\",\n    parse_dates=[\"timestamp\"],\n    dtype={\"icao24\": str},\n)\n\n# Calculate seconds between each timestamp\ndf = df.assign(d_ts=lambda d: d.timestamp.diff().dt.total_seconds().bfill())\n\nLet’s see what are the features in this flight dataframe:\n\ndf\n\n\n\n\n\n\n\n\ntimestamp\nicao24\ntypecode\ncallsign\norigin\ndestination\nlatitude\nlongitude\naltitude\ngroundspeed\ntrack\nvertical_rate\nd_ts\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.085861\n2.349666\n8200.0\n255.0\n327.804266\n1920.0\n60.0\n\n\n1\n2018-01-02 19:54:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.153427\n2.310861\n9475.0\n290.0\n9.722018\n960.0\n60.0\n\n\n2\n2018-01-02 19:55:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.233367\n2.361121\n9975.0\n332.0\n23.243919\n640.0\n60.0\n\n\n3\n2018-01-02 19:56:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.319916\n2.418471\n11225.0\n353.0\n23.517962\n2752.0\n60.0\n\n\n4\n2018-01-02 19:57:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.411652\n2.478896\n14175.0\n368.0\n23.566915\n3584.0\n60.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n58.978659\n17.706646\n13250.0\n343.0\n24.471621\n-1408.0\n60.0\n\n\n112\n2018-01-02 21:45:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.062826\n17.781088\n11800.0\n326.0\n24.443955\n-1344.0\n60.0\n\n\n113\n2018-01-02 21:46:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.142609\n17.852051\n10400.0\n307.0\n24.397686\n-1216.0\n60.0\n\n\n114\n2018-01-02 21:47:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.217286\n17.918701\n9125.0\n291.0\n24.541618\n-1216.0\n60.0\n\n\n115\n2018-01-02 21:48:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.289505\n17.990112\n8075.0\n291.0\n28.500577\n-960.0\n60.0\n\n\n\n\n116 rows × 13 columns\n\n\n\nLet’s plot the altitude profile of the flight. I will also make the plots more visually appealing.\n\nfrom matplotlib import dates\n\nimport matplotlib\n\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef format_ax(ax):\n    ax.xaxis.set_major_formatter(dates.DateFormatter(\"%H:%M\"))\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.03)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 5), sharex=True)\n\nax1.plot(df.timestamp, df.altitude)\nax2.plot(df.timestamp, df.groundspeed)\nax3.plot(df.timestamp, df.vertical_rate)\n\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"groundspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.3.2 Fuel flow calculation\nNext, we iterate over the timestamp to calculate fuel flow and mass during the flight.\n\nmass_current = mass_takeoff_assumed\n\nfuelflow_every_step = []\nfuel_every_step = []\n\nfor i, row in df.iterrows():\n    ff = fuelflow.enroute(\n        mass=mass_current,\n        tas=row.groundspeed,\n        alt=row.altitude,\n        vs=row.vertical_rate,\n    )\n    fuel = ff * row.d_ts\n    fuelflow_every_step.append(ff)\n    fuel_every_step.append(ff * row.d_ts)\n    mass_current -= fuel\n\ndf = df.assign(fuel_flow=fuelflow_every_step, fuel=fuel_every_step)\n\nThen, we can visualize the fuel flow during the flight.\n\nplt.figure(figsize=(7, 2))\nplt.plot(df.timestamp, df.fuel_flow, color=\"tab:red\")\nplt.ylabel(\"fuel flow (kg/s)\")\nformat_ax(plt.gca())\nplt.show()\n\n\n\n\n\n\n\n\nWith the new dataframe, we can calculate total fuel consumption by summing the fuel consumption at overall time steps:\n\ntotal_fuel = df.fuel.sum().astype(int)\nprint(f\"Total fuel: {total_fuel} kg\")\n\nTotal fuel: 5052 kg\n\n\n\n\n6.3.3 Emission calculation\nThe emission calculations are based on the fuel consumption using the openap.Emission class.\nWe can calculate the emissions for the entire flight and append them as new columns to the dataframe as follows:\n\nemission = openap.Emission(ac=\"A319\")\n\ndf = df.assign(\n    co2_flow=lambda d: emission.co2(d.fuel_flow),\n    h2o_flow=lambda d: emission.h2o(d.fuel_flow),\n    soot_flow=lambda d: emission.soot(d.fuel_flow),\n    sox_flow=lambda d: emission.sox(d.fuel_flow),\n    nox_flow=lambda d: emission.nox(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    co_flow=lambda d: emission.co(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    hc_flow=lambda d: emission.hc(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n)\n\nLet’s visualize the emission flows:\n\nfig, axes = plt.subplots(7, 1, figsize=(5, 7), sharex=True)\n\naxes = axes.flatten()\n\nlabels = dict(\n    co2_flow=\"CO2 (g/s)\",\n    h2o_flow=\"H2O (g/s)\",\n    soot_flow=\"Soot (g/s)\",\n    sox_flow=\"SOx (g/s)\",\n    nox_flow=\"NOx (g/s)\",\n    co_flow=\"CO (g/s)\",\n    hc_flow=\"HC (g/s)\",\n)\n\nfor i, (k, v) in enumerate(labels.items()):\n    axes[i].plot(df.timestamp, df[k], color=\"tab:brown\")\n    axes[i].set_ylabel(v)\n    format_ax(axes[i])\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNote that CO2, H2O, Soot, and SOx are linear correlated to the fuel flow, following the coefficients from the paper Global Mortality Attributable to Aircraft Cruise Emissions.\n\n\n6.3.4 Final data\nThe emissions at each time step are also calculated as follows. Note that we divide values by 1000 to obtain the emissions in kg.\n\ndf = df.eval(\n    \"\"\"\n    co2 = co2_flow * d_ts / 1000\n    h2o = h2o_flow * d_ts / 1000\n    soot = soot_flow * d_ts / 1000\n    sox = sox_flow * d_ts / 1000\n    nox = nox_flow * d_ts / 1000\n    co = co_flow * d_ts / 1000\n    hc = hc_flow * d_ts / 1000\n    \"\"\"\n)\n\nWe can take a look at the final data with fuel flow and emissions columns.\n\ndf[[\"timestamp\", \"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].round(4)\n\n\n\n\n\n\n\n\ntimestamp\nfuel\nco2\nh2o\nsoot\nsox\nnox\nco\nhc\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n81.3691\n257.1265\n100.0840\n0.0024\n0.0976\n1.2232\n0.0993\n0.0027\n\n\n1\n2018-01-02 19:54:00+00:00\n61.1136\n193.1191\n75.1698\n0.0018\n0.0733\n0.7674\n0.1380\n0.0027\n\n\n2\n2018-01-02 19:55:00+00:00\n57.3222\n181.1380\n70.5063\n0.0017\n0.0688\n0.6956\n0.1402\n0.0026\n\n\n3\n2018-01-02 19:56:00+00:00\n88.5218\n279.7288\n108.8818\n0.0027\n0.1062\n1.4456\n0.0554\n0.0025\n\n\n4\n2018-01-02 19:57:00+00:00\n85.7259\n270.8939\n105.4429\n0.0026\n0.1029\n1.3834\n0.0540\n0.0025\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n27.3882\n86.5467\n33.6875\n0.0008\n0.0329\n0.2163\n0.3043\n0.0143\n\n\n112\n2018-01-02 21:45:00+00:00\n26.7537\n84.5418\n32.9071\n0.0008\n0.0321\n0.2061\n0.3411\n0.0170\n\n\n113\n2018-01-02 21:46:00+00:00\n26.5316\n83.8399\n32.6339\n0.0008\n0.0318\n0.2016\n0.3610\n0.0184\n\n\n114\n2018-01-02 21:47:00+00:00\n25.4723\n80.4924\n31.3309\n0.0008\n0.0306\n0.1865\n0.3963\n0.0210\n\n\n115\n2018-01-02 21:48:00+00:00\n28.2236\n89.1865\n34.7150\n0.0008\n0.0339\n0.2214\n0.3331\n0.0165\n\n\n\n\n116 rows × 9 columns\n\n\n\nFinally, we can obtain the total fuel consumption and emissions for the entire flight (unit in kg).\n\ndf[[\"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].sum().round(2)\n\nfuel     5052.25\nco2     15965.10\nh2o      6214.27\nsoot        0.15\nsox         6.06\nnox        55.09\nco         18.27\nhc          0.46\ndtype: float64",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "optimize.html",
    "href": "optimize.html",
    "title": "🦸 Trajectory Optimizer",
    "section": "",
    "text": "Paper\nPreviously, the majority of flight optimizers mentioned in the literature remained closed-source, which posed a significant drawback in terms of reproducible research.\nThe trajectory optimizer (TOP) addresses this lack of open-source flight trajectory optimizer by providing everyone with open access to trajectory optimization based on a non-linear optimal control direct collocation approach.\nThe TOP library can consider 3D or 4D wind fields. It can be utilized in various flight phases, either individually or in combination. It provides traditional fuel and cost index objectives alongside climate metrics-based objectives that incorporate global warming or temperature potential.\nFurthermore, I have designed a mechanism to include a complex 4D cost grid in trajectory optimization. This new mechanism allows easy generation of, for example, contrail-optimal trajectories.\nThe optimization framework was first published in my following paper: Sun (2022)\nNote that there have been quite many improvements and changes to the software code since the paper was published.",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize.html#install",
    "href": "optimize.html#install",
    "title": "🦸 Trajectory Optimizer",
    "section": "Install",
    "text": "Install\nThe opeanp.top library is designed to be a module inside the openap scope. You can install the most recent release thorugh pip:\npip install --upgrade openap-top\nThis will install openap.top and related dependencies.\nAlternatively, if you want to install the most recent development version:\npip install --upgrade git+https://github.com/junzis/openap-top\n\n\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air transport and sustainability research. Aerospace, 9(7), 383. https://doi.org/10.3390/aerospace9070383",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize-basic.html",
    "href": "optimize-basic.html",
    "title": "7  🍳 Simple optimal flights",
    "section": "",
    "text": "7.1 Quick start\nExample code to generate a fuel-optimal flight between two airports. First, we need to set up a few parameters, including origin, destination, actype, and m0 (initial mass).\nThe initial mass m0 can be the fraction of the maximum take-off mass (between 0 and 1), or it can be the mass in kg (for example, 65000 kg).\nfrom openap import top\n\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\nIn this simple example, we will generate a complete flight using top.CompleteFlight(). We will generate a fuel-optimal flight by setting objective to \"fuel\" in the trajectory generation function.\noptimizer = top.CompleteFlight(actype, origin, destination, m0=m0)\n\nflight = optimizer.trajectory(objective=\"fuel\")\nflight.head()\n\n\n\n\n\n\n\n\nts\nx\ny\nh\nlatitude\nlongitude\naltitude\nmach\ntas\nvertical_rate\nheading\nmass\nfuel\n\n\n\n\n0\n0.0\n-652425.011796\n840651.921723\n30.480000\n52.316584\n4.746242\n100.0\n0.3000\n198.38\n1155.0\n129.51\n66300.000000\n323.453100\n\n\n1\n240.0\n-633558.159907\n825096.159139\n1436.318481\n52.198631\n5.049358\n4712.0\n0.5000\n325.34\n1655.0\n136.98\n65976.546900\n331.354128\n\n\n2\n479.0\n-606683.338596\n796291.656447\n3450.878939\n51.970046\n5.489819\n11322.0\n0.6869\n436.31\n2155.0\n136.98\n65645.192772\n336.848071\n\n\n3\n719.0\n-571046.986084\n758096.521947\n6074.161370\n51.664464\n6.067002\n19928.0\n0.7590\n466.37\n1655.0\n136.98\n65308.344701\n310.562739\n\n\n4\n959.0\n-532644.746482\n716936.902531\n8088.721824\n51.332075\n6.680337\n26538.0\n0.7970\n476.69\n1155.0\n136.98\n64997.781962\n270.746816\nIn the previous table, we have the final fuel-optimal trajectory. Next, we can visualize the altitude, speed, and vertical rate.\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\n# function to make plot nicer\ndef format_ax(ax):\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.05)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 4), sharex=True)\nax1.plot(flight.ts, flight.altitude)\nax2.plot(flight.ts, flight.tas)\nax3.plot(flight.ts, flight.vertical_rate)\nax1.set_ylim(0, 40000)\nax2.set_ylim(0, 600)\nax3.set_ylim(-3000, 3000)\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"true airspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\nax3.set_xlabel(\"time(s)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize-basic.html#other-objective-functions",
    "href": "optimize-basic.html#other-objective-functions",
    "title": "7  🍳 Simple optimal flights",
    "section": "7.2 Other objective functions",
    "text": "7.2 Other objective functions\nInstead of the default objective functions, you can also specify different objective functions as follows:\n# cost index, between 0 - 100\nflight = optimizer.trajectory(objective=\"ci:30\")\n\n# global warming potential\nflight = optimizer.trajectory(objective=\"gwp100\")\n\n# global temperature potential\nflight = optimizer.trajectory(objective=\"gtp100\")\nThe final flight object is a pandas DataFrame.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize-basic.html#different-flight-phases",
    "href": "optimize-basic.html#different-flight-phases",
    "title": "7  🍳 Simple optimal flights",
    "section": "7.3 Different flight phases",
    "text": "7.3 Different flight phases\nInstead of generating a complete flight, we can also generate cruise, climb, and descent flights using top.Crusie, top.Climb, and top.Descent classes.\n\ncruise_flight = top.Cruise(actype, origin, destination, m0=m0).trajectory()\n\nclimb_flight = top.Climb(actype, origin, destination, m0=m0).trajectory()\n\ndescent_flight = top.Descent(actype, origin, destination, m0=m0).trajectory()\n\nLet’s visulize these trajectories:\n\nlabels = (\"cruise flight\", \"climb flight\", \"descent flight\")\n\nfig, axes = plt.subplots(3, 3, figsize=(10, 4))\n\nfor i, flight in enumerate([cruise_flight, climb_flight, descent_flight]):\n    ax1, ax2, ax3 = axes[:, i]\n    ax1.plot(flight.ts, flight.altitude)\n    ax2.plot(flight.ts, flight.tas)\n    ax3.plot(flight.ts, flight.vertical_rate)\n    ax1.set_ylabel(\"altitude (ft)\")\n    ax2.set_ylabel(\"true airspeed (kts)\")\n    ax3.set_ylabel(\"vertical rate (ft/min)\")\n    ax1.set_ylim(0, 40000)\n    ax2.set_ylim(0, 600)\n    ax3.set_ylim(-3000, 3000)\n    ax1.set_title(labels[i], pad=20)\n    ax3.set_xlabel(\"time(s)\")\n\nfor ax in axes.flatten():\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize-wind.html",
    "href": "optimize-wind.html",
    "title": "8  🌪️ Wind optimal flights",
    "section": "",
    "text": "8.1 Obtaining wind with fastmeteo\nFlight trajectory optimization considering wind conditions is crucial for efficient flight planning. Wind can significantly impact flight time, fuel consumption, and overall flight efficiency. For example, a favorable tailwind can help reduce flight time and fuel burn, while headwinds can have the opposite effect.\nThere are two main approaches to incorporate wind data when using ‘openap.top’ trajectory optimization:\nIt is also possible to include 3D or 4D wind data in the optimization. The following code provides an example of such a use case. Note that the wind data is obtained using fastmeteo library in this example.\nimport fastmeteo\nimport numpy as np\nimport pandas as pd\nimport openap\n\nfrom openap import top\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\nm0 = 0.85\nNext, we need to get an example wind field data using the fastmeteo library. Note the selected ERA5 data will be cached temporarily at /tmp/era5-zarr.\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\n\n# get the boundary of the wind field\no = openap.nav.airport(origin)\nd = openap.nav.airport(destination)\n\nlatmin = round(min(o[\"lat\"], d[\"lat\"])) - 2\nlatmax = round(max(o[\"lat\"], d[\"lat\"])) + 2\nlonmin = round(min(o[\"lon\"], d[\"lon\"])) - 4\nlonmax = round(max(o[\"lon\"], d[\"lon\"])) + 4\n\n# create the and flatten the wind grid\nlatitudes = np.arange(latmin, latmax, 0.5)\nlongitudes = np.arange(lonmin, lonmax, 1)\naltitudes = np.arange(1000, 46000, 2000)\ntimestamps = pd.date_range(\"2021-05-01 08:00:00\", \"2021-05-01 15:00:00\", freq=\"1H\")\n\nlatitudes, longitudes, altitudes, times = np.meshgrid(\n    latitudes, longitudes, altitudes, timestamps\n)\n\ngrid = pd.DataFrame().assign(\n    latitude=latitudes.flatten(),\n    longitude=longitudes.flatten(),\n    altitude=altitudes.flatten(),\n    timestamp=times.flatten(),\n)\n\n# obtain the wind based on the grid\nfmg = fastmeteo.Grid(local_store=\"/tmp/era5-zarr\")\n\nmeteo_data = fmg.interpolate(grid)\nLet’s take a look at the meteorological data we got:\nmeteo_data.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\naltitude\ntimestamp\nu_component_of_wind\nv_component_of_wind\ntemperature\nspecific_humidity\n\n\n\n\n0\n36.0\n1\n1000\n2021-05-01 08:00:00\n4.133623\n3.570823\n287.546767\n0.006717\n\n\n1\n36.0\n1\n1000\n2021-05-01 09:00:00\n5.019323\n2.913781\n288.905607\n0.006309\n\n\n2\n36.0\n1\n1000\n2021-05-01 10:00:00\n6.375478\n1.566804\n289.427981\n0.005825\n\n\n3\n36.0\n1\n1000\n2021-05-01 11:00:00\n6.242283\n0.733652\n290.577190\n0.005545\n\n\n4\n36.0\n1\n1000\n2021-05-01 12:00:00\n6.493321\n-0.154844\n291.026445\n0.005734\nBefore passing this wind field to the optimizer, we need to format it correctly. The wind data needs to be in pandas.DataFrame with the following columns: - ts: timestamp in seconds, with 0 representing the time of departure of the flight - latitude: latitude of all the grid points - longitude: longitude of all the grid points - h: height of the grid points, in meters - u: u component of the wind for each grid point, in m/s - v: v component of the wind for each grid point, in m/s\nwind = (\n    meteo_data.rename(\n        columns={\n            \"u_component_of_wind\": \"u\",\n            \"v_component_of_wind\": \"v\",\n        }\n    )\n    .assign(ts=lambda x: (x.timestamp - x.timestamp.iloc[0]).dt.total_seconds())\n    .eval(\"h=altitude * 0.3048\")\n)[[\"ts\", \"latitude\", \"longitude\", \"h\", \"u\", \"v\"]]\n\nwind.head()\n\n\n\n\n\n\n\n\nts\nlatitude\nlongitude\nh\nu\nv\n\n\n\n\n0\n0.0\n36.0\n1\n304.8\n4.133623\n3.570823\n\n\n1\n3600.0\n36.0\n1\n304.8\n5.019323\n2.913781\n\n\n2\n7200.0\n36.0\n1\n304.8\n6.375478\n1.566804\n\n\n3\n10800.0\n36.0\n1\n304.8\n6.242283\n0.733652\n\n\n4\n14400.0\n36.0\n1\n304.8\n6.493321\n-0.154844\nLast, we can run the optimization with the wind field and visulize the result:\nimport matplotlib.pyplot as plt\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, wind_sample=25)\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>🌪️ Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize-wind.html#using-grid-wind-files",
    "href": "optimize-wind.html#using-grid-wind-files",
    "title": "8  🌪️ Wind optimal flights",
    "section": "8.2 Using grid wind files",
    "text": "8.2 Using grid wind files\nYou can also optimize the trajectory with grid atmospheric data, for example, grib or nc files downloaded from the ECMWF or GFS. In TOP, there is a built-in function top.tools.read_grids() that can be used to process grid data files into a DataFrame for the optimizer.\n\n# read the downloaded ERA5 grib data, the arguments can be a list of files.\nwind = top.tools.read_grids(\"tmp/era5_2021-05-01_0800.grib\")\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, wind_sample=25)\nplt.show()\n\n\n\n\n\n\n\n\nSince the grib data from a similar time frame was downloaded, we can observe that the result is similar to the one from the previous section. The advantage is that the code is relatively simple compared to the previous example, which used fastmeteo to download data that covers the region of the flights.\nHowever, this approach requires a large quantity of grid data to be downloaded first. The read_grids() function also loads the entire grid files into RAM, which can be memory intensive if many grid files are loaded.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>🌪️ Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bartel, M., & Young, T. M. (2008). Simplified thrust and fuel\nconsumption models for modern two-shaft turbofan engines. Journal of\nAircraft, 45(4), 1450–1456.\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode\ns and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air\ntransport and sustainability research. Aerospace,\n9(7), 383. https://doi.org/10.3390/aerospace9070383\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction\nand phase identification for large automatic dependent\nsurveillance–broadcast datasets. Journal of Aerospace Information\nSystems, 14(10), 566–571. https://doi.org/10.2514/1.I010520\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source\nkinematic aircraft performance model. Transportation Research Part\nC: Emerging Technologies, 98, 118–138. https://doi.org/10.1016/j.trc.2018.11.009\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft\ndrag polar using open flight surveillance data and a stochastic total\nenergy model. Transportation Research Part C: Emerging\nTechnologies, 114, 391–404. https://doi.org/10.1016/j.trc.2020.01.026",
    "crumbs": [
      "References"
    ]
  }
]