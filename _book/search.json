[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The OpenAP Handbook",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#synopsis",
    "href": "index.html#synopsis",
    "title": "The OpenAP Handbook",
    "section": "Synopsis",
    "text": "Synopsis\nWelcome to the OpenAP handbook, a comprehensive guide to unlocking the full potential of the OpenAP aircraft performance library. This book is designed to help you navigate the vast capabilities of OpenAP, an open-source initiative that has been revolutionizing air transport research since its inception in 2019.\nThe first part of this book takes you through the core components that form the foundation of OpenAP. From the fundamentals of aircraft and engine data (Chapter 1) to the intricacies of drag and maximum thrust calculations (Chapter 2), kinematic models (Chapter 3), and flight phase identification (Chapter 4), we delve into the key components that make OpenAP an indispensable tool for researchers, developers, and aviation professionals. You will also learn how to harness OpenAP‚Äôs trajectory generation capabilities (Chapter 5) and analyze fuel and emission data (Chapter 6).\nThe second part focuses on the Trajectory Optimizer Package (TOP), an extension of OpenAP. Here, you will learn how to generate fuel-optimal and other types of optimal trajectories (Chapter 7). You will discover how to incorporate wind data into your optimizations (Chapter 8). Additionally, you will learn how to use TOP to handle more complex four-dimensional grid costs in your optimization problems, such as contrail formation (Chapter 9).\nEach chapter provides detailed insights into the underlying concepts, methodologies, and best practices, empowering you to make the most of OpenAP. Whether you‚Äôre a seasoned expert or new to the field, this manual will help you navigate the OpenAP library effectively. The goal is to equip you with the knowledge and skills necessary to leverage OpenAP in your research. Let‚Äôs embark on this journey together and explore the possibilities that OpenAP has to offer.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-the-authors",
    "href": "index.html#about-the-authors",
    "title": "The OpenAP Handbook",
    "section": "About the Authors",
    "text": "About the Authors\nJunzi Sun is an assistant professor in the CNS/ATM group at the TU Delft Faculty of Aerospace Engineering. His research focuses on aircraft surveillance and performance modeling, data science and AI, and aviation sustainability. Passionate about open-source and open science, he aims to make air transportation more sustainable. Born in China, he earned his bachelor‚Äôs in telecommunication in Beijing before moving to Europe for his master‚Äôs in aerospace engineering at the Polytechnic University of Catalonia. After working in Spain and France, he completed his doctoral research in the Netherlands, where he currently works and lives.\nJacco Hoekstra is a professor in the CNS/ATM group at the TU Delft Faculty of Aerospace Engineering with a focus on enhancing aviation safety, efficiency, and sustainability. As the Chair of CNS/ATM, his research employs simulation, signal processing, and big data to create solutions for avoiding in-flight hazards. He is recognized for contributions to airborne separation assurance, data link technology, and 4D trajectory-based operations. His former roles include the Dean of the Faculty of Aerospace Engineering and the Head of the Air Transport Division at the Netherlands Aerospace Laboratory.\n\nThis online book is created with Quarto. To learn more about Quarto books, visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "openap.html",
    "href": "openap.html",
    "title": "üöÄ OpenAP",
    "section": "",
    "text": "Chapters\nOpenAP is an open-source aircraft performance library that aims to support air transportation research and simulations. It provides aircraft performance models and relevant data, allowing users to calculate key flight parameters such as drag, thrust, and fuel consumption.\nThe library also enables users to estimate aircraft emissions, generate flight trajectories based on kinematic parameters, and identify different flight phases. With its modular Python code, OpenAP can be used for various applications, from basic performance calculations to complex trajectory optimization (with the openap.top extension). The library combines both empirical data collected from literature, and parameters derived from open sources data. The model and associated Python library has been fairly widely used in academic research, flight simulation, and air traffic management studies.\nOpenAP library has two parts: OpenAP model data and Python modules. The model data includes aircraft, engine, drag polar, kinematic, and navigation data. The Python modules provide functionalities for computing aircraft performance, emissions, and trajectories. The library is designed to be user-friendly, flexible, and extensible, allowing users to easily integrate it into their projects.\nThe user guide for OpenAP is organized into the following chapters:",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#chapters",
    "href": "openap.html#chapters",
    "title": "üöÄ OpenAP",
    "section": "",
    "text": "Chapter 1: Aircraft and engines\nChapter 2: Drag and thrust\n\nChapter 3: Kinematic models\nChapter 4: Flight phase identification\nChapter 5: Trajectory generation\nChapter 6: Fuel and Emission",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#data",
    "href": "openap.html#data",
    "title": "üöÄ OpenAP",
    "section": "Data",
    "text": "Data\nFollow model datasets are all made public, under GPL open-source license:\n\nAircraft data: Collected from open literature.\nEngines data: Primarily from the ICAO emission data bank, including fuel flow and emissions.\nDrag polar data: Exclusively derived from open data (reference).\nKinematic data: Kinematic model (formally WRAP) describe speed, altitude, and vertical rate.\nNavigation data: Airport and waypoints obtained from X-plane.",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#modules",
    "href": "openap.html#modules",
    "title": "üöÄ OpenAP",
    "section": "Modules",
    "text": "Modules\nOpenAP Python library includes the following modules, which support a variety of functionalities, including performance models, emission models, trajectory generation, and trajectory optimization:\n\nprop: module for accessing aircraft and engine data\nthrust: module for computing aircraft maximum thrust\ndrag: module for computing aircraft drag\nfuel: module for computing fuel flow\nemission: module for computing aircraft emissions\nkinematic: module for accessing kinematic data\naero: module for common aeronautical conversions\nnav: module for accessing navigation information\nphase: module for determining climb, cruise, descent, level flight\ntraj: module for generating trajectories based on the kinematic model\n\nOther modules that can be installed separately:\n\ntop: a package for generating optimal trajectories (see Trajectory Optimization chapter)",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#install",
    "href": "openap.html#install",
    "title": "üöÄ OpenAP",
    "section": "Install",
    "text": "Install\nInstall the stable release from pypi:\npip install --upgrade openap\nOr, you can also install the latest development version from GitHub:\npip install --upgrade git+https://github.com/junzis/openap",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#using-openap",
    "href": "openap.html#using-openap",
    "title": "üöÄ OpenAP",
    "section": "Using OpenAP",
    "text": "Using OpenAP\nMost of the functionalities (except aircraft and engine properties) in OpenAP are provided as Python classes. You can import these as follows:\nfrom openap.prop import aircraft, engine\nfrom openap.drag import Drag\nfrom openap.thrust import Thrust\nfrom openap.kinematic import WRAP\nfrom openap.phase import FlightPhase\nfrom openap.gen import FlightGenerator\nfrom openap.fuel import FuelFlow\nfrom openap.emission import Emission\n\n# when opeap-top is installed\nfrom openap.top import CompleteFlight, Climb, Cruise, Descent, MultiPhase\nYou can also import these Classes directly from the openap package as:\nfrom openap import (\n    Drag,\n    Thrust,\n    WRAP,\n    FlightPhase,\n    FlightGenerator,\n    FuelFlow,\n    Emission,\n)",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#contribute",
    "href": "openap.html#contribute",
    "title": "üöÄ OpenAP",
    "section": "Contribute",
    "text": "Contribute\nIf you encounter any issues, please file a bug report on the GitHub issue tracker. You are even more welcomed to contribute to the project by submitting a pull request.",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "openap.html#book-and-paper",
    "href": "openap.html#book-and-paper",
    "title": "üöÄ OpenAP",
    "section": "Book and Paper",
    "text": "Book and Paper\nThe OpenAP is the one outcome of my PhD research work (2015-2019). The Python library was first published in the following paper: Sun (2022)\nTo cite the paper:\n@article{sun2020openap,\n  title = {OpenAP: An open-source aircraft performance model for air transportation studies and simulations},\n  author = {Sun, Junzi and Hoekstra, Jacco and Ellerbroek, Joost},\n  journal = {Aerospace},\n  volume = {7},\n  number = {8},\n  pages = {104},\n  year = {2020},\n  month = jul,\n  publisher = {Multidisciplinary Digital Publishing Institute},\n  link = {https://doi.org/10.3390/aerospace7080104},\n  doi = {10.3390/aerospace7080104},\n}\n\n\n\n\n\n\nCaution\n\n\n\nThe libaray has evolved significantly since the paper‚Äôs publication. Key improvements include:\n\nUpdated aircraft and engine data\nMore accuracte fuel flow and emissions models\nSymbolic implementation for optimization with CasADi\n\n\n\n\n\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air transport and sustainability research. Aerospace, 9(7), 383. https://doi.org/10.3390/aerospace9070383",
    "crumbs": [
      "üöÄ OpenAP"
    ]
  },
  {
    "objectID": "aircraft_engine.html",
    "href": "aircraft_engine.html",
    "title": "1¬† ü™¨ Aircraft and engines",
    "section": "",
    "text": "1.1 Supported aircraft type codes\nThe prop package in openap allows users to obtain aircraft and engine-related data quickly. We will demonstrate usage through the following example.\nFirst, we need to import the prop package from the OpenAP library.\nfrom openap import prop\nfrom pprint import pprint\nWe can get a list of available aircraft openap.prop.available_aircraft() function:\navaiable_aircraft = prop.available_aircraft()\n\nprint(f\"Supports {len(avaiable_aircraft)} aircraft types\")\nprint(avaiable_aircraft)\n\nSupports 36 aircraft types\n['a19n', 'a20n', 'a21n', 'a318', 'a319', 'a320', 'a321', 'a332', 'a333', 'a343', 'a359', 'a388', 'b37m', 'b38m', 'b39m', 'b3xm', 'b734', 'b737', 'b738', 'b739', 'b744', 'b748', 'b752', 'b763', 'b772', 'b773', 'b77w', 'b788', 'b789', 'c550', 'e145', 'e170', 'e190', 'e195', 'e75l', 'glf6']",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>ü™¨ Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#aircraft-data",
    "href": "aircraft_engine.html#aircraft-data",
    "title": "1¬† ü™¨ Aircraft and engines",
    "section": "1.2 Aircraft data",
    "text": "1.2 Aircraft data\nWe can get the parameters for one aircraft using openap.prop.aircraft() function:\n\naircraft = prop.aircraft(\"A320\")\npprint(aircraft)\n\n{'aircraft': 'Airbus A320',\n 'ceiling': 12500,\n 'cruise': {'height': 11000, 'mach': 0.78},\n 'drag': {'cd0': 0.018, 'e': 0.799, 'gears': 0.017, 'k': 0.039},\n 'engine': {'default': 'CFM56-5B4',\n            'mount': 'wing',\n            'number': 2,\n            'options': {'A320-111': 'CFM56-5-A1',\n                        'A320-211': 'CFM56-5-A1',\n                        'A320-212': 'CFM56-5A3',\n                        'A320-214': 'CFM56-5B4',\n                        'A320-215': 'CFM56-5B5',\n                        'A320-216': 'CFM56-5B6',\n                        'A320-231': 'V2500-A1',\n                        'A320-232': 'V2527-A5',\n                        'A320-233': 'V2527E-A5'},\n            'type': 'turbofan'},\n 'flaps': {'Sf/S': 0.17,\n           'area': 21.1,\n           'bf/b': 0.78,\n           'cf/c': 0.176,\n           'lambda_f': 0.9,\n           'type': 'single-slotted'},\n 'fuel': {'engine': 'CFM56-5B4/P', 'fuel_coef': 2.65942225},\n 'fuselage': {'height': 4.14, 'length': 37.57, 'width': 3.95},\n 'limits': {'MFC': 24210,\n            'MLW': 66000,\n            'MMO': 0.82,\n            'MTOW': 78000,\n            'OEW': 42600,\n            'VMO': 350,\n            'ceiling': 12500},\n 'mfc': 24210,\n 'mlw': 66000,\n 'mmo': 0.82,\n 'mtow': 78000,\n 'oew': 42600,\n 'pax': {'high': 170, 'low': 140, 'max': 180},\n 'vmo': 350,\n 'wing': {'area': 124, 'mac': 4.1935, 'span': 35.8, 'sweep': 25, 't/c': None}}",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>ü™¨ Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#engine-data",
    "href": "aircraft_engine.html#engine-data",
    "title": "1¬† ü™¨ Aircraft and engines",
    "section": "1.3 Engine data",
    "text": "1.3 Engine data\nThe engine data can be obtained with openap.prop.engine() function:\n\nengine = prop.engine(\"CFM56-5B4\")\nengine\n\n{'uid': '2CM014',\n 'name': 'CFM56-5B4',\n 'manufacturer': 'CFM International',\n 'type': 'TF',\n 'bpr': 5.9,\n 'pr': 27.1,\n 'max_thrust': 117900,\n 'ei_hc_to': 0.1,\n 'ei_hc_co': 0.1,\n 'ei_hc_app': 0.13,\n 'ei_hc_idl': 3.87,\n 'ei_co_to': 0.5,\n 'ei_co_co': 0.5,\n 'ei_co_app': 2.33,\n 'ei_co_idl': 31.9,\n 'ei_nox_to': 28.7,\n 'ei_nox_co': 23.3,\n 'ei_nox_app': 10.0,\n 'ei_nox_idl': 4.3,\n 'ff_to': 1.166,\n 'ff_co': 0.961,\n 'ff_app': 0.326,\n 'ff_idl': 0.107,\n 'fuel_lto': 421.0,\n 'fuel_c3': 0.0468598,\n 'fuel_c2': 0.202282,\n 'fuel_c1': 0.871899,\n 'fuel_a': 0.587855,\n 'fuel_b': 0.417561,\n 'cruise_thrust': 22241.0,\n 'cruise_sfc': 0.0154,\n 'cruise_mach': 0.8,\n 'cruise_alt': 35000.0,\n 'fuel_ch': 5.2e-07}",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>ü™¨ Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html",
    "href": "drag_thrust.html",
    "title": "2¬† ‚òØÔ∏è Drag and thrust",
    "section": "",
    "text": "2.1 Compute the aircraft drag\nThe OpenAP provides two modules, drag and thrust, for the calculation of drag force and maximum available thrust force during the flight.\nThe drag calculation is based on the OpenAP‚Äôs drag polar model, which is obtained based on open trajectory data and methodology from the paper: Sun et al. (2020).\nKnowing the drag polar coefficients - \\(C_{d0}\\) (zero-lift drag coefficient) and \\(k\\) (lift-induced drag coefficient) - of the aircraft, the drag force can be calculated based on the point-mass aircraft performance model:\n\\[\n\\begin{aligned}\nC_l &= \\frac{L}{1/2~\\rho v^2 S} = \\frac{mg}{1/2~\\rho v^2 S} \\\\\nC_d &= C_{d0} + k C_l^2 \\\\\nD &= C_d \\cdot \\frac{1}{2} \\rho v^2 S\n\\end{aligned}\n\\]\nWhen an aircraft is climbing and descending, the flight path angle is also considered to calculate the lift force. Hence, by including the vertical speed, the estimation of drag can be different.\nAn example calculation using the OpenAP‚Äôs drag module is:\nfrom openap.drag import Drag\n\ntypecode = \"A320\"\n\nmass = 62_000  # kg\nTAS = 250  # kts\nALT = 20_000  # ft\nVS = 1000  # ft/min\n\ndrag = Drag(ac=typecode)\n\n# clean configuration\nD = drag.clean(mass=mass, tas=TAS, alt=ALT, vs=VS)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nClean configuration \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:250  ALT:20000  VS:1000 \nClean configuration \n\nTotal drag is 33.0 kN\nThe drag.clean() function estimates the drag force when the aircraft is at the clean configuration, which means no flaps or landing gear are deployed.\nDuring the initial climb and approach, we can also calculate drag considering flaps (providing the flaps setting angle in degrees) and whether the landing gears are extended.\nmass = 62_000  # kg\nTAS = 150  # kts\nALT = 1000  # ft\nVS = 1500  # ft/min\nflap_angle = 20  # degree\n\n# with flaps and landing gears\nD = drag.nonclean(\n    mass=mass,\n    tas=TAS,\n    alt=ALT,\n    flap_angle=flap_angle,\n    vs=VS,\n    landing_gear=True,\n)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nFlap:{flap_angle} deg,  Landing Gear extended \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:150  ALT:1000  VS:1500 \nFlap:20 deg,  Landing Gear extended \n\nTotal drag is 46.0 kN",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>‚òØÔ∏è Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "href": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "title": "2¬† ‚òØÔ∏è Drag and thrust",
    "section": "2.2 Compute maximum aircraft engine thrust",
    "text": "2.2 Compute maximum aircraft engine thrust\nOpenAP implements the engine thrust model proposed by Bartel & Young (2008). Small adjustments to the model was made to improve the computational efficiency.\nTo calculate the maximum net thrust of an aircraft, we first instantiate the thrust.Thrust object:\n\nfrom openap.thrust import Thrust\n\nthr_a320 = Thrust(ac=\"A320\", eng=\"CFM56-5B4\")\n\nThe function Thrust.takeoff() function is used to calculate maximum thrust during the take-off at different speed (kts) and altitude (ft) conditions, for example:\n\nT = thr_a320.takeoff(tas=100, alt=0)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 200.72 kN\n\n\nThe Thrust.climb() function estimates the maximum net thrust during the climb, which requires TAS (kts), altitude (ft), and rate of climb (ft/min).\nAn example for A320 climbing at 1000 ft/min at 10,000 ft with TAS 250 kts:\n\nT = thr_a320.climb(tas=250, alt=10000, roc=1000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 89.23 kN\n\n\nThe Thrust.cruise() function estimates the maximum net thrust during the cruise at different speeds and altitudes. An example is shown as follows.\n\nT = thr_a320.cruise(tas=300, alt=32000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 53.68 kN",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>‚òØÔ∏è Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#idle-thrust",
    "href": "drag_thrust.html#idle-thrust",
    "title": "2¬† ‚òØÔ∏è Drag and thrust",
    "section": "2.3 Idle thrust",
    "text": "2.3 Idle thrust\nFurthermore, we can use the Thrust.descent_ide() function to estimate the idle thrust during the descent at different altitude and speed conditions.\nThe idle thrust is modeled as approximately 7% of the maximum thrust at the same altitude and speed.\nAn example is shown as follows:\n\nT = thr_a320.descent_idle(tas=250, alt=10000)\nprint(f\"Idle thrust: {round(T/1000, 2)} kN\")\n\nIdle thrust: 9.31 kN\n\n\n\n\n\n\nBartel, M., & Young, T. M. (2008). Simplified thrust and fuel consumption models for modern two-shaft turbofan engines. Journal of Aircraft, 45(4), 1450‚Äì1456.\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft drag polar using open flight surveillance data and a stochastic total energy model. Transportation Research Part C: Emerging Technologies, 114, 391‚Äì404. https://doi.org/10.1016/j.trc.2020.01.026",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>‚òØÔ∏è Drag and thrust</span>"
    ]
  },
  {
    "objectID": "kinematic.html",
    "href": "kinematic.html",
    "title": "3¬† üåØ Kinematic models",
    "section": "",
    "text": "3.1 Parametric models\nOpenAP includes a set of kinematic models that describe speeds, vertical rates, altitudes, distance, and other parameters during different phases of a flight. The kinematic model, named WRAP, is constructed based on the method from the paper: Sun et al. (2019)\nFollowing is a list of functions that can be used to access parameters at different phases of flight, for example, flight type code A320:\nfrom openap.kinematic import WRAP\n\nwrap = WRAP(ac=\"A320\")",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>üåØ Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#parametric-models",
    "href": "kinematic.html#parametric-models",
    "title": "3¬† üåØ Kinematic models",
    "section": "",
    "text": "params = wrap.takeoff_speed()\nparams = wrap.takeoff_distance()\nparams = wrap.takeoff_acceleration()\nparams = wrap.initclimb_vcas()\nparams = wrap.initclimb_vs()\nparams = wrap.climb_range()\nparams = wrap.climb_const_vcas()\nparams = wrap.climb_const_mach()\nparams = wrap.climb_cross_alt_concas()\nparams = wrap.climb_cross_alt_conmach()\nparams = wrap.climb_vs_pre_concas()\nparams = wrap.climb_vs_concas()\nparams = wrap.climb_vs_conmach()\nparams = wrap.cruise_range()\nparams = wrap.cruise_alt()\nparams = wrap.cruise_init_alt()\nparams = wrap.cruise_mach()\nparams = wrap.descent_range()\nparams = wrap.descent_const_mach()\nparams = wrap.descent_const_vcas()\nparams = wrap.descent_cross_alt_conmach()\nparams = wrap.descent_cross_alt_concas()\nparams = wrap.descent_vs_conmach()\nparams = wrap.descent_vs_concas()\nparams = wrap.descent_vs_post_concas()\nparams = wrap.finalapp_vcas()\nparams = wrap.finalapp_vs()\nparams = wrap.landing_speed()\nparams = wrap.landing_distance()\nparams = wrap.landing_acceleration()",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>üåØ Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-normal-distribution",
    "href": "kinematic.html#example-normal-distribution",
    "title": "3¬† üåØ Kinematic models",
    "section": "3.2 Example, normal distribution",
    "text": "3.2 Example, normal distribution\nLet‚Äôs take an example of the take-off distance, which is obtained using the takeoff_distance() function:\n\nwrap.takeoff_distance()\n\n{'default': 1.65,\n 'minimum': 1.06,\n 'maximum': 2.24,\n 'statmodel': 'norm',\n 'statmodel_params': [1.65, 0.36]}\n\n\nHere, we can see that the mean (default) value is 1.65 km, while the minimum and maximum take-off distances are 1.06 km and 2.24 km. The parameter can be described with a normal distribution, with a mean of 1.65 and a standard deviation of 0.36.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\nparams = wrap.takeoff_distance()\n\nmean, std = params[\"statmodel_params\"]\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\ny = stats.norm.pdf(x, mean, std)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"take-off distance (km)\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>üåØ Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-other-distributions",
    "href": "kinematic.html#example-other-distributions",
    "title": "3¬† üåØ Kinematic models",
    "section": "3.3 Example, other distributions",
    "text": "3.3 Example, other distributions\nWe can take another example where the distribution is not a normal distribution, such as Mach number during the cruise:\n\nparams = wrap.cruise_mach()\ndisplay(params)\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\n\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\n\ny = model.pdf(x)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"curise Mach number\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()\n\n{'default': 0.78,\n 'minimum': 0.75,\n 'maximum': 0.8,\n 'statmodel': 'beta',\n 'statmodel_params': [17.82, 5.05, 0.62, 0.2]}\n\n\n\n\n\n\n\n\n\nThe plot shows a bete distribution. However, in this example code, we do not need to specify how the model should be constructed. The following code does the trick:\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\nWith this code, we can automatically generate a parametric model using parameters from the wrap.cruise_mach() function.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>üåØ Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#units",
    "href": "kinematic.html#units",
    "title": "3¬† üåØ Kinematic models",
    "section": "3.4 Units",
    "text": "3.4 Units\nThe units of kinematic models are all in SI units, hence:\n\ndistance: in km\naltitude: in km\nspeed: in m/s\nacceleration: in m^2/s\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source kinematic aircraft performance model. Transportation Research Part C: Emerging Technologies, 98, 118‚Äì138. https://doi.org/10.1016/j.trc.2018.11.009",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>üåØ Kinematic models</span>"
    ]
  },
  {
    "objectID": "flight_phases.html",
    "href": "flight_phases.html",
    "title": "4¬† „äôÔ∏è Flight phase identification",
    "section": "",
    "text": "4.1 Phase labeling\nOpenAP includes a module to identify flight phases based on flight data, such as ADS-B data. It uses the fuzzy logic, which is defined in my paper: Sun et al. (2017)\nNote that the paper was published a while ago; some improvements have been made in the logic since then. I also added a new phase to indicate level segments in the flight during the climb and descent.\nWe can use FlightPhase.phaselabel(ts, alt, spd, roc) function to identify the labels of a given set of flight states. The following flight phases are supported:\nNote that the unit for all required parameters is:\nFollowing is an example labeling process based on a real flight:\nimport pandas as pd\nfrom openap.phase import FlightPhase\n\ndf = pd.read_csv(\"assets/data/flight_a319_opensky.csv\", parse_dates=[\"timestamp\"])\n\nts = (df.timestamp - df.timestamp.iloc[0]).dt.total_seconds()  # second\nalt = df.altitude.values  # ft\nspd = df.groundspeed.values  # kts\nroc = df.vertical_rate.values  # ft/min\n\nfp = FlightPhase()\n\nfp.set_trajectory(ts, alt, spd, roc)\n\nlabels = fp.phaselabel()\nprint(labels)\n\n['CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CL', 'CL', 'CR', 'CR', 'CL', 'CR', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'NA']\nWe can visualize the identified flight phases:\nimport matplotlib.pyplot as plt\n\nphasecolors = {\n    \"GND\": \"black\",\n    \"CL\": \"green\",\n    \"DE\": \"blue\",\n    \"LVL\": \"cyan\",\n    \"CR\": \"purple\",\n    \"NA\": \"red\",\n}\n\ncolors = [phasecolors[lbl] for lbl in labels]\n\nplt.subplot(311)\nplt.scatter(ts, alt, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"altitude (ft)\")\n\nplt.subplot(312)\nplt.scatter(ts, spd, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"speed (kt)\")\n\nplt.subplot(313)\nplt.scatter(ts, roc, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"roc (fpm)\")\n\nplt.show()",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>„äôÔ∏è Flight phase identification</span>"
    ]
  },
  {
    "objectID": "flight_phases.html#phase-labeling",
    "href": "flight_phases.html#phase-labeling",
    "title": "4¬† „äôÔ∏è Flight phase identification",
    "section": "",
    "text": "GND: on-ground  \nCL:  climb\nDE:  descend\nLVL: level flight\nCR:  cruise\nNA:  unlabeled\n\nts:  timestamp      second\nalt: altitude       ft\nspd: speed          kts\nroc: vertical rate  ft/min\n\n\n\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction and phase identification for large automatic dependent surveillance‚Äìbroadcast datasets. Journal of Aerospace Information Systems, 14(10), 566‚Äì571. https://doi.org/10.2514/1.I010520",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>„äôÔ∏è Flight phase identification</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html",
    "href": "trajectory_gen.html",
    "title": "5¬† üíÖ Trajectory generation",
    "section": "",
    "text": "5.1 Complete flight\nBased on the kinematic module from the OpenAP package, we can conveniently generate realistic flight trajectories for different flight phases, knowing the distribution of speed, vertical rates, and altitudes.\nThe gen module provides FlightGenerator class to facilitate the generation of flight trajectories.\nTo use the flight generator, we need to instantiate the FlightGenerator object by providing the aircraft typecode, as in the following example:\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom openap.gen import FlightGenerator\n\nfgen = FlightGenerator(ac=\"a320\")\nThe following blocks of code are functions for plotting the trajectories later on.\nShow the plot_traj(flight) code\nimport matplotlib\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef plot_traj(flights: pd.DataFrame | list[pd.DataFrame], lw=2):\n    if isinstance(flights, pd.DataFrame):\n        flights = [flights]\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 4))\n\n    for f in flights:\n        ax1.plot(f.t, f.altitude, lw=lw)\n        ax2.plot(f.t, f.groundspeed, lw=lw)\n        ax3.plot(f.t, f.vertical_rate, lw=lw)\n        ax4.plot(f.t, f.s / 1000, lw=lw)\n\n        ax1.set_ylabel(\"altitude (ft)\")\n        ax2.set_ylabel(\"groundspeed (kt)\")\n        ax3.set_ylabel(\"vertical rate (ft/min)\")\n        ax4.set_ylabel(\"distance flown (km)\")\n\n        ax1.set_ylim(-1000, 40_000)\n        ax2.set_ylim(0, 600)\n        ax3.set_ylim(-3000, 3000)\n\n    for ax in (ax1, ax2, ax3, ax4):\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"top\"].set_visible(False)\n        ax.yaxis.set_label_coords(-0.1, 1.05)\n        ax.yaxis.label.set_rotation(0)\n        ax.yaxis.label.set_ha(\"left\")\n        ax.grid()\n\n        plt.tight_layout()\n        plt.show()\nTo generate a complete trajectory, we can call the FlightGenerator.complete() function by specifying the time step size in seconds. The function outputs a pandas dataframe, containing altitude, flight distance, speed, and vertical_rate.\nSee an example as follows:\nflight = fgen.complete(dt=10)\ndisplay(flight)\n\nplot_traj(flight)\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\naltitude\nvertical_rate\ngroundspeed\n\n\n\n\n0\n0\n0.0\n0.000000e+00\n0.0\n0.0\n0\n0\n0\n\n\n1\n10\n0.0\n0.000000e+00\n19.3\n0.0\n0\n0\n37\n\n\n2\n20\n0.0\n1.930000e+02\n38.6\n0.0\n0\n0\n75\n\n\n3\n30\n0.0\n5.790000e+02\n57.9\n0.0\n0\n0\n112\n\n\n4\n40\n0.0\n1.158000e+03\n77.2\n0.0\n0\n0\n150\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n681\n6790\n0.0\n1.386008e+06\n59.8\n0.0\n0\n0\n116\n\n\n682\n6800\n0.0\n1.386606e+06\n47.6\n0.0\n0\n0\n92\n\n\n683\n6810\n0.0\n1.387082e+06\n35.4\n0.0\n0\n0\n68\n\n\n684\n6820\n0.0\n1.387436e+06\n23.2\n0.0\n0\n0\n45\n\n\n685\n6830\n0.0\n1.387668e+06\n11.0\n0.0\n0\n0\n21\n\n\n\n\n686 rows √ó 8 columns\n\n\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>üíÖ Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#flight-segments-at-different-phases",
    "href": "trajectory_gen.html#flight-segments-at-different-phases",
    "title": "5¬† üíÖ Trajectory generation",
    "section": "5.2 Flight segments at different phases",
    "text": "5.2 Flight segments at different phases\nWe can also generate partial trajectories for only climb, descent, or cruise segments of the flight. The following are three examples.\n\nflight_climb = fgen.climb(dt=10)\nplot_traj(flight_climb)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_descent = fgen.descent(dt=10)\nplot_traj(flight_descent)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_cruise = fgen.cruise(dt=10)\nplot_traj(flight_cruise)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>üíÖ Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "href": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "title": "5¬† üíÖ Trajectory generation",
    "section": "5.3 Generate flight with specific parameters",
    "text": "5.3 Generate flight with specific parameters\nPreviously, we generated the most typical flight profile based on the default values in the WRAP kinematic model. However, we can customize the generation by providing specific parameters.\nFor example, with the following code, we can specify CAS/Mach setting during the climb and the top of the climb altitude for the trajectory.\n\nflight_climb_with_params = fgen.climb(\n    dt=10,\n    cas_const_cl=280,\n    mach_const_cl=0.78,\n    alt_cr=32000,\n)\n\nplot_traj(flight_climb_with_params)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>üíÖ Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "href": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "title": "5¬† üíÖ Trajectory generation",
    "section": "5.4 Generate flights randomly sampled using the kinematic model",
    "text": "5.4 Generate flights randomly sampled using the kinematic model\nIn many use cases, we want to generate a wide range of flight trajectories. The FlightGenerator allows such a possibility. We can generate random and yet realistic trajectories like a breeze.\nYou simply need to provide the radom=True argument when generating trajectories. The generator will randomly sample parameters from the proper distribution of each parameter in the WRAP model.\nThe following example shows several randomly generated flights at different flight phases and randomly sampled complete trajectories.\n\nclimb_flights= [fgen.climb(dt=10, random=True) for i in range(5)]\n\nplot_traj(climb_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ndescent_flights = [fgen.descent(dt=10, random=True) for i in range(5)]\n\nplot_traj(descent_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncruise_flights = [fgen.cruise(dt=10, random=True) for i in range(5)]\n\nplot_traj(cruise_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>üíÖ Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#add-noise-to-the-flight-data",
    "href": "trajectory_gen.html#add-noise-to-the-flight-data",
    "title": "5¬† üíÖ Trajectory generation",
    "section": "5.5 Add noise to the flight data",
    "text": "5.5 Add noise to the flight data\nSometimes, we may also want to add some random noises to the trajectory data. With the FlightGenerator.enable_noise() function, we can make sure Gaussian noises are added to all trajectory points.\nThe noise model is based on ADS-B Version 1 and 2, with a NACv (navigation accuracy category - velocity) value of 3 and a NACp (navigation accuracy category - position) value of 10. More details can be found in Sun (2021, Chapter 9).\n\nfgen.enable_noise()  # enable Gaussian noise in trajectory data\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\n\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode s and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>üíÖ Trajectory generation</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html",
    "href": "fuel_emission.html",
    "title": "6¬† üî• Fuel and Emission",
    "section": "",
    "text": "6.1 Accuracy of the fuel model\nOpenAP provides estimations of fuel consumption and emissions based on actual flight trajectory data. The models are based on the following work:\nThe accuracy of the fuel estimation is greatly improved in the new OpenAP (v2), which is comparable to the BADA 3 fuel model. This is due to the better tuning using data-driven model, acropole, shared by @JarryGabriel.\nThe acropole model only support a few aircraft types, while the OpenAP extends the model to a wide range of aircraft types based on a customized calibration model based on engine parameters.\nThe following figure shows the comparison between the fuel flow estimation from OpenAP and the QAR data. In the end of this page, you can find the code snippet to generate this comparison.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>üî• Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#accuracy-of-the-fuel-model",
    "href": "fuel_emission.html#accuracy-of-the-fuel-model",
    "title": "6¬† üî• Fuel and Emission",
    "section": "",
    "text": "fuel estimation compared to QAR data",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>üî• Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "href": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "title": "6¬† üî• Fuel and Emission",
    "section": "6.2 Basic usage of the fuel and emission modules",
    "text": "6.2 Basic usage of the fuel and emission modules\n\n6.2.1 Compute aircraft fuel flow:\nTo estimate fuel flow, you need to provide the aircraft type (e.g., ‚ÄòA320‚Äô) through the openap.FuelFlow object. The fuel flow model is based on: - aircraft‚Äôs mass (in kg), - true airspeed (TAS, in kts), - altitude (in ft), - and vertical speed (optional, in ft/min).\n\nfrom openap import FuelFlow\n\n# create a fuel flow model for A320\nfuelflow = FuelFlow(ac='A320')\n\n# estimate fuel flow during cruise\nFF = fuelflow.enroute(mass=60000, tas=230, alt=32000)\n\n# estimate fuel flow at climb, with vertical speed (feet/min)\nFF = fuelflow.enroute(mass=60000, tas=200, alt=20000, vs=1000)\n\n# estimate fuel flow at with a given thrust (e.g., derived from drag model)\nFF = fuelflow.at_thrust(acthr=50000, alt=30000)\n\n# estimate fuel flow at takeoff\nFF = fuelflow.takeoff(tas=100, alt=0, throttle=1)\n\n\n\n6.2.2 Compute aircraft emissions:\nThe emission model is based on the fuel flow and aircraft‚Äôs true airspeed (TAS) and altitude. The input fuel flow is in kg/s The emissions include CO2, H2O, NOx, CO, and HC, with units in g/s.\n\nfrom openap import FuelFlow, Emission\n\nfuelflow = FuelFlow(ac=\"A320\")\nemission = Emission(ac=\"A320\")\n\nTAS = 350\nALT = 30000\n\nFF = fuelflow.enroute(mass=60000, tas=TAS, alt=ALT, vs=0)  # kg/s\n\nCO2 = emission.co2(FF)  # g/s\nH2O = emission.h2o(FF)  # g/s\nNOx = emission.nox(FF, tas=TAS, alt=ALT)  # g/s\nCO = emission.co(FF, tas=TAS, alt=ALT)  # g/s\nHC = emission.hc(FF, tas=TAS, alt=ALT)  # g/s",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>üî• Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "href": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "title": "6¬† üî• Fuel and Emission",
    "section": "6.3 Estimate fuel and emission from flight data",
    "text": "6.3 Estimate fuel and emission from flight data\nIn the following example, we estimate the fuel consumption for a given flight trajectory data obtained from the OpenSky Network. The sample data can be downloaded from https://github.com/junzis/openap/tree/master/examples.\nThe following code snippets show how to estimate fuel flow and emissions for this example flight trajectory data.\n\n6.3.1 Data exploration\nFirst, we need to import openap, pandas, and matplotlib libraries.\n\nimport pandas as pd\nimport openap\nimport matplotlib.pyplot as plt\n\nWe also need to define aircraft parameters and import data.\n\nmass_takeoff_assumed = 66300  # kg\n\nfuelflow = openap.FuelFlow(\"A319\")\n\n# Load the data\ndf = pd.read_csv(\n    \"data/flight_a319_opensky.csv\",\n    parse_dates=[\"timestamp\"],\n    dtype={\"icao24\": str},\n)\n\n# Calculate seconds between each timestamp\ndf = df.assign(d_ts=lambda d: d.timestamp.diff().dt.total_seconds().bfill())\n\nLet‚Äôs see what are the features in this flight dataframe:\n\ndf\n\n\n\n\n\n\n\n\ntimestamp\nicao24\ntypecode\ncallsign\norigin\ndestination\nlatitude\nlongitude\naltitude\ngroundspeed\ntrack\nvertical_rate\nd_ts\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.085861\n2.349666\n8200.0\n255.0\n327.804266\n1920.0\n60.0\n\n\n1\n2018-01-02 19:54:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.153427\n2.310861\n9475.0\n290.0\n9.722018\n960.0\n60.0\n\n\n2\n2018-01-02 19:55:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.233367\n2.361121\n9975.0\n332.0\n23.243919\n640.0\n60.0\n\n\n3\n2018-01-02 19:56:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.319916\n2.418471\n11225.0\n353.0\n23.517962\n2752.0\n60.0\n\n\n4\n2018-01-02 19:57:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.411652\n2.478896\n14175.0\n368.0\n23.566915\n3584.0\n60.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n58.978659\n17.706646\n13250.0\n343.0\n24.471621\n-1408.0\n60.0\n\n\n112\n2018-01-02 21:45:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.062826\n17.781088\n11800.0\n326.0\n24.443955\n-1344.0\n60.0\n\n\n113\n2018-01-02 21:46:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.142609\n17.852051\n10400.0\n307.0\n24.397686\n-1216.0\n60.0\n\n\n114\n2018-01-02 21:47:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.217286\n17.918701\n9125.0\n291.0\n24.541618\n-1216.0\n60.0\n\n\n115\n2018-01-02 21:48:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.289505\n17.990112\n8075.0\n291.0\n28.500577\n-960.0\n60.0\n\n\n\n\n116 rows √ó 13 columns\n\n\n\nLet‚Äôs plot the altitude profile of the flight. I will also make the plots more visually appealing.\n\nfrom matplotlib import dates\n\nimport matplotlib\n\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef format_ax(ax):\n    ax.xaxis.set_major_formatter(dates.DateFormatter(\"%H:%M\"))\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.03)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 5), sharex=True)\n\nax1.plot(df.timestamp, df.altitude)\nax2.plot(df.timestamp, df.groundspeed)\nax3.plot(df.timestamp, df.vertical_rate)\n\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"groundspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.3.2 Fuel flow calculation\nNext, we iterate over the timestamp to calculate fuel flow and mass during the flight.\n\nmass_current = mass_takeoff_assumed\n\nfuelflow_every_step = []\nfuel_every_step = []\n\nfor i, row in df.iterrows():\n    ff = fuelflow.enroute(\n        mass=mass_current,\n        tas=row.groundspeed,\n        alt=row.altitude,\n        vs=row.vertical_rate,\n    )\n    fuel = ff * row.d_ts\n    fuelflow_every_step.append(ff)\n    fuel_every_step.append(ff * row.d_ts)\n    mass_current -= fuel\n\ndf = df.assign(fuel_flow=fuelflow_every_step, fuel=fuel_every_step)\n\nThen, we can visualize the fuel flow during the flight.\n\nplt.figure(figsize=(7, 2))\nplt.plot(df.timestamp, df.fuel_flow, color=\"tab:red\")\nplt.ylabel(\"fuel flow (kg/s)\")\nformat_ax(plt.gca())\nplt.show()\n\n\n\n\n\n\n\n\nWith the new dataframe, we can calculate total fuel consumption by summing the fuel consumption at overall time steps:\n\ntotal_fuel = df.fuel.sum().astype(int)\nprint(f\"Total fuel: {total_fuel} kg\")\n\nTotal fuel: 3841 kg\n\n\n\n\n6.3.3 Emission calculation\nThe emission calculations are based on the fuel consumption using the openap.Emission class.\nWe can calculate the emissions for the entire flight and append them as new columns to the dataframe as follows:\n\nemission = openap.Emission(ac=\"A319\")\n\ndf = df.assign(\n    co2_flow=lambda d: emission.co2(d.fuel_flow),\n    h2o_flow=lambda d: emission.h2o(d.fuel_flow),\n    soot_flow=lambda d: emission.soot(d.fuel_flow),\n    sox_flow=lambda d: emission.sox(d.fuel_flow),\n    nox_flow=lambda d: emission.nox(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    co_flow=lambda d: emission.co(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    hc_flow=lambda d: emission.hc(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n)\n\nLet‚Äôs visualize the emission flows:\n\nfig, axes = plt.subplots(7, 1, figsize=(5, 7), sharex=True)\n\naxes = axes.flatten()\n\nlabels = dict(\n    co2_flow=\"CO2 (g/s)\",\n    h2o_flow=\"H2O (g/s)\",\n    soot_flow=\"Soot (g/s)\",\n    sox_flow=\"SOx (g/s)\",\n    nox_flow=\"NOx (g/s)\",\n    co_flow=\"CO (g/s)\",\n    hc_flow=\"HC (g/s)\",\n)\n\nfor i, (k, v) in enumerate(labels.items()):\n    axes[i].plot(df.timestamp, df[k], color=\"tab:brown\")\n    axes[i].set_ylabel(v)\n    format_ax(axes[i])\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNote that CO2, H2O, Soot, and SOx are linear correlated to the fuel flow, following the coefficients from the paper Global Mortality Attributable to Aircraft Cruise Emissions.\n\n\n6.3.4 Final data\nThe emissions at each time step are also calculated as follows. Note that we divide values by 1000 to obtain the emissions in kg.\n\ndf = df.eval(\n    \"\"\"\n    co2 = co2_flow * d_ts / 1000\n    h2o = h2o_flow * d_ts / 1000\n    soot = soot_flow * d_ts / 1000\n    sox = sox_flow * d_ts / 1000\n    nox = nox_flow * d_ts / 1000\n    co = co_flow * d_ts / 1000\n    hc = hc_flow * d_ts / 1000\n    \"\"\"\n)\n\nWe can take a look at the final data with fuel flow and emissions columns.\n\ndf[[\"timestamp\", \"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].round(4)\n\n\n\n\n\n\n\n\ntimestamp\nfuel\nco2\nh2o\nsoot\nsox\nnox\nco\nhc\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n84.5375\n267.1385\n103.9811\n0.0025\n0.1014\n1.3049\n0.0892\n0.0026\n\n\n1\n2018-01-02 19:54:00+00:00\n59.4300\n187.7989\n73.0989\n0.0018\n0.0713\n0.7334\n0.1397\n0.0026\n\n\n2\n2018-01-02 19:55:00+00:00\n54.0898\n170.9238\n66.5305\n0.0016\n0.0649\n0.6335\n0.1421\n0.0026\n\n\n3\n2018-01-02 19:56:00+00:00\n91.0999\n287.8755\n112.0528\n0.0027\n0.1093\n1.5188\n0.0434\n0.0024\n\n\n4\n2018-01-02 19:57:00+00:00\n88.7208\n280.3577\n109.1266\n0.0027\n0.1065\n1.4676\n0.0391\n0.0024\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n6.7503\n21.3311\n8.3029\n0.0002\n0.0081\n0.0284\n0.2678\n0.0160\n\n\n112\n2018-01-02 21:45:00+00:00\n5.5660\n17.5885\n6.8462\n0.0002\n0.0067\n0.0236\n0.2156\n0.0129\n\n\n113\n2018-01-02 21:46:00+00:00\n5.1859\n16.3875\n6.3787\n0.0002\n0.0062\n0.0221\n0.1962\n0.0117\n\n\n114\n2018-01-02 21:47:00+00:00\n3.2038\n10.1240\n3.9407\n0.0001\n0.0038\n0.0137\n0.1187\n0.0071\n\n\n115\n2018-01-02 21:48:00+00:00\n8.4690\n26.7619\n10.4168\n0.0003\n0.0102\n0.0364\n0.3089\n0.0185\n\n\n\n\n116 rows √ó 9 columns\n\n\n\nFinally, we can obtain the total fuel consumption and emissions for the entire flight (unit in kg).\n\ndf[[\"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].sum().round(2)\n\nfuel     3841.92\nco2     12140.48\nh2o      4725.57\nsoot        0.12\nsox         4.61\nnox        39.18\nco         17.28\nhc          0.43\ndtype: float64",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>üî• Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#qar-data-comparison",
    "href": "fuel_emission.html#qar-data-comparison",
    "title": "6¬† üî• Fuel and Emission",
    "section": "6.4 QAR data comparison",
    "text": "6.4 QAR data comparison\nThe following code snippet shows how to compare the fuel flow estimation from OpenAP with the QAR data. This QAR data is an example flight from traffic library.\n\nfuelflow = openap.FuelFlow(ac=\"A320\")\n\n# Load the data\ndf = pd.read_csv(\"data/flight_a320_qar.csv\", parse_dates=[\"timestamp\"])\n\nff_estimate = fuelflow.enroute(\n    mass=df.weight, tas=df.TAS, alt=df.altitude, vs=df.vertical_rate\n)\n\ndiff = abs(ff_estimate.sum() - df.fuelflow.sum()) / df.fuelflow.sum() * 100\n\nplt.figure(figsize=(7, 3))\nplt.plot(df.timestamp, df.fuelflow, lw=1, label=\"QAR\")\nplt.plot(df.timestamp, ff_estimate, lw=1, label=\"OpenAP\")\nplt.ylabel(\"fuel flow (kg/s)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThe difference between the estimated fuel flow and the QAR data is 4.29%.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>üî• Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "contrail.html",
    "href": "contrail.html",
    "title": "7¬† Contrails",
    "section": "",
    "text": "7.1 Overview\nContrails (condensation trails) are line-shaped ice clouds produced by aircraft engine exhaust. The openap.contrail module provides functions to calculate contrail formation conditions and their climate impact through radiative forcing.\nThe module includes functions for:\nfrom openap import contrail",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#overview",
    "href": "contrail.html#overview",
    "title": "7¬† Contrails",
    "section": "",
    "text": "Saturation pressure: Water vapor saturation over liquid water and ice (Murphy & Koop 2005)\nRelative humidity: Conversions between specific humidity and relative humidity\nCritical temperature: Schmidt-Appleman criterion for contrail formation\nRadiative forcing: Shortwave (cooling) and longwave (warming) effects",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#saturation-pressure",
    "href": "contrail.html#saturation-pressure",
    "title": "7¬† Contrails",
    "section": "7.2 Saturation Pressure",
    "text": "7.2 Saturation Pressure\nSaturation vapor pressure is the pressure at which water vapor is in equilibrium with liquid water or ice at a given temperature. These functions use the Murphy & Koop (2005) formulations.\n\n7.2.1 Over liquid water\nValid for temperatures from 123 K to 332 K:\n\nimport numpy as np\n\n# Temperature in Kelvin (typical cruise altitude: ~220 K)\nT = np.array([210, 220, 230, 240])\n\n# Saturation pressure over liquid water (Pa)\np_sat_water = contrail.saturation_pressure_over_water(T)\n\nfor t, p in zip(T, p_sat_water):\n    print(f\"T = {t} K: {p:.2f} Pa\")\n\nT = 210 K: 1.23 Pa\nT = 220 K: 4.36 Pa\nT = 230 K: 13.55 Pa\nT = 240 K: 37.67 Pa\n\n\n\n\n7.2.2 Over ice\nValid for temperatures from 110 K to 273 K:\n\n# Saturation pressure over ice (Pa)\np_sat_ice = contrail.saturation_pressure_over_ice(T)\n\nfor t, p in zip(T, p_sat_ice):\n    print(f\"T = {t} K: {p:.2f} Pa\")\n\nT = 210 K: 0.70 Pa\nT = 220 K: 2.65 Pa\nT = 230 K: 8.95 Pa\nT = 240 K: 27.27 Pa\n\n\nThe ratio of these pressures determines contrail persistence:\n\nratio = p_sat_water / p_sat_ice\nfor t, r in zip(T, ratio):\n    print(f\"T = {t} K: p_water/p_ice = {r:.3f}\")\n\nT = 210 K: p_water/p_ice = 1.757\nT = 220 K: p_water/p_ice = 1.643\nT = 230 K: p_water/p_ice = 1.514\nT = 240 K: p_water/p_ice = 1.381",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#relative-humidity",
    "href": "contrail.html#relative-humidity",
    "title": "7¬† Contrails",
    "section": "7.3 Relative Humidity",
    "text": "7.3 Relative Humidity\nConvert between specific humidity (kg water / kg air) and relative humidity.\n\n# Typical cruise conditions\nspecific_humidity = 0.00005  # kg/kg (very dry at cruise altitude)\npressure = 25000  # Pa (~FL350)\ntemperature = 220  # K\n\n# Relative humidity with respect to ice\nrhi = contrail.relative_humidity(specific_humidity, pressure, temperature, to=\"ice\")\nprint(f\"Relative humidity (ice): {rhi:.1%}\")\n\n# Relative humidity with respect to water\nrhw = contrail.relative_humidity(specific_humidity, pressure, temperature, to=\"water\")\nprint(f\"Relative humidity (water): {rhw:.1%}\")\n\nRelative humidity (ice): 75.7%\nRelative humidity (water): 46.1%\n\n\n\n7.3.1 Converting between water and ice reference\nWhen atmospheric data provides relative humidity with respect to water, you can convert to ice:\n\n# Convert RH w.r.t. water to RH w.r.t. ice\nrhi_converted = contrail.rhw2rhi(rhw, temperature)\nprint(f\"RH (water) = {rhw:.1%} -&gt; RH (ice) = {rhi_converted:.1%}\")\n\nRH (water) = 46.1% -&gt; RH (ice) = 75.7%",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#schmidt-appleman-criterion",
    "href": "contrail.html#schmidt-appleman-criterion",
    "title": "7¬† Contrails",
    "section": "7.4 Schmidt-Appleman Criterion",
    "text": "7.4 Schmidt-Appleman Criterion\nThe Schmidt-Appleman criterion determines when contrails can form. It calculates the critical temperature below which the aircraft exhaust plume becomes saturated with respect to water, allowing ice crystals to form.\n\n7.4.1 Critical temperature for contrail formation\n\n# Pressure at different flight levels\npressures = np.array([20000, 25000, 30000, 35000])  # Pa\n\n# Calculate critical temperature (default propulsion efficiency = 0.4)\nT_crit = contrail.critical_temperature_water(pressures)\n\nfor p, t in zip(pressures, T_crit):\n    fl = round(44330 * (1 - (p/101325)**0.19) / 0.3048 / 100)\n    print(f\"FL{fl:03d} ({p/100:.0f} hPa): T_crit = {t:.1f} K ({t-273.15:.1f} ¬∞C)\")\n\nFL386 (200 hPa): T_crit = 230.5 K (-42.7 ¬∞C)\nFL340 (250 hPa): T_crit = 232.8 K (-40.3 ¬∞C)\nFL300 (300 hPa): T_crit = 234.8 K (-38.4 ¬∞C)\nFL266 (350 hPa): T_crit = 236.5 K (-36.7 ¬∞C)\n\n\n\n\n7.4.2 Effect of propulsion efficiency\nModern engines with higher propulsion efficiency produce contrails more easily (higher critical temperature):\n\npressure = 25000  # Pa\n\n# Different engine efficiencies\nefficiencies = [0.3, 0.35, 0.4, 0.45]\n\nfor eta in efficiencies:\n    T_crit = contrail.critical_temperature_water(pressure, propulsion_efficiency=eta)\n    print(f\"Œ∑ = {eta}: T_crit = {T_crit:.1f} K ({T_crit-273.15:.1f} ¬∞C)\")\n\nŒ∑ = 0.3: T_crit = 231.2 K (-42.0 ¬∞C)\nŒ∑ = 0.35: T_crit = 232.0 K (-41.2 ¬∞C)\nŒ∑ = 0.4: T_crit = 232.8 K (-40.3 ¬∞C)\nŒ∑ = 0.45: T_crit = 233.7 K (-39.4 ¬∞C)\n\n\n\n\n7.4.3 Persistent contrails\nContrails persist when the atmosphere is supersaturated with respect to ice. The critical_temperature_water_and_ice function returns both thresholds:\n\npressure = 25000  # Pa\n\nT_crit_water, T_crit_ice = contrail.critical_temperature_water_and_ice(pressure)\n\nprint(f\"Contrail formation: T &lt; {T_crit_water:.1f} K ({T_crit_water-273.15:.1f} ¬∞C)\")\nprint(f\"Contrail persistence: T &lt; {T_crit_ice:.1f} K ({T_crit_ice-273.15:.1f} ¬∞C)\")\n\nContrail formation: T &lt; 232.8 K (-40.3 ¬∞C)\nContrail persistence: T &lt; 226.3 K (-46.9 ¬∞C)",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#radiative-forcing",
    "href": "contrail.html#radiative-forcing",
    "title": "7¬† Contrails",
    "section": "7.5 Radiative Forcing",
    "text": "7.5 Radiative Forcing\nContrails affect Earth‚Äôs radiative balance through two mechanisms:\n\nShortwave (SW): Reflect incoming solar radiation (cooling effect, negative RF)\nLongwave (LW): Trap outgoing thermal radiation (warming effect, positive RF)\n\n\n7.5.1 Shortwave radiative forcing\nDepends on solar geometry and contrail optical properties:\n\n# Solar zenith angle (0¬∞ = overhead, 90¬∞ = horizon)\nzenith = np.array([0, 30, 60, 80, 100])  # degrees\n\n# Contrail optical depth (typical: 0.1-0.5)\ntau = 0.3\n\n# Background cirrus optical depth\ntau_c = 0.2\n\nrf_sw = contrail.rf_shortwave(zenith, tau, tau_c)\n\nfor z, rf in zip(zenith, rf_sw):\n    status = \"night\" if z &gt; 90 else \"day\"\n    print(f\"Zenith = {z:3d}¬∞ ({status}): RF_SW = {rf:7.2f} W/m¬≤\")\n\nZenith =   0¬∞ (day): RF_SW =   -8.81 W/m¬≤\nZenith =  30¬∞ (day): RF_SW =   -9.70 W/m¬≤\nZenith =  60¬∞ (day): RF_SW =  -16.32 W/m¬≤\nZenith =  80¬∞ (day): RF_SW =  -20.77 W/m¬≤\nZenith = 100¬∞ (night): RF_SW =    0.00 W/m¬≤\n\n\nNote that shortwave forcing is zero at night (zenith &gt; 90¬∞) and negative (cooling) during daytime.\n\n\n7.5.2 Longwave radiative forcing\nDepends on outgoing longwave radiation (OLR) and temperature:\n\n# Outgoing longwave radiation (typical: 200-300 W/m¬≤)\nolr = 250  # W/m¬≤\n\n# Contrail temperature\ntemperatures = np.array([210, 220, 230, 240])  # K\n\nrf_lw = contrail.rf_longwave(olr, temperatures)\n\nfor t, rf in zip(temperatures, rf_lw):\n    print(f\"T = {t} K: RF_LW = {rf:.1f} W/m¬≤\")\n\nT = 210 K: RF_LW = 137.8 W/m¬≤\nT = 220 K: RF_LW = 118.4 W/m¬≤\nT = 230 K: RF_LW = 99.1 W/m¬≤\nT = 240 K: RF_LW = 79.7 W/m¬≤\n\n\nLongwave forcing is always positive (warming) and increases with colder contrails.\n\n\n7.5.3 Net radiative forcing\nThe net effect combines both components:\n\n# Daytime scenario\nzenith_day = 45  # degrees\ntau = 0.3\ntau_c = 0.2\nolr = 250  # W/m¬≤\ntemperature = 220  # K\n\nrf_net_day = contrail.rf_net(zenith_day, tau, tau_c, olr, temperature)\nrf_sw_day = contrail.rf_shortwave(zenith_day, tau, tau_c)\nrf_lw_day = contrail.rf_longwave(olr, temperature)\n\nprint(f\"Daytime (zenith = {zenith_day}¬∞):\")\nprint(f\"  SW: {rf_sw_day:.1f} W/m¬≤ (cooling)\")\nprint(f\"  LW: {rf_lw_day:.1f} W/m¬≤ (warming)\")\nprint(f\"  Net: {rf_net_day:.1f} W/m¬≤\")\n\nDaytime (zenith = 45¬∞):\n  SW: -12.1 W/m¬≤ (cooling)\n  LW: 118.4 W/m¬≤ (warming)\n  Net: 106.4 W/m¬≤\n\n\n\n# Nighttime scenario\nzenith_night = 120  # degrees (sun below horizon)\n\nrf_net_night = contrail.rf_net(zenith_night, tau, tau_c, olr, temperature)\nrf_sw_night = contrail.rf_shortwave(zenith_night, tau, tau_c)\n\nprint(f\"\\nNighttime (zenith = {zenith_night}¬∞):\")\nprint(f\"  SW: {rf_sw_night:.1f} W/m¬≤ (no cooling)\")\nprint(f\"  LW: {rf_lw_day:.1f} W/m¬≤ (warming)\")\nprint(f\"  Net: {rf_net_night:.1f} W/m¬≤\")\n\n\nNighttime (zenith = 120¬∞):\n  SW: 0.0 W/m¬≤ (no cooling)\n  LW: 118.4 W/m¬≤ (warming)\n  Net: 118.4 W/m¬≤\n\n\nThis explains why nighttime contrails have a stronger warming effect‚Äîthere‚Äôs no shortwave cooling to offset the longwave warming.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#contrail-optical-evolution",
    "href": "contrail.html#contrail-optical-evolution",
    "title": "7¬† Contrails",
    "section": "7.6 Contrail Optical Evolution",
    "text": "7.6 Contrail Optical Evolution\nContrails evolve over time, spreading and changing their optical properties:\n\nages = [0.5, 1.5, 3, 5, 8]  # hours\n\nprint(\"Age (h) | tau   | width (m) | tau_c\")\nprint(\"--------|-------|-----------|------\")\n\nfor age in ages:\n    tau, width, tau_c = contrail.contrail_optical_properties(age)\n    print(f\"  {age:4.1f}  | {tau:.2f}  |   {width:5.0f}   | {tau_c:.3f}\")\n\nAge (h) | tau   | width (m) | tau_c\n--------|-------|-----------|------\n   0.5  | 0.40  |     500   | 0.360\n   1.5  | 0.60  |    1500   | 0.540\n   3.0  | 0.68  |    3500   | 0.612\n   5.0  | 0.70  |    6500   | 0.630\n   8.0  | 0.71  |   10500   | 0.639",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#practical-example-contrail-formation-check",
    "href": "contrail.html#practical-example-contrail-formation-check",
    "title": "7¬† Contrails",
    "section": "7.7 Practical Example: Contrail Formation Check",
    "text": "7.7 Practical Example: Contrail Formation Check\nDetermine if contrails will form for a given flight condition:\n\nimport openap\n\n# Flight conditions\naltitude = 35000  # ft\ntemperature_isa_deviation = 0  # K\n\n# Get atmospheric conditions\nh_m = altitude * openap.aero.ft\npressure = openap.aero.pressure(h_m)\ntemperature = openap.aero.temperature(h_m, temperature_isa_deviation)\n\n# Calculate critical temperature\nT_crit = contrail.critical_temperature_water(pressure, propulsion_efficiency=0.4)\n\n# Check formation\nwill_form = temperature &lt; T_crit\n\nprint(f\"Flight level: FL{altitude//100}\")\nprint(f\"Pressure: {pressure:.0f} Pa ({pressure/100:.0f} hPa)\")\nprint(f\"Ambient temperature: {temperature:.1f} K ({temperature-273.15:.1f} ¬∞C)\")\nprint(f\"Critical temperature: {T_crit:.1f} K ({T_crit-273.15:.1f} ¬∞C)\")\nprint(f\"Contrails will form: {will_form}\")\n\nFlight level: FL350\nPressure: 23836 Pa (238 hPa)\nAmbient temperature: 218.8 K (-54.3 ¬∞C)\nCritical temperature: 232.3 K (-40.8 ¬∞C)\nContrails will form: True",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#loading-olr-data",
    "href": "contrail.html#loading-olr-data",
    "title": "7¬† Contrails",
    "section": "7.8 Loading OLR Data",
    "text": "7.8 Loading OLR Data\nFor climate impact calculations with real atmospheric data, use load_olr to interpolate OLR from netCDF files:\n# Load OLR data (requires xarray)\nolr_values = contrail.load_olr(\n    filepath=\"path/to/olr_data.nc\",\n    lat=52.3,    # latitude\n    lon=4.8,     # longitude\n    time=\"2024-01-15T12:00:00\"\n)",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#physical-constants",
    "href": "contrail.html#physical-constants",
    "title": "7¬† Contrails",
    "section": "7.9 Physical Constants",
    "text": "7.9 Physical Constants\nThe module provides several physical constants used in the calculations:\n\n\n\n\n\n\n\n\n\nConstant\nValue\nUnit\nDescription\n\n\n\n\nei_water\n1.2232\nkg/kg\nWater vapor emission index\n\n\nspec_combustion_heat\n43√ó10‚Å∂\nJ/kg\nSpecific combustion heat of jet fuel\n\n\ngas_constant_water_vapor\n461.51\nJ/(kg¬∑K)\nGas constant for water vapor\n\n\ngas_constant_dry_air\n287.05\nJ/(kg¬∑K)\nGas constant for dry air",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "contrail.html#references",
    "href": "contrail.html#references",
    "title": "7¬† Contrails",
    "section": "7.10 References",
    "text": "7.10 References\n\nMurphy, D. M. and Koop, T. (2005). Review of the vapour pressures of ice and supercooled water for atmospheric applications. Q. J. R. Meteorol. Soc., 131, 1539-1565.\nSchumann, U. (1996). On conditions for contrail formation from aircraft exhausts. Meteorol. Z., 5, 4-23.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Contrails</span>"
    ]
  },
  {
    "objectID": "addons.html",
    "href": "addons.html",
    "title": "8¬† Add-ons",
    "section": "",
    "text": "8.1 BADA3\nOpenAP can interface with EUROCONTROL‚Äôs BADA (Base of Aircraft Data) performance models. Both BADA3 and BADA4 are supported, providing alternative drag, thrust, and fuel flow calculations.\nBADA3 uses a coefficient-based model with different parameters for various flight phases. The data is stored in OPF (Operations Performance File) format.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Add-ons</span>"
    ]
  },
  {
    "objectID": "addons.html#bada3",
    "href": "addons.html#bada3",
    "title": "8¬† Add-ons",
    "section": "",
    "text": "8.1.1 Setup\nfrom openap.addon import bada3\n\nbada_path = \"path/to/bada_3.x\"\n\n\n8.1.2 Drag\nCalculate drag force in clean and non-clean configurations:\ndrag = bada3.Drag(\"A320\", bada_path)\n\n# Clean configuration (cruise)\ndrag.clean(mass=60000, tas=300, alt=35_000)  # kg, kts, ft -&gt; N\n\n# Non-clean configuration (approach or landing)\ndrag.nonclean(mass=60000, tas=150, alt=3_000, phase=\"AP\")  # approach\ndrag.nonclean(mass=60000, tas=140, alt=1_000, phase=\"LD\", landing_gear=True)  # landing\nThe phase parameter accepts:\n\n\"AP\" - Approach configuration\n\"LD\" - Landing configuration\n\n\n\n8.1.3 Thrust\nBADA3 provides thrust calculations for different flight phases:\nthrust = bada3.Thrust(\"A320\", bada_path)\n\n# Maximum climb thrust\nthrust.climb(tas=280, alt=20_000)  # kts, ft -&gt; N\n\n# Maximum cruise thrust (95% of climb thrust)\nthrust.cruise(tas=450, alt=35_000)\n\n# Takeoff thrust\nthrust.takeoff(tas=150, alt=0)\n\n# Idle (descent) thrust - requires configuration\nthrust.idle(tas=300, alt=25_000, config=\"CR\")  # cruise descent\nthrust.idle(tas=200, alt=5_000, config=\"AP\")   # approach\nthrust.idle(tas=150, alt=1_000, config=\"LD\")   # landing\nThe config parameter for idle thrust:\n\n\"CR\" - Cruise/clean configuration\n\"AP\" - Approach configuration\n\"LD\" - Landing configuration\n\n\n\n8.1.4 Fuel Flow\nfuel = bada3.FuelFlow(\"A320\", bada_path)\n\n# Enroute fuel flow (cruise, corrected)\nfuel.enroute(mass=60000, tas=450, alt=35_000)  # kg, kts, ft -&gt; kg/s\n\n# Nominal fuel flow (before cruise correction)\nfuel.nominal(mass=60000, tas=450, alt=35_000, vs=0)\n\n# Idle fuel flow\nfuel.idle(mass=60000, tas=300, alt=25_000)\n\n# Approach/landing fuel flow\nfuel.approach(mass=60000, tas=150, alt=3_000)\n\n\n8.1.5 ISA Temperature Deviation\nAll thrust and fuel calculations support ISA temperature deviation using the dT parameter:\n# Hot day scenario (+15K above ISA)\nthrust.climb(tas=280, alt=20_000, dT=15)\nfuel.enroute(mass=60000, tas=450, alt=35_000, vs=500, dT=15)",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Add-ons</span>"
    ]
  },
  {
    "objectID": "addons.html#bada4",
    "href": "addons.html#bada4",
    "title": "8¬† Add-ons",
    "section": "8.2 BADA4",
    "text": "8.2 BADA4\nBADA4 uses a more sophisticated polynomial model with higher fidelity, especially for modern aircraft. The data is stored in XML format.\n\n8.2.1 Setup\nfrom openap.addon import bada4\n\nbada_path = \"path/to/bada_4.x/tables\"\n\n\n8.2.2 Drag\ndrag = bada4.Drag(\"A320\", bada_path)\n\ndrag.clean(mass=60000, tas=300, alt=35_000)  # kg, kts, ft -&gt; N\nThe aircraft type can be ICAO typecode like A320 or with subtypes like A320-231.\n\n\n8.2.3 Thrust\nthrust = bada4.Thrust(\"A320\", bada_path)\n\n# Maximum climb thrust (MCMB rating)\nthrust.climb(tas=280, alt=20_000)\n\n# Maximum cruise thrust (MCRZ rating)\nthrust.cruise(tas=450, alt=35_000)\n\n# Takeoff thrust\nthrust.takeoff(tas=150, alt=0)\n\n# Idle thrust (LIDL rating)\nthrust.idle(tas=300, alt=25_000)\n\n\n8.2.4 Fuel Flow\nfuel = bada4.FuelFlow(\"A320\", bada_path)\n\n# Enroute fuel flow\nfuel.enroute(mass=60000, tas=450, alt=35_000)  # kg, kts, ft -&gt; kg/s\n\n# Idle fuel flow\nfuel.idle(mass=60000, tas=300, alt=25_000)\nThe enroute method automatically switches to idle fuel flow when vertical speed is below -250 ft/min.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Add-ons</span>"
    ]
  },
  {
    "objectID": "addons.html#vectorized-calculations",
    "href": "addons.html#vectorized-calculations",
    "title": "8¬† Add-ons",
    "section": "8.3 Vectorized Calculations",
    "text": "8.3 Vectorized Calculations\n\n\n\n\n\n\nTip\n\n\n\nAll BADA models support vectorized calculations. Input parameters can be provided as lists or numpy arrays for fast batch processing.\n\n\nIn the following example, we show how to calculate the fuel flow from a flight data file obtained from opensky state vectors. First, we read the data file and calculate the time step between each row.\nimport pandas as pd\nimport openap\nfrom openap.addon import bada4\n\ntypecode = \"A319\"\nfuel_bada = bada4.FuelFlow(typecode, bada_path)\n\ndf = pd.read_csv(\"path/to/your/fightdata.csv\")\ndt = df.timestamp.diff().bfill().dt.total_seconds()  # time step in seconds\n\n# assume 85% of MTOW as initial mass\nmass0 = openap.prop.aircraft(typecode)[\"mtow\"] * 0.85\nThen we calculate the fuel flow at each time step and sum the total fuel consumed.\n# first pass to get an initial guess with reference mass\nfuel_flow_initial_guess = fuel_bada.enroute(\n    mass=mass0,\n    tas=df.groundspeed,\n    alt=df.altitude,\n    vs=df.vertical_rate,\n).flatten()\n\n# correct the mass at each time step\nmass = mass0 - (fuel_flow_initial_guess * dt).cumsum()\n\n# second pass with corrected mass\nfuel_flow = fuel_bada.enroute(\n    mass=mass, tas=df.groundspeed, alt=df.altitude, vs=df.vertical_rate\n).flatten()\n\ntotal_fuel = sum(fuel_flow * dt)\nThe cacluation takes approximately 4.6 ms ¬± 33.7 Œºs for a flight dataframe with ~ 7,000 rows on aRyzen 7 7840HS CPU.",
    "crumbs": [
      "üöÄ OpenAP",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Add-ons</span>"
    ]
  },
  {
    "objectID": "optimize/index.html",
    "href": "optimize/index.html",
    "title": "ü¶∏ Trajectory Optimizer",
    "section": "",
    "text": "Supported aircraft types\nPreviously, the majority of flight optimizers mentioned in the literature remained closed-source, which posed a significant drawback in terms of reproducible research.\nThe trajectory optimizer (TOP) addresses this lack of open-source flight trajectory optimizer by providing everyone with open access to trajectory optimization based on a non-linear optimal control direct collocation approach.\nThe TOP library can consider 3D or 4D wind fields. It can be utilized in various flight phases, either individually or in combination. It provides traditional fuel and cost index objectives alongside climate metrics-based objectives that incorporate global warming or temperature potential.\nFurthermore, There is a mechanism to include a 3D or 4D cost grid in trajectory optimization. This implementation allows easy generation of, for example, contrail-optimal trajectories, or generate trajectories that avoid areas with convective weathers.\nThe TOP library supports a wide range of aircraft types, however, the most accurate performance models are available for the following aircraft:\nNarrow-body aircraft:\nWide-body aircraft:",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#supported-aircraft-types",
    "href": "optimize/index.html#supported-aircraft-types",
    "title": "ü¶∏ Trajectory Optimizer",
    "section": "",
    "text": "A20N, A21N, A319, A320, A321\nB38M, B39M, B737, B738, B739\nE190, E195\n\n\n\nA332, A333\n\n\n\n\n\n\n\nCaution\n\n\n\nThe optimizer also supports other aircraft types in the OpenAP library, but the performance models for these aircraft may not be as accurate.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#use-cases",
    "href": "optimize/index.html#use-cases",
    "title": "ü¶∏ Trajectory Optimizer",
    "section": "Use cases",
    "text": "Use cases\nThe following chapters demonstrate various optimization scenarios and practical applications:\n\nChapter 7: explains how you can easily generate fuel and other simple cost-optimal trajectories.\nChapter 8: provides two approaches to obtaining wind fields and using them in your optimization.\nChapter 9: dives deeper into optimization with more complex 3D or 4D grids.\nChapter 10: provides a concrete example of flight optimization considering contrails.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#install",
    "href": "optimize/index.html#install",
    "title": "ü¶∏ Trajectory Optimizer",
    "section": "Install",
    "text": "Install\nThe opeanp.top library is designed to be a module inside the openap scope. You can install the most recent release thorugh pip:\npip install --upgrade openap-top\nThis will install openap.top and related dependencies.\nAlternatively, if you want to install the most recent development version (usually it is also recommended to update openap to the latest dev version):\npip install --upgrade git+https://github.com/junzis/openap\npip install --upgrade git+https://github.com/junzis/openap-top",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#paper",
    "href": "optimize/index.html#paper",
    "title": "ü¶∏ Trajectory Optimizer",
    "section": "Paper",
    "text": "Paper\nThe optimization framework was first published in the following paper: Sun (2022)\nTo cite the paper:\n@article{sun2022top,\n  title = {OpenAP.top: Open Flight Trajectory Optimization for Air Transport and Sustainability Research},\n  author = {Sun, Junzi},\n  journal = {Aerospace},\n  volume = {9},\n  number = {7},\n  pages = {383},\n  year = {2022},\n  month = jul,\n  publisher = {Multidisciplinary Digital Publishing Institute},\n  link = {https://doi.org/10.3390/aerospace9070383},\n  doi = {10.3390/aerospace9070383},\n}\n\n\n\n\n\n\nCaution\n\n\n\nWhile the fundamental principle of trajectory optimization (based on non-linear optimal control) remains unchanged, the software has evolved significantly since the paper‚Äôs publication.\nKey improvements include:\n\nEnhanced performance models\nMore robust trajectory generation logic, and better convergence\nOptimized computational performance, much faster üöÄ\n\n\n\n\n\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air transport and sustainability research. Aerospace, 9(7), 383. https://doi.org/10.3390/aerospace9070383",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/basic.html",
    "href": "optimize/basic.html",
    "title": "9¬† üç≥ Simple optimal flights",
    "section": "",
    "text": "9.1 Quick start\nExample code to generate a fuel-optimal flight between two airports. First, we need to set up a few parameters, including origin, destination, actype, and m0 (initial mass).\nThe initial mass m0 can be the fraction of the maximum take-off mass (between 0 and 1), or it can be the mass in kg (for example, 65000 kg).\nfrom openap import top\n\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\nIn this simple example, we will generate a complete flight using top.CompleteFlight(). We will generate a fuel-optimal flight by setting objective to \"fuel\" in the trajectory generation function.\noptimizer = top.CompleteFlight(actype, origin, destination, m0=m0)\n\nflight = optimizer.trajectory(objective=\"fuel\")\nflight.head()\n\n\n\n\n\n\n\n\nts\nx\ny\nh\nlatitude\nlongitude\naltitude\nmach\ntas\nvertical_rate\nheading\nmass\nfuel\n\n\n\n\n0\n0.0\n-652425.011696\n840651.921623\n30.480000\n52.316584\n4.746242\n100.0\n0.3000\n198.38\n1155.0\n129.51\n66300.000000\n323.467557\n\n\n1\n240.0\n-633557.291544\n825095.442439\n1436.228097\n52.198625\n5.049372\n4712.0\n0.5000\n325.34\n1655.0\n137.01\n65976.532443\n331.368938\n\n\n2\n479.0\n-606696.232046\n796275.571353\n3450.725380\n51.969890\n5.489660\n11321.0\n0.6869\n436.31\n2155.0\n137.02\n65645.163505\n336.864499\n\n\n3\n719.0\n-571079.731509\n758059.040224\n6073.971848\n51.664098\n6.066591\n19928.0\n0.7589\n466.37\n1655.0\n137.02\n65308.299006\n310.576620\n\n\n4\n959.0\n-532698.817232\n716876.379079\n8088.469130\n51.331487\n6.679653\n26537.0\n0.7970\n476.69\n1155.0\n137.03\n64997.722386\n270.762600\nIn the previous table, we have the final fuel-optimal trajectory. Next, we can visualize the altitude, speed, and vertical rate.\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\n# function to make plot nicer\ndef format_ax(ax):\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.05)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 4), sharex=True)\nax1.plot(flight.ts, flight.altitude)\nax2.plot(flight.ts, flight.tas)\nax3.plot(flight.ts, flight.vertical_rate)\nax1.set_ylim(0, 40000)\nax2.set_ylim(0, 600)\nax3.set_ylim(-3000, 3000)\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"true airspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\nax3.set_xlabel(\"time(s)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>üç≥ Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/basic.html#other-objective-functions",
    "href": "optimize/basic.html#other-objective-functions",
    "title": "9¬† üç≥ Simple optimal flights",
    "section": "9.2 Other objective functions",
    "text": "9.2 Other objective functions\nInstead of the default objective functions, you can also specify different objective functions as follows:\n# cost index, between 0 - 100\nflight = optimizer.trajectory(objective=\"ci:30\")\n\n# global warming potential\nflight = optimizer.trajectory(objective=\"gwp100\")\n\n# global temperature potential\nflight = optimizer.trajectory(objective=\"gtp100\")\nThe final flight object is a pandas DataFrame.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>üç≥ Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/basic.html#different-flight-phases",
    "href": "optimize/basic.html#different-flight-phases",
    "title": "9¬† üç≥ Simple optimal flights",
    "section": "9.3 Different flight phases",
    "text": "9.3 Different flight phases\nInstead of generating a complete flight, we can also generate cruise, climb, and descent flights using top.Crusie, top.Climb, and top.Descent classes.\n\ncruise_flight = top.Cruise(actype, origin, destination, m0=m0).trajectory()\n\nclimb_flight = top.Climb(actype, origin, destination, m0=m0).trajectory()\n\ndescent_flight = top.Descent(actype, origin, destination, m0=m0).trajectory()\n\nLet‚Äôs visulize these trajectories:\n\nlabels = (\"cruise flight\", \"climb flight\", \"descent flight\")\n\nfig, axes = plt.subplots(3, 3, figsize=(10, 4))\n\nfor i, flight in enumerate([cruise_flight, climb_flight, descent_flight]):\n    ax1, ax2, ax3 = axes[:, i]\n    ax1.plot(flight.ts, flight.altitude)\n    ax2.plot(flight.ts, flight.tas)\n    ax3.plot(flight.ts, flight.vertical_rate)\n    ax1.set_ylabel(\"altitude (ft)\")\n    ax2.set_ylabel(\"true airspeed (kts)\")\n    ax3.set_ylabel(\"vertical rate (ft/min)\")\n    ax1.set_ylim(0, 40000)\n    ax2.set_ylim(0, 600)\n    ax3.set_ylim(-3000, 3000)\n    ax1.set_title(labels[i], pad=20)\n    ax3.set_xlabel(\"time(s)\")\n\nfor ax in axes.flatten():\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>üç≥ Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/wind.html",
    "href": "optimize/wind.html",
    "title": "10¬† üå™Ô∏è Wind optimal flights",
    "section": "",
    "text": "10.1 Obtaining wind with fastmeteo\nFlight trajectory optimization considering wind conditions is crucial for efficient flight planning. Wind can significantly impact flight time, fuel consumption, and overall flight efficiency. For example, a favorable tailwind can help reduce flight time and fuel burn, while headwinds can have the opposite effect.\nThere are two main approaches to incorporate wind data when using ‚Äòopenap.top‚Äô trajectory optimization:\nIt is also possible to include 3D or 4D wind data in the optimization. The following code provides an example of such a use case. Note that the wind data is obtained using fastmeteo library in this example.\nimport fastmeteo\nimport numpy as np\nimport pandas as pd\nimport openap\n\nfrom openap import top\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\nm0 = 0.85\nNext, we need to get an example wind field data using the fastmeteo library. Note the selected ERA5 data will be cached temporarily at /tmp/era5-zarr.\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\n\n# get the boundary of the wind field\no = openap.nav.airport(origin)\nd = openap.nav.airport(destination)\n\nlatmin = round(min(o[\"lat\"], d[\"lat\"])) - 2\nlatmax = round(max(o[\"lat\"], d[\"lat\"])) + 2\nlonmin = round(min(o[\"lon\"], d[\"lon\"])) - 4\nlonmax = round(max(o[\"lon\"], d[\"lon\"])) + 4\n\n# create the and flatten the wind grid\nlatitudes = np.arange(latmin, latmax, 0.5)\nlongitudes = np.arange(lonmin, lonmax, 1)\naltitudes = np.arange(1000, 46000, 2000)\ntimestamps = pd.date_range(\"2021-05-01 08:00:00\", \"2021-05-01 11:00:00\", freq=\"1H\")\n\nlatitudes, longitudes, altitudes, times = np.meshgrid(\n    latitudes, longitudes, altitudes, timestamps\n)\n\ngrid = pd.DataFrame().assign(\n    latitude=latitudes.flatten(),\n    longitude=longitudes.flatten(),\n    altitude=altitudes.flatten(),\n    timestamp=times.flatten(),\n)\n\n# obtain the wind based on the grid\nfmg = fastmeteo.Grid(local_store=\"/tmp/era5-zarr\")\n\nmeteo_data = fmg.interpolate(grid)\n\ninit local zarr from google arco era5, hour: 2021-05-01 08:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 09:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 10:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 11:00:00\nLet‚Äôs take a look at the meteorological data we got:\nmeteo_data.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\naltitude\ntimestamp\nu_component_of_wind\nv_component_of_wind\ntemperature\nspecific_humidity\n\n\n\n\n0\n36.0\n1\n1000\n2021-05-01 08:00:00\n4.133623\n3.570823\n287.546767\n0.006717\n\n\n1\n36.0\n1\n1000\n2021-05-01 09:00:00\n5.019323\n2.913781\n288.905607\n0.006309\n\n\n2\n36.0\n1\n1000\n2021-05-01 10:00:00\n6.375478\n1.566804\n289.427981\n0.005825\n\n\n3\n36.0\n1\n1000\n2021-05-01 11:00:00\n6.242283\n0.733652\n290.577190\n0.005545\n\n\n4\n36.0\n1\n3000\n2021-05-01 08:00:00\n8.573422\n4.150122\n282.324727\n0.006347\nBefore passing this wind field to the optimizer, we need to format it correctly. The wind data needs to be in pandas.DataFrame with the following columns: - ts: timestamp in seconds, with 0 representing the time of departure of the flight - latitude: latitude of all the grid points - longitude: longitude of all the grid points - h: height of the grid points, in meters - u: u component of the wind for each grid point, in m/s - v: v component of the wind for each grid point, in m/s\nwind = (\n    meteo_data.rename(\n        columns={\n            \"u_component_of_wind\": \"u\",\n            \"v_component_of_wind\": \"v\",\n        }\n    )\n    .assign(ts=lambda x: (x.timestamp - x.timestamp.iloc[0]).dt.total_seconds())\n    .eval(\"h=altitude * 0.3048\")\n)[[\"ts\", \"latitude\", \"longitude\", \"h\", \"u\", \"v\"]]\n\nwind.head()\n\n\n\n\n\n\n\n\nts\nlatitude\nlongitude\nh\nu\nv\n\n\n\n\n0\n0.0\n36.0\n1\n304.8\n4.133623\n3.570823\n\n\n1\n3600.0\n36.0\n1\n304.8\n5.019323\n2.913781\n\n\n2\n7200.0\n36.0\n1\n304.8\n6.375478\n1.566804\n\n\n3\n10800.0\n36.0\n1\n304.8\n6.242283\n0.733652\n\n\n4\n0.0\n36.0\n1\n914.4\n8.573422\n4.150122\nLast, we can run the optimization with the wind field and visulize the result:\nimport matplotlib.pyplot as plt\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, barb_steps=15)\nplt.show()\nIf you only want to visualize the map:\ntop.vis.map(flight, windfield=wind, barb_steps=15)\nplt.show()",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>üå™Ô∏è Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/wind.html#using-grid-wind-files",
    "href": "optimize/wind.html#using-grid-wind-files",
    "title": "10¬† üå™Ô∏è Wind optimal flights",
    "section": "10.2 Using grid wind files",
    "text": "10.2 Using grid wind files\nYou can also optimize the trajectory with grid atmospheric data, for example, grib or nc files downloaded from the ECMWF or GFS. In TOP, there is a built-in function top.tools.read_grids() that can be used to process grid data files into a DataFrame for the optimizer.\n\n# read the downloaded ERA5 grib data, the arguments can be a list of files.\nwind = top.tools.read_grids(\"tmp/era5_2021-05-01_0800.grib\")\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, barb_steps=25)\nplt.show()\n\nIgnoring index file '/home/junzi/arc/workspace/website/openap.dev/optimize/tmp/era5_2021-05-01_0800.grib.5b7b6.idx' incompatible with GRIB file\n\n\n\n\n\n\n\n\n\nSince the grib data from a similar time frame was downloaded, we can observe that the result is similar to the one from the previous section. The advantage is that the code is relatively simple compared to the previous example, which used fastmeteo to download data that covers the region of the flights.\nHowever, this approach requires a large quantity of grid data to be downloaded first. The read_grids() function also loads the entire grid files into RAM, which can be memory intensive if many grid files are loaded.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>üå™Ô∏è Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html",
    "href": "optimize/costgrid.html",
    "title": "11¬† üôÄ Using cost grids",
    "section": "",
    "text": "11.1 Cost grid in 3D\nIn many trajectory optimization scenarios, the cost function is area-dependent. For example, we may need to avoid areas of convective weather or regions with sensitive climate conditions. In these cases, the TOP optimizer considers a 3D or 4D cost grid as part of the objective function.\nTo find the optimal set of control variables (i.e., speed, heading, and vertical rate), the cost grid is converted into an interpolant. This allows the non-linear optimal control process to evaluate the combined cost based on flight states (time, positions, and altitudes) throughout the entire trajectory. Subject to the constraints defined in the flight dynamics, the optimizer computes a trajectory that minimizes the total cost across the airspace.\nPractically, in order to prevent the trajectory from completely deviating from the fuel-optimal route, the cost is combined with the fuel cost to provide a more realistic trajectory. In this chapter, I will explain how one can use a predefined cost grid (in both 3D and 4D) to perform the optimization of trajectories.\nTo demonstrate the use of 3D cost in flight optimization, we will first set up an example cost grid. The example flight we want to optimize is still based on the one from previous chapters, flight with the origin of EHAM and the destination of LGAV.\nWe first generate an artificial 2D cost grid using a Gaussian function, with the x range of (-10, 10) and y range of (-5, 5). Then the range is transformed to the longitude and latitude bounds for our flight. The 2D cost grids at different levels are dependent on the altitude, where the higher the altitude, the higher the cost.\nimport numpy as np\nimport pandas as pd\n\n\ndef gaussian(x, y, z):\n    return (\n        np.exp(-((x + 3) ** 2 + (y - 1) ** 2)) + np.exp(-((x - 3) ** 2 + (y + 2) ** 2))\n    ) * z**2\n\n\nx = np.linspace(-10, 10, 40)\ny = np.linspace(-5, 5, 40)\nz = np.linspace(1, 2, 32)\n\nX, Y, Z = np.meshgrid(x, y, z)\ncosts3d = gaussian(X, Y, Z)\ncosts3d = (costs3d - costs3d.min()) / (costs3d.max() - costs3d.min())\n\nlon = np.interp(x, (min(x), max(x)), (-10, 40))\nlat = np.interp(y, (min(y), max(y)), (35, 60))\nalt = np.interp(z, (min(z), max(z)), (0, 40_000))\n\nlons, lats, alts = np.meshgrid(lon, lat, alt)\nWe can visualize the cost grid at different altitude as follows:\nShow the code used for visulization\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 3, figsize=(12, 8), subplot_kw={\"projection\": \"3d\"})\nfor i, ax in enumerate(axes.flatten()):\n    ax.plot_surface(\n        lons[:, :, i * 6],\n        lats[:, :, i * 6],\n        costs3d[:, :, i * 6],\n        edgecolor=\"tab:blue\",\n        lw=0.5,\n        alpha=0.3,\n    )\n    ax.set_zlim(0, 1)\n    flight_level = int(alt[i * 6] // 1000 * 10)\n    ax.set_title(f\"FL{flight_level}\")\n    ax.set_xlabel(\"longitude\")\n    ax.set_ylabel(\"latitude\")\n    ax.set_zlabel(\"cost\", rotation=90)\n\nplt.show()\nWe can construct the cost as a flattened 2D DataFrame. It is important that the DataFrame has the columns height, latitude, longitude. The height unit must be in meters.\nExample of the cost grid as apd.DataFrame:\ndf_cost_3d = pd.DataFrame(\n    np.array([lons, lats, alts, costs3d]).reshape(4, -1).T,\n    columns=[\"longitude\", \"latitude\", \"altitude\", \"cost\"],\n).assign(height=lambda x: x.altitude * 0.3048)\n\ndf_cost_3d\n\n\n\n\n\n\n\n\nlongitude\nlatitude\naltitude\ncost\nheight\n\n\n\n\n0\n-10.0\n35.0\n0.000000\n3.158413e-38\n0.000000\n\n\n1\n-10.0\n35.0\n1290.322581\n3.365469e-38\n393.290323\n\n\n2\n-10.0\n35.0\n2580.645161\n3.579098e-38\n786.580645\n\n\n3\n-10.0\n35.0\n3870.967742\n3.799300e-38\n1179.870968\n\n\n4\n-10.0\n35.0\n5161.290323\n4.026075e-38\n1573.161290\n\n\n...\n...\n...\n...\n...\n...\n\n\n51195\n40.0\n60.0\n34838.709677\n1.785139e-43\n10618.838710\n\n\n51196\n40.0\n60.0\n36129.032258\n1.872056e-43\n11012.129032\n\n\n51197\n40.0\n60.0\n37419.354839\n1.960458e-43\n11405.419355\n\n\n51198\n40.0\n60.0\n38709.677419\n2.050347e-43\n11798.709677\n\n\n51199\n40.0\n60.0\n40000.000000\n2.141721e-43\n12192.000000\n\n\n\n\n51200 rows √ó 5 columns\nWith this grid cost, we need to define an interpolant based on this grid and an objective function which is a combination of the grid cost and fuel cost.\nfrom openap import top, aero\n\noptimizer = top.CompleteFlight(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\n# optimizer.setup(debug=True)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost_3d)\n\n\ndef objective(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(x, u, dt, time_dependent=True, **kwargs)\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost + fuel_cost * 2\n\n\n# generate optimal flight trajectory\n# interpolant is passed to trajectory(), and internally used by obj_grid()\nflight = optimizer.trajectory(objective=objective, interpolant=interpolant)\nOnce the optimization is complete, we can visualize the trajetory with the builtin vis.trajectory() function:\ntop.vis.trajectory(flight)\nplt.show()\nWe can create visualization code so that the trajectory is plotted along the cost grid at different altitudes. In the following figure, you can see the flight avoided the regions with highest cost, while maintaining a small detour to avoid excess fuel consumption.\nShow the function flight_level_cost_3d() used for visulization\ndef flight_level_cost_3d(flight, df_cost):\n    from cartopy import crs as ccrs\n    from cartopy.feature import BORDERS\n\n    proj = ccrs.PlateCarree()\n\n    fig, axes = plt.subplots(\n        3,\n        2,\n        figsize=(9, 9),\n        subplot_kw=dict(\n            projection=ccrs.TransverseMercator(\n                central_longitude=15, central_latitude=45\n            )\n        ),\n    )\n\n    for i, ax in enumerate(axes.flatten()):\n        ax.set_extent([-10, 40, 32, 60])\n        ax.add_feature(BORDERS, lw=0.5, color=\"gray\")\n        ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n\n        h = df_cost.height.unique()[i * 6]\n        fl = int(h / 0.3048 // 1000 * 10)\n\n        df_cost_pivot = df_cost.query(f\"height=={h}\").pivot(\n            index=\"latitude\", columns=\"longitude\", values=\"cost\"\n        )\n\n        lat, lon, val = (\n            df_cost_pivot.index.values,\n            df_cost_pivot.columns.values,\n            df_cost_pivot.values,\n        )\n\n        ax.contourf(\n            lon, lat, val, transform=proj, alpha=0.8, cmap=\"Reds\", vmin=0, vmax=1\n        )\n\n        ax.text(0.03, 0.9, f\"FL{fl}\", transform=ax.transAxes, fontsize=14)\n\n        ax.plot(flight.longitude, flight.latitude, color=\"k\", lw=1, transform=proj)\n\n        for r, p in (flight.iloc[[0, -1]]).iterrows():\n            ax.scatter(p.longitude, p.latitude, c=\"k\", transform=proj)\n\n    plt.tight_layout()\n    plt.show()\nflight_level_cost_3d(flight, df_cost_3d)\nNext, we modify the combined objective (grid and fuel) so that the weight of the grid cost is higher. And we can see that the optimized trajectory takes a longer detour to avoid regions with high grid cost with more fuel burnt.\ndef objective_2(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(x, u, dt, time_dependent=True, **kwargs)\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost * 2 + fuel_cost\n\n\nflight_2 = optimizer.trajectory(objective=objective_2, interpolant=interpolant)\n\nflight_level_cost_3d(flight_2, df_cost_3d)",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üôÄ Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html#cost-grid-in-3d",
    "href": "optimize/costgrid.html#cost-grid-in-3d",
    "title": "11¬† üôÄ Using cost grids",
    "section": "",
    "text": "Note\n\n\n\nThere is also a built-in logic that raises a warning if the maximum height is higher than 20,000, which can be a common mistake between ft and meters when referring to the altitude.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üôÄ Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html#cost-grid-in-4d",
    "href": "optimize/costgrid.html#cost-grid-in-4d",
    "title": "11¬† üôÄ Using cost grids",
    "section": "11.2 Cost grid in 4D",
    "text": "11.2 Cost grid in 4D\nThe usage of 4D cost grid is similar to 3D cost grid. The only difference is that the 4D cost grid includes a time dimension.\nIn the following example, we extend the 3D cost grid by adding a time dimension. The time dimension can be represented as a sequence of 3D cost grids at different time steps.\n\nimport numpy as np\nimport pandas as pd\n\n\ndef gaussian(x, y, z, t):\n    return (\n        np.exp(-((x + 3 - i) ** 2 + (y - 1) ** 2))\n        + np.exp(-((x - 3 + i / 2) ** 2 + (y + 2) ** 2))\n    ) * z**2\n\n\nx = np.linspace(-8, 8, 40)\ny = np.linspace(-4, 4, 40)\nz = np.linspace(1, 2, 32)\nX, Y, Z = np.meshgrid(x, y, z)\n\n# add the time dimension\nts = np.arange(0, 8 * 1800, 1800)  # every 30 minutes\ncosts4d = np.zeros((len(x), len(y), len(z), len(ts)))\n\nfor i, ts_ in enumerate(ts):\n    costs3d = gaussian(X, Y, Z, ts)\n    costs4d[:, :, :, i] = costs3d\n\ncosts4d = (costs4d - costs4d.min()) / (costs4d.max() - costs4d.min())\n\n# scale the x,y to lon,lat bound\nlon = np.interp(x, (min(x), max(x)), (-10, 40))\nlat = np.interp(y, (min(y), max(y)), (35, 60))\nalt = np.interp(z, (min(z), max(z)), (0, 40_000))\n\nlons, lats, alts, tss = np.meshgrid(lon, lat, alt, ts)\n\nThe 4D cost grid can be visualized at different time steps and altitudes as follows. Each rows represent the cost grid at different flight levels, and each column represents the cost grid at different time steps.\n\n\nShow the code used for visulization\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(4, 4, figsize=(16, 18), subplot_kw={\"projection\": \"3d\"})\nfor i, ax in enumerate(axes.flatten()):\n    ax.plot_surface(\n        lons[:, :, i // 4 * 6, i % 4 * 2],\n        lats[:, :, i // 4 * 6, i % 4 * 2],\n        costs4d[:, :, i // 4 * 6, i % 4 * 2],\n        edgecolor=\"tab:blue\",\n        lw=0.5,\n        alpha=0.3,\n    )\n    ax.set_zlim(0, 1)\n    flight_level = int(alt[i // 4 * 6] // 1000 * 10)\n    time = ts[i % 4 * 2] / 1800 / 2\n    ax.set_title(f\"FL{flight_level} | {int(time)}h\")\n    ax.set_xlabel(\"longitude\")\n    ax.set_ylabel(\"latitude\")\n    ax.set_zlabel(\"cost\", rotation=90)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nSimilar to the 3D cost grid, we can construct the 4D cost grid as a pd.DataFrame. The DataFrame has the columns height, latitude, longitude, and ts. The height unit must be in meters.\n\ndf_cost_4d = pd.DataFrame(\n    np.array([lons, lats, alts, tss, costs4d]).reshape(5, -1).T,\n    columns=[\"longitude\", \"latitude\", \"altitude\", \"ts\", \"cost\"],\n).assign(height=lambda x: x.altitude * 0.3048)\n\ndf_cost_4d\n\n\n\n\n\n\n\n\nlongitude\nlatitude\naltitude\nts\ncost\nheight\n\n\n\n\n0\n-10.0\n35.0\n0.0\n0.0\n4.836940e-23\n0.0\n\n\n1\n-10.0\n35.0\n0.0\n1800.0\n8.078512e-28\n0.0\n\n\n2\n-10.0\n35.0\n0.0\n3600.0\n1.826010e-33\n0.0\n\n\n3\n-10.0\n35.0\n0.0\n5400.0\n5.615118e-40\n0.0\n\n\n4\n-10.0\n35.0\n0.0\n7200.0\n3.049747e-38\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n409595\n40.0\n60.0\n40000.0\n5400.0\n1.995862e-32\n12192.0\n\n\n409596\n40.0\n60.0\n40000.0\n7200.0\n6.490450e-26\n12192.0\n\n\n409597\n40.0\n60.0\n40000.0\n9000.0\n2.871462e-20\n12192.0\n\n\n409598\n40.0\n60.0\n40000.0\n10800.0\n1.719263e-15\n12192.0\n\n\n409599\n40.0\n60.0\n40000.0\n12600.0\n1.393133e-11\n12192.0\n\n\n\n\n409600 rows √ó 6 columns\n\n\n\nWith the 4D cost grid, we can again define an interpolant based on this grid and an objective function which is a combination of the grid cost and fuel cost.\n\nfrom openap import top, aero\n\noptimizer = top.CompleteFlight(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\n# optimizer.setup(debug=True)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost_4d)\n\n\ndef objective(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(\n        x, u, dt, n_dim=4, time_dependent=True, **kwargs\n    )\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost + fuel_cost * 2\n\n\n# generate the flight trajectory\n# interpolant is passed to trajectory(), and internally used by obj_grid()\nflight = optimizer.trajectory(objective=objective, interpolant=interpolant)\n\nOnce the optimization is complete, we can visualize the trajetory with the builtin vis.trajectory() function:\n\ntop.vis.trajectory(flight)\nplt.show()\n\n\n\n\n\n\n\n\nWe can create visualization code so that the trajectory is plotted along the cost grid at different altitudes and time steps. In the following figure, you can see the flight avoided the regions with highest cost, while maintaining a small detour to avoid excess fuel consumption. This is similar to the 3D cost grid, but with the added time dimension.\n\n\nShow the function flight_level_cost_4d() used for visulization\ndef flight_level_cost_4d(flight, df_cost):\n    from cartopy import crs as ccrs\n    from cartopy.feature import BORDERS\n\n    proj = ccrs.PlateCarree()\n\n    fig, axes = plt.subplots(\n        3,\n        2,\n        figsize=(9, 9),\n        subplot_kw=dict(\n            projection=ccrs.TransverseMercator(\n                central_longitude=15, central_latitude=45\n            )\n        ),\n    )\n\n    for i, ax in enumerate(axes.flatten()):\n        ax.set_extent([-10, 40, 32, 60])\n        ax.add_feature(BORDERS, lw=0.5, color=\"gray\")\n        ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n\n        df_cost_pivot = df_cost.query(\n            f\"height=={df_cost.height.max()} and ts=={i*1800}\"\n        ).pivot(index=\"latitude\", columns=\"longitude\", values=\"cost\")\n\n        lat, lon, val = (\n            df_cost_pivot.index.values,\n            df_cost_pivot.columns.values,\n            df_cost_pivot.values,\n        )\n\n        ax.contourf(lon, lat, val, transform=proj, alpha=0.7, cmap=\"Purples\")\n\n        current = flight.query(f\"{i*1800}&lt;ts&lt;{i*1800+600}\").iloc[0]\n\n        ax.text(\n            0.03, 0.9, f\"Time={int(current.ts)}s\", transform=ax.transAxes, fontsize=14\n        )\n\n        ax.scatter(current.longitude, current.latitude, color=\"r\", lw=5, transform=proj)\n\n        ax.plot(flight.longitude, flight.latitude, color=\"k\", lw=1, transform=proj)\n\n        for r, p in flight.iloc[[0, -1]].iterrows():\n            ax.scatter(p.longitude, p.latitude, c=\"k\", transform=proj)\n\n    plt.tight_layout()\n    plt.show()\n\n\n\nflight_level_cost_4d(flight, df_cost_4d)",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üôÄ Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html",
    "href": "optimize/contrails.html",
    "title": "12¬† ü•† Contrails",
    "section": "",
    "text": "12.1 Building the cost grid\nContrails are line-shaped clouds produced by aircraft. They are formed when the water vapor in the exhaust of an airplane engine condenses and freezes. Depending on the atmospheric conditions, contrails are made up of ice crystals and can last for a few seconds to several hours.\nSimilar to cirrus clouds, contrails can trap heat in the atmosphere, which has a warming effect. They can also reflect sunlight back into space, which can have a cooling effect. The net effect of contrails on the climate is still a topic of ongoing research. But many companies and policymakers have already been pushing the adoption of contrail optimization.\nI have more skepticism about its operational maturity, as a lot of the uncertainties are yet to be addressed. But it is a good example to show how the TOP library can be used to perform this kind of optimization. In this chapter, we will explain how we can combine the knowledge of the previously explained wind cost grid to optimize a trajectory to study the trade-off between contrail and fuel.\nIn the previous chapter, we have built a cost grid that represents the cost of flying in a certain region. Here we want to construct a cost grid that represents the climate cost of contrails and CO2 emissions, which are converted to temperature response based on their effective radiative forcing (ERF) in W/m2.\nThe source of the example data is obtained from the paper Yin et al. (2023). The data is based on the ECMWF data and is used to calculate the contrail temperature response (ATR20) in K/km. The data is available in the netCDF format and is stored in the 3D grid of latitude, longitude, and pressure level.\nFirst, we will download the associated data with the paper using the following code:\nNext, we will read the data and convert it to a cost grid. We will use only the data from December 18, 2015 as example, which is also the date used in the paper.\nimport xarray as xr\n\nds = xr.open_dataset(\"tmp/contrail.nc\").sel(time=\"2015-12-18\")\nIn this dataset, the levels are defined using L31 model from ECMWF. In order to convert the pressure levels to height, we use the following corresponding pressure altitude in hPa, which will be used to calculate the height in m:\nL31 level to pressure in hPa\nlevel_pressure = [\n    0.0000,\n    10.0000,\n    30.0000,\n    50.0000,\n    70.0000,\n    90.0787,\n    110.6606,\n    132.3968,\n    155.7909,\n    181.1544,\n    208.6494,\n    238.3258,\n    270.1530,\n    304.0465,\n    339.8891,\n    377.5467,\n    416.8789,\n    457.7442,\n    500.0000,\n    543.4970,\n    588.0685,\n    633.5144,\n    679.5799,\n    725.9285,\n    772.1102,\n    817.5241,\n    861.3757,\n    902.6287,\n    939.9520,\n    971.6610,\n    995.6532,\n    1009.3396,\n]\nThe following code will convert the contrail temperature response to a cost grid.\nimport openap\nimport pandas as pd\nimport numpy as np\n\ndf = (\n    ds.to_dataframe()\n    .reset_index()\n    .assign(lev=lambda x: x.lev.astype(int))\n    .merge(\n        pd.DataFrame(level_pressure, columns=[\"hPa\"]).reset_index(names=\"lev\"),\n        on=\"lev\",\n    )\n    .assign(height=lambda x: openap.aero.h_isa(x.hPa * 100).round(-2))\n    .assign(longitude=lambda x: ((x.lon + 180) % 360 - 180))\n    .query(\"height&lt;15000\")\n)\n\ndf_cost_world = df.rename(\n    columns={\n        \"lat\": \"latitude\",\n        \"atr20_contrail\": \"cost\",\n    }\n)[[\"time\", \"latitude\", \"longitude\", \"hPa\", \"height\", \"cost\"]]\n\ndf_cost_world.head()\n\n\n\n\n\n\n\n\ntime\nlatitude\nlongitude\nhPa\nheight\ncost\n\n\n\n\n6\n2015-12-18\n87.8638\n0.0\n132.3968\n14400.0\n0.000000e+00\n\n\n7\n2015-12-18\n87.8638\n0.0\n155.7909\n13400.0\n0.000000e+00\n\n\n8\n2015-12-18\n87.8638\n0.0\n181.1544\n12400.0\n9.405122e-13\n\n\n9\n2015-12-18\n87.8638\n0.0\n208.6494\n11500.0\n8.791347e-13\n\n\n10\n2015-12-18\n87.8638\n0.0\n238.3258\n10700.0\n7.871002e-13\nBefore we use the data for optimization, let‚Äôs reproduce the example from the paper with the cost grid for Europe at 250 hPa, which is approximately 10,700m. The selected EU region is defined as 30-70 latitude and -20 to 40 longitude.\nimport matplotlib.pyplot as plt\nfrom cartopy import crs as ccrs\nfrom cartopy.feature import BORDERS\n\nproj = ccrs.TransverseMercator(central_longitude=10, central_latitude=50)\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4), subplot_kw=dict(projection=proj))\n\ndf_cost_eu_250hpa = (\n    df_cost_world.query(\"height==10700\")\n    .query(\"-20&lt;longitude&lt;40 and 30&lt;latitude&lt;70\")\n    .sort_values([\"latitude\", \"longitude\"])\n)\n\nhours = [0, 12]\n\nfor ax, hour in zip(axes, hours):\n    df_cost_pivot = df_cost_eu_250hpa.query(f\"time.dt.hour=={hour}\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n\n    ax.set_extent([-20, 40, 28, 70])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n    ax.gridlines(draw_labels=True, lw=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\")\n\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost_eu_250hpa.cost.max(),\n        vmax=df_cost_eu_250hpa.cost.max(),\n    )",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>ü•† Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#building-the-cost-grid",
    "href": "optimize/contrails.html#building-the-cost-grid",
    "title": "12¬† ü•† Contrails",
    "section": "",
    "text": "import urllib\n\nurllib.request.urlretrieve('https://opendap.4tu.nl/thredds/fileServer/data2/djht/bea8a3fe-e34c-4598-9f94-c5a5c63348e5/1/contrail_original.nc', 'tmp/contrail.nc')\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA few things to pay attention to: - longitude from ECMWF data is in the range of 0 to 360, we need to convert it to -180 to 180. - The height is in hPa, we need to convert it to m. - We will only use the data below 15,000m (below FL500). - The cost dataframe must contain the following minimum columns: ‚Äòlatitude‚Äô, ‚Äòlongitude‚Äô, ‚Äòheight‚Äô, ‚Äòcost‚Äô.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>ü•† Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#the-contrail-grid",
    "href": "optimize/contrails.html#the-contrail-grid",
    "title": "12¬† ü•† Contrails",
    "section": "12.2 The contrail grid",
    "text": "12.2 The contrail grid\nSince the grid is sparse in the time dimension, with data at 00:00, 06:00, 12:00, and 18:00, we will only use the data at 12:00 for the optimization, which simplifies the cost grid to 3D. We will also smooth the grid using a Gaussian filter.\n\n\n\n\n\n\nNote\n\n\n\nIt is also practical to smooth the grid, most importantly the vertical axis, so that the optimization can be more stable. The Gaussian filter helps to prevent sharp discontinuities in the cost grid, thus improving the gradient calculation.\n\n\n\nfrom scipy.ndimage import gaussian_filter\n\ndf_cost = df_cost_world.query(\n    \"-20&lt;longitude&lt;40 and 30&lt;latitude&lt;70 and time.dt.hour==12\"\n).sort_values([\"height\", \"latitude\", \"longitude\"])\n\ncost = df_cost.cost.values.reshape(\n    df_cost.height.nunique(),\n    df_cost.latitude.nunique(),\n    df_cost.longitude.nunique(),\n)\n\ncost_ = gaussian_filter(cost, sigma=1, mode=\"nearest\")\ndf_cost = df_cost.assign(cost=cost_.flatten())\n\nNext, we can plot the smoothed cost grid for different heights.\n\nfig, axes = plt.subplots(3, 3, figsize=(12, 10), subplot_kw=dict(projection=proj))\n\nheights = df_cost.height.unique()\nskip_levels = 15\n\nfor i, ax in enumerate(axes.flatten()):\n    df_cost_pivot = df_cost.query(f\"height=={heights[skip_levels+i]}\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n\n    ax.set_extent([-20, 40, 28, 70])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n    ax.gridlines(\n        draw_labels=False, linewidth=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\"\n    )\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost.cost.quantile(0.99),\n        vmax=df_cost.cost.quantile(0.99),\n    )\n\n    fl = heights[skip_levels + i] / openap.aero.ft // 1000 * 10\n\n    ax.text(0.03, 0.9, f\"FL{int(fl)}\", transform=ax.transAxes, fontsize=14)\n\nplt.tight_layout()",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>ü•† Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#optimization-for-both-contrail-and-co2",
    "href": "optimize/contrails.html#optimization-for-both-contrail-and-co2",
    "title": "12¬† ü•† Contrails",
    "section": "12.3 Optimization for both contrail and CO2",
    "text": "12.3 Optimization for both contrail and CO2\nNow we can use the cost grid to optimize a trajectory. Again, we use the example flight from Amsterdam (EHAM) to Athens (LGAV).\nThe final cost function is the combination of temperature response (ATR20) from both contrails and CO2 emissions.\nThe unit of the contrail temperature response from the paper is in K/km; however, the optimizer requires the cost to be divided by time, thus we need to convert the unit to K/s. In this case, we first define the cost to be not time-dependent. Then, we multiply the cost by the true airspeed of the aircraft with a conversion factor of 1e-3, which is the speed of the aircraft in km/s.\nFor the CO2 emissions, we use the conversion factor of 7.03e-15 K/kg to convert the fuel flow (kg/s) to temperature response (K/s).\nIn addition to the default combined effect of contrail and CO2, we will build a fuel optimal trajectory as a comparison. The fuel optimal trajectory is obtained by setting the contrail cost to zero.\n\nfrom openap import top\n\noptimizer = top.Cruise(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\noptimizer.setup(debug=False, max_iteration=2000)\n\nflight_fuel_optimal = optimizer.trajectory(objective=\"fuel\")\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost)\n\n\ndef objective(x, u, dt, **kwargs):\n    scale_contrail = kwargs.get(\"scale_contrail\", 1)\n    scale_co2 = kwargs.get(\"scale_co2\", 1)\n\n    xp, yp, h, m, ts = x[0], x[1], x[2], x[3], x[4]\n    mach, vs, psi = u[0], u[1], u[2]\n    vtas = openap.casadi.aero.mach2tas(mach, h)\n    contrail_cost = (\n        optimizer.obj_grid_cost(x, u, dt, n_dim=3, time_dependent=False, **kwargs)\n        * vtas\n        * 1e-3\n    ) * scale_contrail\n    co2_cost = optimizer.obj_fuel(x, u, dt, **kwargs) * 7.03e-15 * scale_co2\n    return contrail_cost + co2_cost\n\n\nflight = optimizer.trajectory(\n    objective=objective,\n    interpolant=interpolant,\n    initial_guess=flight_fuel_optimal,\n    return_failed=True,\n)\n\nresults = {}\nresults[\"fuel_optimal\"] = flight_fuel_optimal\nresults[\"accf_optimal\"] = flight\n\nNext we can visualize the final flight trajectory. Note that the cost grid at FL350 is shown in the background.\n\n\nShow the code of plot_flight() used for visulization\ndef plot_flight(results, df_cost, scenarios=None):\n    proj = ccrs.TransverseMercator(central_longitude=10, central_latitude=50)\n\n    fig = plt.figure(figsize=(12, 5))\n\n    ax = fig.add_subplot(1, 2, 1)\n\n    for scenario, flight in results.items():\n        ax.plot(flight.ts, flight.altitude, lw=2)\n        ax.set_ylim(0, 40000)\n    ax.set_xlabel(\"Time [s]\")\n    ax.set_ylabel(\"Altitude [ft]\")\n\n    ax = plt.subplot(1, 2, 2, projection=proj)\n\n    df_cost_pivot = df_cost.query(\"height==10700\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n    ax.set_extent([0, 30, 35, 55])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"50m\", lw=0.5, color=\"gray\")\n    ax.gridlines(\n        draw_labels=False, linewidth=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\"\n    )\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost.cost.max(),\n        vmax=df_cost.cost.max(),\n    )\n\n    for scenario, flight in results.items():\n        ax.plot(\n            flight.longitude,\n            flight.latitude,\n            transform=ccrs.PlateCarree(),\n            lw=2,\n            label=f\"{scenario} | fuel: {int(flight.fuel.sum())} kg\",\n        )\n\n    for r, p in flight.iloc[[0, -1]].iterrows():\n        ax.scatter(\n            p.longitude,\n            p.latitude,\n            c=\"k\",\n            transform=ccrs.PlateCarree(),\n        )\n\n    ax.legend()\n    plt.tight_layout()\n    plt.show()\n\n\n\n\ncacluate extra fuel\naccf_fuel = results[\"accf_optimal\"].fuel.sum()\nfuel_fuel = results[\"fuel_optimal\"].fuel.sum()\n\nextra_fuel = int((accf_fuel - fuel_fuel).round(-1))\nextra_fuel_percent = int(((accf_fuel / fuel_fuel - 1) * 100).round())\n\n\n\nplot_flight(results, df_cost)\n\n\n\n\n\n\n\n\nIn this example, we can see that the optimal trajectory considering both contrail and CO2 climate effects fly at a very low altitude to avoide regions with high contrail cost. This comes with a great cost in terms of fuel, which is significantly higher than the fuel optimal trajectory. The extra fuel cost is about 1710 kg, which accounts for about 24% extra fuel when compared to the optimal case.\nTo perform a more fair comparison, we will constraint the altitude of the desired trajectory to be within the range of the fuel optimal trajectory. This can be done by setting the h_min and h_max arguments in the optimizer.trajectory() function. A margion of 600 meters is added to the minimum and maximum altitude of the fuel optimal trajectory.\n\nflight = optimizer.trajectory(\n    objective=objective,\n    interpolant=interpolant,\n    initial_guess=flight_fuel_optimal,\n    h_min=flight_fuel_optimal.h.min() - 600,\n    h_max=flight_fuel_optimal.h.max() + 600,\n    return_failed=True,\n)\n\nresults = {}\nresults[\"fuel_optimal\"] = flight_fuel_optimal\nresults[\"accf_optimal\"] = flight\n\n\n\ncacluate extra fuel\naccf_fuel = results[\"accf_optimal\"].fuel.sum()\nfuel_fuel = results[\"fuel_optimal\"].fuel.sum()\n\nextra_fuel = int((accf_fuel - fuel_fuel).round(-1))\nextra_fuel_percent = int(((accf_fuel / fuel_fuel - 1) * 100).round())\n\n\n\nplot_flight(results, df_cost)\n\n\n\n\n\n\n\n\nEven in this constrained trajectory, we can see that the sub-optimal trajectory considering both contrail and CO2 climate effects differs largely from the fuel optimal trajectory. A large lateral deviation is observed in both the altitude and the route to avoid regions with high contrail cost.\nThis deviation costs about 570 kg of fuel, which accounts for about 8% extra fuel when compared to the optimal case. This is a still a significant amount of fuel, results in greater monetary cost and excess CO2 emissions.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>ü•† Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#uncertainties-that-makes-or-breaks-the-optimization",
    "href": "optimize/contrails.html#uncertainties-that-makes-or-breaks-the-optimization",
    "title": "12¬† ü•† Contrails",
    "section": "12.4 Uncertainties that makes or breaks the optimization",
    "text": "12.4 Uncertainties that makes or breaks the optimization\nIn recent studies regarding operational contrail mitigation, we often miss the fact that the contrail cost is highly uncertain. In the paper The contribution of global aviation to anthropogenic climate forcing for 2000 to 2018 Lee et al. (2021), the authors have pointed out that the uncertainties in the effective radiative forcing caused by contrail cirrus can be between 17 and 98 mW/m2. This is a huge range, but many studies only consider the mean value of 57.4.\nThis large scale of uncertainties can lead to completely different optimal trajectories. In the following example, we will show how the optimization results can be affected by the uncertainties in the contrail cost.\nFirst of all, different scenarios and scaling factors for contrail and CO2 are defined as follows:\n\nmore_scenarios = {\n    \"fuel_optimal\": [0, 1],\n    \"accf_optimal\": [1, 1],\n    \"lo_contrail_high_co2\": [0.293, 1.166],\n    \"lo_contrail_lo_co2\": [0.293, 0.816],\n    \"hi_contrail_lo_co2\": [1.707, 0.816],\n    \"hi_contrail_hi_co2\": [1.707, 1.166],\n}\n\nIn the above scenarios, for example, lo_contrail_high_co2 refers to scaling the contrail impact to a lower bound of 29.3% of the default value, while the CO2 cost is scaled to the upper bound of 116.6% of the default value. In this case, the contrail has a significantly lower impact than what has been assumed in the default case, while the CO2 cost is slightly higher.\nThe following code will run the optimization for all the scenarios and visualize the results. Note that the altitude constraints are still applied to the optimizations.\n\nfrom openap import top\n\noptimizer = top.Cruise(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\noptimizer.setup(debug=False, max_iteration=2000)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost)\n\nmore_results = {}\n\nfor scenario, weights in more_scenarios.items():\n    print(f\"runing scenario: {scenario}\")\n    flight = optimizer.trajectory(\n        objective=objective,\n        interpolant=interpolant,\n        initial_guess=flight_fuel_optimal,\n        h_min=flight_fuel_optimal.h.min() - 600,\n        h_max=flight_fuel_optimal.h.max() + 600,\n        scale_contrail=weights[0],\n        scale_co2=weights[1],\n        return_failed=True,\n    )\n    more_results[scenario] = flight\n\nruning scenario: fuel_optimal\nruning scenario: accf_optimal\nruning scenario: lo_contrail_high_co2\nruning scenario: lo_contrail_lo_co2\nruning scenario: hi_contrail_lo_co2\nruning scenario: hi_contrail_hi_co2\n\n\n\nplot_flight(more_results, df_cost)\n\n\n\n\n\n\n\n\nWhat we can see based on these results is that the optimal trajectory can be very different depending on the uncertainties in the contrail cost. In the case of lo_contrail_high_co2, the optimal trajectory is much closer to the fuel optimal trajectory, as the contrail cost is significantly lower than the default value. In the case of hi_contrail_lo_co2, it has the highest deviation from the fuel optimal trajectory.\nGiven the large uncertainties in the contrail cost, without a better understanding of the uncertainties, pushing operations to perform deviations caused by contrails may come with a large cost in terms of fuel and CO2 emissions.\n\n\n\n\nLee, D. S., Fahey, D. W., Skowron, A., Allen, M. R., Burkhardt, U., Chen, Q., Doherty, S. J., Freeman, S., Forster, P. M., Fuglestvedt, J., et al. (2021). The contribution of global aviation to anthropogenic climate forcing for 2000 to 2018. Atmospheric Environment, 244, 117834.\n\n\nYin, F., Grewe, V., Castino, F., Rao, P., Matthes, S., Dahlmann, K., Dietm√ºller, S., Fr√∂mming, C., Yamashita, H., Peter, P., et al. (2023). Predicting the climate impact of aviation for en-route emissions: The algorithmic climate change function submodel ACCF 1.0 of EMAC 2.53. Geoscientific Model Development, 16(11), 3313‚Äì3334.",
    "crumbs": [
      "ü¶∏ Trajectory Optimizer",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>ü•† Contrails</span>"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "üìñ API Reference",
    "section": "",
    "text": "This section provides a complete reference for every public module, class, and function in OpenAP.\nConventions\n\nSpeed: knots (kt) for airspeed inputs in performance models\nAltitude: feet (ft) for altitude inputs in performance models\nVertical rate: feet per minute (ft/min)\nMass: kilograms (kg)\nForce (thrust/drag): Newtons (N)\nFuel flow: kg/s\nEmissions: g/s\nAero/Geo modules: SI units (meters, m/s, Pa, K, degrees)\n\nAll performance classes (Thrust, Drag, FuelFlow, Emission) accept an optional backend parameter to switch between NumPy (default), CasADi, or JAX computation. See Backends for details.",
    "crumbs": [
      "üìñ API Reference"
    ]
  },
  {
    "objectID": "api/prop.html",
    "href": "api/prop.html",
    "title": "13¬† ü™¨ prop",
    "section": "",
    "text": "The prop module provides access to aircraft and engine property data.\n\nfrom openap import prop\nfrom pprint import pprint\n\n\n13.0.1 available_aircraft(use_synonym=False)\nGet a list of available aircraft types in OpenAP.\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nuse_synonym\nbool\nInclude synonyms in the list. Default: False\n\n\n\nReturns: List[str] ‚Äî List of ICAO aircraft type codes\n\n# Get first 10 available aircraft types\nprop.available_aircraft()[:10]\n\n['a19n',\n 'a20n',\n 'a21n',\n 'a318',\n 'a319',\n 'a320',\n 'a321',\n 'a332',\n 'a333',\n 'a343']\n\n\n\n\n13.0.2 aircraft(ac, use_synonym=False)\nGet detailed performance parameters for a specific aircraft type.\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nac\nstr\nICAO aircraft type code (e.g., ‚ÄúA320‚Äù)\n\n\nuse_synonym\nbool\nUse synonym if aircraft not found. Default: False\n\n\n\nReturns: Dict[str, Any] ‚Äî Dictionary containing performance parameters including maximum takeoff weight (mtow), maximum landing weight (mlw), operating empty weight (oew), dimensions, engine information, and other aircraft specifications.\n\n# Get aircraft details for A320\naircraft_data = prop.aircraft(\"A320\")\npprint(aircraft_data)\n\n{'aircraft': 'Airbus A320',\n 'ceiling': 12500,\n 'cruise': {'height': 11000, 'mach': 0.78, 'range': 5000},\n 'drag': {'cd0': 0.018, 'e': 0.799, 'gears': 0.017, 'k': 0.039},\n 'engine': {'default': 'CFM56-5B4',\n            'mount': 'wing',\n            'number': 2,\n            'options': {'A320-111': 'CFM56-5-A1',\n                        'A320-211': 'CFM56-5-A1',\n                        'A320-212': 'CFM56-5A3',\n                        'A320-214': 'CFM56-5B4',\n                        'A320-215': 'CFM56-5B5',\n                        'A320-216': 'CFM56-5B6',\n                        'A320-231': 'V2500-A1',\n                        'A320-232': 'V2527-A5',\n                        'A320-233': 'V2527E-A5'},\n            'type': 'turbofan'},\n 'flaps': {'Sf/S': 0.17,\n           'area': 21.1,\n           'bf/b': 0.78,\n           'cf/c': 0.176,\n           'lambda_f': 0.9,\n           'type': 'single-slotted'},\n 'fuel': {'engine': 'CFM56-5B4/P', 'fuel_coef': 2.65942225},\n 'fuselage': {'height': 4.14, 'length': 37.57, 'width': 3.95},\n 'limits': {'MFC': 24210,\n            'MLW': 66000,\n            'MMO': 0.82,\n            'MTOW': 78000,\n            'OEW': 42600,\n            'VMO': 350,\n            'ceiling': 12500},\n 'mfc': 24210,\n 'mlw': 66000,\n 'mmo': 0.82,\n 'mtow': 78000,\n 'oew': 42600,\n 'pax': {'high': 170, 'low': 140, 'max': 180},\n 'vmo': 350,\n 'wing': {'area': 124, 'mac': 4.1935, 'span': 35.8, 'sweep': 25, 't/c': None}}\n\n\n\n\n13.0.3 aircraft_engine_options(ac)\nGet the list of engine options available for a specific aircraft type.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nac\nstr\nICAO aircraft type code (e.g., ‚ÄúA320‚Äù)\n\n\n\nReturns: List[str] ‚Äî List of engine type strings\n\n# Get engine options for A320\nprop.aircraft_engine_options(\"A320\")\n\n['CFM56-5-A1',\n 'CFM56-5-A1',\n 'CFM56-5A3',\n 'CFM56-5B4',\n 'CFM56-5B5',\n 'CFM56-5B6',\n 'V2500-A1',\n 'V2527-A5',\n 'V2527E-A5']\n\n\n\n\n13.0.4 search_engine(eng)\nSearch for engines that match the given prefix string.\n\n\n\nParameter\nType\nDescription\n\n\n\n\neng\nstr\nEngine type prefix (e.g., ‚ÄúCFM56‚Äù)\n\n\n\nReturns: List[str] or None ‚Äî List of matching engine types, or None if no matches found\n\n# Search for CFM56 engines\nprop.search_engine(\"CFM56\")\n\n['CFM56-2A',\n 'CFM56-2B-1',\n 'CFM56-2-C5',\n 'CFM56-3-B1',\n 'CFM56-3B-2',\n 'CFM56-3C-1',\n 'CFM56-5-A1',\n 'CFM56-5A3',\n 'CFM56-5A4',\n 'CFM56-5A5',\n 'CFM56-5B1',\n 'CFM56-5B1/2',\n 'CFM56-5B1/2P',\n 'CFM56-5B1/3',\n 'CFM56-5B1/P',\n 'CFM56-5B2',\n 'CFM56-5B2/2',\n 'CFM56-5B2/2P',\n 'CFM56-5B2/3',\n 'CFM56-5B2/P',\n 'CFM56-5B3/2P',\n 'CFM56-5B3/3',\n 'CFM56-5B3/P',\n 'CFM56-5B4',\n 'CFM56-5B4/2',\n 'CFM56-5B4/2P',\n 'CFM56-5B4/3',\n 'CFM56-5B4/P',\n 'CFM56-5B5/3',\n 'CFM56-5B5/P',\n 'CFM56-5B6/2',\n 'CFM56-5B6/2P',\n 'CFM56-5B6/3',\n 'CFM56-5B6/P',\n 'CFM56-5B7/3',\n 'CFM56-5B7/P',\n 'CFM56-5B8/3',\n 'CFM56-5B8/P',\n 'CFM56-5B9/2P',\n 'CFM56-5B9/3',\n 'CFM56-5B9/P',\n 'CFM56-5C2',\n 'CFM56-5C2/P',\n 'CFM56-5C3',\n 'CFM56-5C3/P',\n 'CFM56-5C4',\n 'CFM56-5C4/P',\n 'CFM56-7B18',\n 'CFM56-7B18/3',\n 'CFM56-7B20',\n 'CFM56-7B20/2',\n 'CFM56-7B20/3',\n 'CFM56-7B20E',\n 'CFM56-7B22',\n 'CFM56-7B22/2',\n 'CFM56-7B22/3',\n 'CFM56-7B22E',\n 'CFM56-7B22E/B1',\n 'CFM56-7B24',\n 'CFM56-7B24/2',\n 'CFM56-7B24/3',\n 'CFM56-7B24E',\n 'CFM56-7B24E/B1',\n 'CFM56-7B26',\n 'CFM56-7B26/2',\n 'CFM56-7B26/3',\n 'CFM56-7B26E',\n 'CFM56-7B26E/B1',\n 'CFM56-7B26E/B2',\n 'CFM56-7B26E/B2F',\n 'CFM56-7B26E/F',\n 'CFM56-7B27',\n 'CFM56-7B27/2',\n 'CFM56-7B27/3',\n 'CFM56-7B27AE',\n 'CFM56-7B27E',\n 'CFM56-7B27E/B1',\n 'CFM56-7B27E/B1F',\n 'CFM56-7B27E/B3',\n 'CFM56-7B27E/F']\n\n\n\n\n13.0.5 engine(eng)\nGet detailed parameters for a specific engine type.\n\n\n\nParameter\nType\nDescription\n\n\n\n\neng\nstr\nEngine type (e.g., ‚ÄúCFM56-5B6‚Äù)\n\n\n\nReturns: Dict[str, Any] ‚Äî Dictionary containing engine specifications including thrust, fuel flow, specific fuel consumption, and other performance parameters.\n\n# Get engine details for CFM56-5B4\nengine_data = prop.engine(\"CFM56-5B4\")\npprint(engine_data)\n\n{'bpr': 5.9,\n 'cruise_alt': 35000.0,\n 'cruise_mach': 0.8,\n 'cruise_sfc': 0.0154,\n 'cruise_thrust': 22241.0,\n 'ei_co_app': 2.33,\n 'ei_co_co': 0.5,\n 'ei_co_idl': 31.9,\n 'ei_co_to': 0.5,\n 'ei_hc_app': 0.13,\n 'ei_hc_co': 0.1,\n 'ei_hc_idl': 3.87,\n 'ei_hc_to': 0.1,\n 'ei_nox_app': 10.0,\n 'ei_nox_co': 23.3,\n 'ei_nox_idl': 4.3,\n 'ei_nox_to': 28.7,\n 'ff_app': 0.326,\n 'ff_co': 0.961,\n 'ff_idl': 0.107,\n 'ff_to': 1.166,\n 'fuel_ch': np.float64(5.2e-07),\n 'fuel_lto': 421.0,\n 'manufacturer': 'CFM International',\n 'max_thrust': 117900.0,\n 'name': 'CFM56-5B4',\n 'pr': 27.1,\n 'type': 'TF',\n 'uid': '2CM014'}",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>ü™¨ prop</span>"
    ]
  },
  {
    "objectID": "api/thrust.html",
    "href": "api/thrust.html",
    "title": "14¬† ‚ö° Thrust",
    "section": "",
    "text": "Thrust model based on a simplified two-shaft turbofan model.\n\nfrom openap import Thrust\nthrust = Thrust(\"A320\")\n\n\n14.0.1 Thrust(ac, eng=None, backend=None)\nInitialize a thrust model for a specific aircraft and engine combination.\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nac\nstr\nICAO aircraft type (e.g., ‚ÄúA320‚Äù)\n\n\neng\nstr, optional\nEngine type (e.g., ‚ÄúCFM56-5A3‚Äù). Default: aircraft‚Äôs default engine\n\n\nbackend\nMathBackend, optional\nComputation backend. Default: NumpyBackend\n\n\n\n\n\n14.0.2 takeoff(tas, alt=0, dT=0)\nCalculate total thrust at takeoff condition.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nRunway altitude. Default: 0\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: Total thrust (N)\n\nthrust.takeoff(tas=100, alt=0)\n\n200722.99758761944\n\n\n\n\n14.0.3 cruise(tas, alt, dT=0)\nCalculate thrust at cruise condition.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nAltitude\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: Total thrust (N)\n\nthrust.cruise(tas=450, alt=35000)\n\n46159.58086889595\n\n\n\n\n14.0.4 climb(tas, alt, roc, dT=0)\nCalculate thrust during climb.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nAltitude\n\n\nroc\nfloat\nft/min\nRate of climb\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: Total thrust (N)\n\nthrust.climb(tas=250, alt=10000, roc=2000)\n\n91946.25704312592\n\n\n\n\n14.0.5 descent_idle(tas, alt, dT=0)\nCalculate idle thrust during descent. Idle thrust is approximated as 7% of maximum available thrust.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nAltitude\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: Total thrust (N)\n\nthrust.descent_idle(tas=300, alt=20000)\n\n6358.064951276059",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>‚ö° Thrust</span>"
    ]
  },
  {
    "objectID": "api/drag.html",
    "href": "api/drag.html",
    "title": "15¬† üå¨Ô∏è Drag",
    "section": "",
    "text": "Drag model based on drag polar coefficients.\n\nfrom openap import Drag\ndrag = Drag(\"A320\")\n\n\n15.0.1 Drag(ac, wave_drag=False, backend=None)\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nac\nstr\nICAO aircraft type (e.g., ‚ÄúA320‚Äù)\n\n\nwave_drag\nbool\nEnable wave drag model (experimental). Default: False\n\n\nbackend\nMathBackend, optional\nComputation backend. Default: NumpyBackend\n\n\n\n\n\n15.0.2 clean(mass, tas, alt, vs=0, dT=0)\nCompute drag at clean configuration (cruise, climb, descent ‚Äî no flaps, gear up).\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nmass\nfloat\nkg\nAircraft mass\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nAltitude\n\n\nvs\nfloat\nft/min\nVertical rate. Default: 0\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: Total drag (N)\n\ndrag.clean(mass=60000, tas=250, alt=30000)\n\n37192.35192276492\n\n\n\n\n15.0.3 nonclean(mass, tas, alt, flap_angle, vs=0, dT=0, landing_gear=False)\nCompute drag at non-clean configuration (flaps deployed, gear extended).\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nmass\nfloat\nkg\nAircraft mass\n\n\ntas\nfloat\nkt\nTrue airspeed\n\n\nalt\nfloat\nft\nAltitude\n\n\nflap_angle\nfloat\ndegree\nFlap deflection angle\n\n\nvs\nfloat\nft/min\nVertical rate. Default: 0\n\n\ndT\nfloat\nK\nISA temperature deviation. Default: 0\n\n\nlanding_gear\nbool\n‚Äî\nLanding gear extended? Default: False\n\n\n\nReturns: Total drag (N)\n\ndrag.nonclean(mass=60000, tas=180, alt=5000, flap_angle=20, landing_gear=True)\n\n43298.09038943537",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>üå¨Ô∏è Drag</span>"
    ]
  },
  {
    "objectID": "api/fuelflow.html",
    "href": "api/fuelflow.html",
    "title": "16¬† üî• FuelFlow",
    "section": "",
    "text": "Fuel flow model based on the ICAO emission databank.\n\nfrom openap import FuelFlow\n\n\n16.0.1 FuelFlow(ac, eng=None, backend=None)\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nac\nstr\nICAO aircraft type (e.g., ‚ÄúA320‚Äù)\n\n\neng\nstr, optional\nEngine type. Default: aircraft‚Äôs default engine.\n\n\nbackend\nMathBackend, optional\nComputation backend. Default: NumpyBackend.\n\n\n\n\nfuelflow = FuelFlow(\"A320\")\n\n\n\n16.0.2 enroute(mass, tas, alt, vs=0, acc=0, dT=0, limit=True)\nCompute fuel flow during climb, cruise, or descent (clean configuration, no flaps/gear).\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nmass\nfloat/array\nkg\nAircraft mass\n\n\ntas\nfloat/array\nkt\nTrue airspeed\n\n\nalt\nfloat/array\nft\nAltitude\n\n\nvs\nfloat/array\nft/min\nVertical rate. Default 0.\n\n\nacc\nfloat/array\nm/s¬≤\nAcceleration. Default 0.\n\n\ndT\nfloat/array\nK\nISA temperature deviation. Default 0.\n\n\nlimit\nbool\n‚Äî\nApply thrust limits. Default True.\n\n\n\nReturns: Fuel flow (kg/s)\n\nfuelflow.enroute(mass=60000, tas=250, alt=30000)\n\n0.7848076572156082\n\n\n\n\n16.0.3 takeoff(tas, alt=None, throttle=1)\nCompute fuel flow at takeoff.\n\n\n\n\n\n\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntas\nfloat/array\nkt\nTrue airspeed\n\n\nalt\nfloat/array\nft\nAirport altitude. Default: sea level.\n\n\nthrottle\nfloat/array\n‚Äî\nThrottle setting, 0 to 1. Default 1 (full thrust).\n\n\n\nReturns: Fuel flow (kg/s)\n\nfuelflow.takeoff(tas=100, alt=0)\n\n2.1467180381321667\n\n\n\n\n16.0.4 at_thrust(total_ac_thrust)\nCompute fuel flow at a given total aircraft thrust.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ntotal_ac_thrust\nfloat/array\nN\nTotal net thrust\n\n\n\nReturns: Fuel flow (kg/s)\n\nfuelflow.at_thrust(total_ac_thrust=50000)\n\n1.0309944492235337\n\n\n\n\n16.0.5 plot_model(plot=True)\nPlot the engine fuel model.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nplot\nbool\nDisplay plot or return pyplot object. Default True.\n\n\n\n\nfuelflow.plot_model()",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>üî• FuelFlow</span>"
    ]
  },
  {
    "objectID": "api/emission.html",
    "href": "api/emission.html",
    "title": "17¬† üí® Emission",
    "section": "",
    "text": "Emission model based on the ICAO emission databank. Uses the Boeing Fuel Flow Method 2 (BFFM2) for altitude corrections.\n\n17.0.1 Emission(ac, eng=None, backend=None)\nCreate an emission model instance.\n\n\n\n\n\n\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nac\nstr\n-\nICAO aircraft type (e.g.¬†‚ÄúA320‚Äù)\n\n\neng\nstr, optional\n-\nEngine type. Default: aircraft‚Äôs default engine\n\n\nbackend\nMathBackend, optional\n-\nComputation backend. Default: NumpyBackend\n\n\n\nFuel-proportional emissions\nThese methods only need fuel flow as input (no altitude correction):\n\n\n17.0.2 co2(ffac)\nCompute CO2 emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\n\nReturns: CO2 emission (g/s)\n\n\n17.0.3 h2o(ffac)\nCompute H2O emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\n\nReturns: H2O emission (g/s)\n\n\n17.0.4 soot(ffac)\nCompute soot emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\n\nReturns: Soot emission (g/s)\n\n\n17.0.5 sox(ffac)\nCompute SOx emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\n\nReturns: SOx emission (g/s)\nAltitude-corrected emissions\nThese methods use BFFM2 to correct for altitude effects:\n\n\n17.0.6 nox(ffac, tas, alt=0, dT=0)\nCompute NOx emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\ntas\nfloat/array\nkt\nTrue airspeed\n\n\nalt\nfloat/array\nft\nAltitude. Default: 0\n\n\ndT\nfloat/array\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: NOx emission (g/s)\n\n\n17.0.7 co(ffac, tas, alt=0, dT=0)\nCompute CO emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\ntas\nfloat/array\nkt\nTrue airspeed\n\n\nalt\nfloat/array\nft\nAltitude. Default: 0\n\n\ndT\nfloat/array\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: CO emission (g/s)\n\n\n17.0.8 hc(ffac, tas, alt=0, dT=0)\nCompute HC emission.\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nffac\nfloat/array\nkg/s\nTotal fuel flow for all engines\n\n\ntas\nfloat/array\nkt\nTrue airspeed\n\n\nalt\nfloat/array\nft\nAltitude. Default: 0\n\n\ndT\nfloat/array\nK\nISA temperature deviation. Default: 0\n\n\n\nReturns: HC emission (g/s)\nExample:\n\nfrom openap import FuelFlow, Emission\n\n# Create fuel flow and emission models\nfuelflow = FuelFlow(\"A320\")\nemission = Emission(\"A320\")\n\n# Flight conditions at cruise\nmass = 60000  # kg\ntas = 250     # kt\nalt = 30000   # ft\n\n# Compute fuel flow\nff = fuelflow.enroute(mass, tas, alt)\nprint(f\"Fuel flow: {ff:.4f} kg/s\")\n\n# Compute CO2 emission (fuel-proportional)\nco2 = emission.co2(ff)\nprint(f\"CO2 emission: {co2:.2f} g/s\")\n\n# Compute NOx emission (altitude-corrected)\nnox = emission.nox(ff, tas, alt)\nprint(f\"NOx emission: {nox:.4f} g/s\")\n\nFuel flow: 0.7848 kg/s\nCO2 emission: 2479.99 g/s\nNOx emission: 10.3774 g/s",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>üí® Emission</span>"
    ]
  },
  {
    "objectID": "api/wrap.html",
    "href": "api/wrap.html",
    "title": "18¬† üåØ WRAP",
    "section": "",
    "text": "Kinematic performance model providing pre-computed statistical flight parameters for different flight phases.\n\n18.0.1 WRAP(ac)\nCreate a WRAP model for a specific aircraft type.\nParameters:\n\nac (str): ICAO aircraft type code (e.g., ‚ÄúA320‚Äù)\n\nTakeoff\n\n\n\nMethod\nDescription\n\n\n\n\ntakeoff_speed()\nTakeoff speed\n\n\ntakeoff_distance()\nTakeoff distance\n\n\ntakeoff_acceleration()\nTakeoff acceleration\n\n\n\nInitial climb\n\n\n\nMethod\nDescription\n\n\n\n\ninitclimb_vcas()\nInitial climb CAS\n\n\ninitclimb_vs()\nInitial climb vertical rate\n\n\n\nClimb\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nclimb_range()\nClimb range distance\n\n\nclimb_const_vcas()\nSpeed for constant CAS climb\n\n\nclimb_const_mach()\nSpeed during constant Mach climb\n\n\nclimb_cross_alt_concas()\nCrossover altitude when constant CAS starts\n\n\nclimb_cross_alt_conmach()\nCrossover altitude from CAS to Mach\n\n\nclimb_vs_pre_concas()\nVertical rate before constant CAS\n\n\nclimb_vs_concas()\nVertical rate during constant CAS\n\n\nclimb_vs_conmach()\nVertical rate during constant Mach\n\n\n\nCruise\n\n\n\nMethod\nDescription\n\n\n\n\ncruise_range()\nCruise range\n\n\ncruise_alt()\nAverage cruise altitude\n\n\ncruise_init_alt()\nInitial cruise altitude\n\n\ncruise_max_alt()\nMaximum cruise altitude\n\n\ncruise_mach()\nAverage cruise Mach\n\n\ncruise_max_mach()\nMaximum cruise Mach\n\n\ncruise_mean_vcas()\nMean cruise CAS\n\n\n\nDescent\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ndescent_range()\nDescent range\n\n\ndescent_const_mach()\nSpeed during constant Mach descent\n\n\ndescent_const_vcas()\nSpeed during constant CAS descent\n\n\ndescent_cross_alt_conmach()\nCrossover altitude from Mach to CAS\n\n\ndescent_cross_alt_concas()\nCrossover altitude when constant CAS ends\n\n\ndescent_vs_conmach()\nVertical rate during constant Mach descent\n\n\ndescent_vs_concas()\nVertical rate during constant CAS descent\n\n\ndescent_vs_post_concas()\nVertical rate after constant CAS\n\n\n\nApproach and landing\n\n\n\nMethod\nDescription\n\n\n\n\nfinalapp_vcas()\nFinal approach CAS\n\n\nfinalapp_vs()\nFinal approach vertical speed\n\n\nlanding_speed()\nLanding speed\n\n\nlanding_distance()\nLanding (braking) distance\n\n\nlanding_acceleration()\nLanding deceleration\n\n\n\nReturn format\nAll methods return a dictionary with three keys:\n{\"default\": ..., \"minimum\": ..., \"maximum\": ...}\nThe values represent typical default values and the statistical minimum and maximum observed in real flight data.\nExample:\n\nimport openap\n\n# Create WRAP model for A320\nwrap = openap.WRAP(\"A320\")\n\n# Get takeoff speed statistics\nprint(\"Takeoff speed:\", wrap.takeoff_speed())\n\n# Get cruise parameters\nprint(\"Cruise Mach:\", wrap.cruise_mach())\nprint(\"Cruise altitude:\", wrap.cruise_alt())\n\nTakeoff speed: {'default': 85.3, 'minimum': 74.5, 'maximum': 96.0, 'statmodel': 'norm', 'statmodel_params': [85.29, 7.47]}\nCruise Mach: {'default': 0.78, 'minimum': 0.75, 'maximum': 0.8, 'statmodel': 'beta', 'statmodel_params': [17.82, 5.05, 0.62, 0.2]}\nCruise altitude: {'default': 10.92, 'minimum': 10.0, 'maximum': 11.84, 'statmodel': 'norm', 'statmodel_params': [10.92, 0.56]}",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>üåØ WRAP</span>"
    ]
  },
  {
    "objectID": "api/flightphase.html",
    "href": "api/flightphase.html",
    "title": "19¬† üè∑Ô∏è FlightPhase",
    "section": "",
    "text": "Fuzzy logic-based flight phase identification.\n\n19.0.1 FlightPhase()\nInitialize a FlightPhase object.\nParameters:\nNone\nReturns:\nFlightPhase object\n\n\n19.0.2 set_trajectory(ts, alt, spd, roc)\nSet trajectory data for phase identification.\nParameters:\n\n\n\nParameter\nType\nDescription\n\n\n\n\nts\narray-like\nTimestamps (seconds)\n\n\nalt\narray-like\nAltitude (ft)\n\n\nspd\narray-like\nTrue airspeed (kt)\n\n\nroc\narray-like\nRate of climb (ft/min). Negative for descent.\n\n\n\nReturns:\nNone\n\n\n19.0.3 phaselabel(twindow=60)\nDetermine flight phase labels using fuzzy logic.\nParameters:\n\n\n\nParameter\nType\nDescription\n\n\n\n\ntwindow\nint\nTime window in seconds. Default 60.\n\n\n\nReturns:\nlist of labels:\n\nGND ‚Äî Ground\nCL ‚Äî Climb\nDE ‚Äî Descent\nCR ‚Äî Cruise\nLVL ‚Äî Level flight\n\n\n\n19.0.4 flight_phase_indices()\nGet indices where different flight phases start.\nParameters:\nNone\nReturns:\ndict with keys:\n\nTO ‚Äî Takeoff\nIC ‚Äî Initial climb\nCL ‚Äî Climb\nCR ‚Äî Cruise\nDE ‚Äî Descent\nFA ‚Äî Final approach\nLD ‚Äî Landing\n\nExample:\nThe following example demonstrates using FlightGenerator to create a trajectory, then FlightPhase to identify phases:\n\nfrom openap import FlightGenerator, FlightPhase\n\ngen = FlightGenerator(\"A320\")\nflight = gen.complete(random=False)\n\nfp = FlightPhase()\nfp.set_trajectory(\n    flight.t.values,\n    flight.altitude.values,\n    flight.groundspeed.values,\n    flight.vertical_rate.values,\n)\nlabels = fp.phaselabel()\nset(labels)\n\n{'CL', 'CR', 'DE', 'NA'}",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>üè∑Ô∏è FlightPhase</span>"
    ]
  },
  {
    "objectID": "api/flightgenerator.html",
    "href": "api/flightgenerator.html",
    "title": "20¬† ‚úàÔ∏è FlightGenerator",
    "section": "",
    "text": "Generate synthetic flight trajectories using the WRAP kinematic model.\n\n20.0.1 FlightGenerator(ac, random_seed=42, use_synonym=False)\nInitialize the trajectory generator for a specific aircraft type.\n\n\n\n\n\n\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\nac\nstr\n-\nICAO aircraft type (e.g.¬†‚ÄúA320‚Äù)\n\n\nrandom_seed\nint\n-\nRandom seed for noise generation. Default 42.\n\n\nuse_synonym\nbool\n-\nUse synonym if aircraft not found. Default False.\n\n\n\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\n\n\n\n20.0.2 enable_noise()\nEnable noise in generated trajectories based on ADS-B Version 1&2, NACv=3 and NACp=10.\nParameters: None\nReturns: None\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\ngen.enable_noise()\n\n\n\n20.0.3 climb(**kwargs)\nGenerate climb trajectory from takeoff to cruise altitude.\nKeyword Arguments:\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ndt\nint\ns\nTime step. Default 1.\n\n\ncas_const_cl\nfloat\nkt\nConstant CAS for climb.\n\n\nmach_const_cl\nfloat\n-\nConstant Mach for climb.\n\n\nalt_cr\nfloat\nft\nTarget cruise altitude.\n\n\nrandom\nbool\n-\nUse random parameters. Default False.\n\n\n\nReturns: pd.DataFrame with columns: t, h, s, v, vs, seg, altitude, vertical_rate, groundspeed, etc.\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\nclimb_traj = gen.climb(dt=10, cas_const_cl=280, mach_const_cl=0.78, alt_cr=35000)\nclimb_traj.head()\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\nseg\naltitude\nvertical_rate\ngroundspeed\ncas_const_cl\nmach_const_cl\nh_const_cas_start\nh_const_mach_start\nalt_cr\n\n\n\n\n0\n0\n0.0\n0.0\n0.0\n0.0\nNone\n0\n0\n0\n280\n0.78\n3700.0\n9895.150102\n35000\n\n\n1\n10\n0.0\n0.0\n19.3\n0.0\nTO\n0\n0\n37\n280\n0.78\n3700.0\n9895.150102\n35000\n\n\n2\n20\n0.0\n193.0\n38.6\n0.0\nTO\n0\n0\n75\n280\n0.78\n3700.0\n9895.150102\n35000\n\n\n3\n30\n0.0\n579.0\n57.9\n0.0\nTO\n0\n0\n112\n280\n0.78\n3700.0\n9895.150102\n35000\n\n\n4\n40\n0.0\n1158.0\n77.2\n0.0\nTO\n0\n0\n150\n280\n0.78\n3700.0\n9895.150102\n35000\n\n\n\n\n\n\n\n\n\n20.0.4 descent(**kwargs)\nGenerate descent trajectory from cruise altitude to landing.\nKeyword Arguments:\n\n\n\n\n\n\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ndt\nint\ns\nTime step. Default 1.\n\n\ncas_const_de\nfloat\nkt\nConstant CAS for descent.\n\n\nmach_const_de\nfloat\n-\nConstant Mach for descent.\n\n\nalt_cr\nfloat\nft\nTop of descent altitude.\n\n\nrandom\nbool\n-\nUse random parameters. Default False.\n\n\nwithcr\nbool\n-\nInclude short cruise segment (60s). Default True.\n\n\n\nReturns: pd.DataFrame with columns: t, h, s, v, vs, seg, altitude, vertical_rate, groundspeed, etc.\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\ndescent_traj = gen.descent(dt=10, cas_const_de=280, mach_const_de=0.78, alt_cr=35000)\ndescent_traj.head()\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\nseg\naltitude\nvertical_rate\ngroundspeed\ncas_const_de\nvcas_const_de\nmach_const_de\nva_app\nvs_constmach\nvs_constcas\nh_const_mach_end\nh_const_cas_end\nalt_cr\n\n\n\n\n0\n0\n10668.0\n0.000000\n231.297621\n0.0\nNone\n35000\n0\n449\n280\n144.04432\n0.78\n72.0\n-5.76\n-10.03\n9895.150102\n5700.0\n35000\n\n\n1\n10\n10668.0\n2312.976208\n231.297621\n0.0\nCR\n35000\n0\n449\n280\n144.04432\n0.78\n72.0\n-5.76\n-10.03\n9895.150102\n5700.0\n35000\n\n\n2\n20\n10668.0\n4625.952416\n231.297621\n0.0\nCR\n35000\n0\n449\n280\n144.04432\n0.78\n72.0\n-5.76\n-10.03\n9895.150102\n5700.0\n35000\n\n\n3\n30\n10668.0\n6938.928623\n231.297621\n0.0\nCR\n35000\n0\n449\n280\n144.04432\n0.78\n72.0\n-5.76\n-10.03\n9895.150102\n5700.0\n35000\n\n\n4\n40\n10668.0\n9251.904831\n231.297621\n0.0\nCR\n35000\n0\n449\n280\n144.04432\n0.78\n72.0\n-5.76\n-10.03\n9895.150102\n5700.0\n35000\n\n\n\n\n\n\n\n\n\n20.0.5 cruise(**kwargs)\nGenerate cruise trajectory at constant altitude and Mach number.\nKeyword Arguments:\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ndt\nint\ns\nTime step. Default 1.\n\n\nrange_cr\nfloat\nkm\nCruise range.\n\n\nalt_cr\nfloat\nft\nCruise altitude.\n\n\nmach_cr\nfloat\n-\nCruise Mach number.\n\n\nrandom\nbool\n-\nUse random parameters. Default False.\n\n\n\nReturns: pd.DataFrame with columns: t, h, s, v, vs, altitude, vertical_rate, groundspeed, etc.\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\ncruise_traj = gen.cruise(dt=60, range_cr=2000, alt_cr=35000, mach_cr=0.78)\ncruise_traj.head()\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\naltitude\nvertical_rate\ngroundspeed\nalt_cr\nmach_cr\n\n\n\n\n0\n0\n10668.0\n0\n231.297621\n0\n35000\n0\n449\n35000\n0.78\n\n\n\n\n\n\n\n\n\n20.0.6 complete(**kwargs)\nGenerate a complete flight trajectory (climb + cruise + descent).\nKeyword Arguments:\nCombines all keyword arguments from climb(), cruise(), and descent() methods:\n\n\n\nParameter\nType\nUnit\nDescription\n\n\n\n\ndt\nint\ns\nTime step. Default 1.\n\n\ncas_const_cl\nfloat\nkt\nConstant CAS for climb.\n\n\nmach_const_cl\nfloat\n-\nConstant Mach for climb.\n\n\ncas_const_de\nfloat\nkt\nConstant CAS for descent.\n\n\nmach_const_de\nfloat\n-\nConstant Mach for descent.\n\n\nrange_cr\nfloat\nkm\nCruise range.\n\n\nalt_cr\nfloat\nft\nCruise altitude.\n\n\nmach_cr\nfloat\n-\nCruise Mach number.\n\n\nrandom\nbool\n-\nUse random parameters. Default False.\n\n\n\nReturns: pd.DataFrame with columns: t, h, s, v, vs, altitude, vertical_rate, groundspeed.\nExample:\n\nfrom openap import FlightGenerator\n\ngen = FlightGenerator(\"A320\")\nflight = gen.complete(random=False)\nflight.head()\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\naltitude\nvertical_rate\ngroundspeed\n\n\n\n\n0\n0\n0.0\n0.00\n0.00\n0.0\n0\n0\n0\n\n\n1\n1\n0.0\n0.00\n1.93\n0.0\n0\n0\n3\n\n\n2\n2\n0.0\n1.93\n3.86\n0.0\n0\n0\n7\n\n\n3\n3\n0.0\n5.79\n5.79\n0.0\n0\n0\n11\n\n\n4\n4\n0.0\n11.58\n7.72\n0.0\n0\n0\n15\n\n\n\n\n\n\n\nComplete Workflow Example\nGenerate a complete flight with random parameters and visualize:\n\nfrom openap import FlightGenerator\n\n# Create generator for A320\ngen = FlightGenerator(\"A320\", random_seed=42)\n\n# Enable noise to simulate realistic ADS-B data\ngen.enable_noise()\n\n# Generate complete flight with random parameters\nflight = gen.complete(dt=10, random=True)\n\n# Display summary\nprint(f\"Flight duration: {flight.t.iloc[-1]:.0f} seconds\")\nprint(f\"Total distance: {flight.s.iloc[-1]/1000:.0f} km\")\nprint(f\"Max altitude: {flight.altitude.max():.0f} ft\")\n\nFlight duration: 18040 seconds\nTotal distance: 4003 km\nMax altitude: 35578 ft",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>‚úàÔ∏è FlightGenerator</span>"
    ]
  },
  {
    "objectID": "api/aero.html",
    "href": "api/aero.html",
    "title": "21¬† üå°Ô∏è aero",
    "section": "",
    "text": "Aeronautical calculations: atmosphere model (ISA), airspeed conversions, and physical constants.\n\n\n\n\n\n\nNote\n\n\n\nAll inputs and outputs are in SI units (meters, m/s, Pa, K) ‚Äî unlike performance classes which use kt/ft.\n\n\nConstants\nPhysical and conversion constants are available as module-level variables:\n\n\n\nConstant\nValue\nDescription\n\n\n\n\nkts\n0.514444\nknot to m/s\n\n\nft\n0.3048\nfeet to m\n\n\nfpm\n0.00508\nft/min to m/s\n\n\ninch\n0.0254\ninch to m\n\n\nsqft\n0.09290304\nsquare feet to m^2\n\n\nnm\n1852.0\nnautical mile to m\n\n\nlbs\n0.453592\npound to kg\n\n\ng0\n9.80665\ngravity (m/s^2)\n\n\nR\n287.05287\ngas constant (m2/(s2*K))\n\n\np0\n101325.0\nsea level pressure (Pa)\n\n\nrho0\n1.225\nsea level density (kg/m^3)\n\n\nT0\n288.15\nsea level temperature (K)\n\n\ngamma\n1.40\nspecific heat ratio\n\n\nbeta\n-0.0065\nISA temp gradient (K/m)\n\n\nr_earth\n6371000.0\nearth radius (m)\n\n\na0\n340.294\nsea level speed of sound (m/s)\n\n\n\nAtmosphere functions\n\n21.0.1 atmos(h, dT=0)\nCompute pressure, density, and temperature at altitude.\n\nh: Altitude (m)\ndT: ISA temperature shift (K). Default 0.\nReturns: tuple of (pressure [Pa], density [kg/m^3], temperature [K])\n\n\n\n21.0.2 temperature(h, dT=0), pressure(h, dT=0), density(h, dT=0), vsound(h, dT=0)\nIndividual atmosphere properties.\n\nSame parameters as atmos\nReturns the respective property\n\n\n\n21.0.3 h_isa(p, dT=0)\nCompute ISA altitude from pressure.\n\np: Pressure (Pa)\nReturns: Altitude (m)\n\nAirspeed conversions\n\n\n21.0.4 cas2tas(v_cas, h, dT=0), tas2cas(v_tas, h, dT=0)\n\n\n21.0.5 mach2tas(mach, h, dT=0), tas2mach(v_tas, h, dT=0)\n\n\n21.0.6 eas2tas(v_eas, h, dT=0), tas2eas(v_tas, h, dT=0)\n\n\n21.0.7 mach2cas(mach, h, dT=0), cas2mach(v_cas, h, dT=0)\nAll speeds in m/s, altitude in m, dT in K. Mach is dimensionless.\n\n\n21.0.8 crossover_alt(v_cas, mach, dT=0)\nCompute crossover altitude for constant CAS and Mach.\n\nv_cas: CAS (m/s)\nmach: Mach number\nReturns: altitude (m)\n\nUsage note\nFunctions are available both as module-level (openap.aero.cas2tas(...)) and via class (openap.Aero(backend=...).cas2tas(...)). The class form supports CasADi/JAX backends.\nExample:\n\nfrom openap import aero\n\n# Atmosphere at 10000 m\np, rho, T = aero.atmos(10000)\nprint(f\"Pressure: {p:.0f} Pa, Density: {rho:.4f} kg/m3, Temp: {T:.1f} K\")\n\n# Convert 250 kt CAS to TAS at 10000 m\nv_cas = 250 * aero.kts  # convert knots to m/s\nv_tas = aero.cas2tas(v_cas, 10000)\nprint(f\"TAS: {v_tas:.1f} m/s ({v_tas/aero.kts:.1f} kt)\")\n\nPressure: 26430 Pa, Density: 0.4126 kg/m3, Temp: 223.1 K\nTAS: 212.0 m/s (412.2 kt)",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>üå°Ô∏è aero</span>"
    ]
  },
  {
    "objectID": "api/geo.html",
    "href": "api/geo.html",
    "title": "22¬† üåç geo",
    "section": "",
    "text": "Geographic and navigation calculations.\n\n\n\n\n\n\nNote\n\n\n\nAll inputs and outputs use degrees for latitude/longitude and meters for distance/altitude.\n\n\n\n22.0.1 distance(lat1, lon1, lat2, lon2, h=0)\nCalculate the great-circle distance between two points using the Haversine formula.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nlat1\nfloat\nStart latitude (degrees)\n\n\nlon1\nfloat\nStart longitude (degrees)\n\n\nlat2\nfloat\nEnd latitude (degrees)\n\n\nlon2\nfloat\nEnd longitude (degrees)\n\n\nh\nfloat\nAltitude (meters). Default: 0\n\n\n\nReturns: Distance (meters)\n\nfrom openap import geo\n\n# Distance from Amsterdam to New York\nd = geo.distance(52.31, 4.76, 40.64, -73.78)\nprint(f\"Distance: {d/1000:.0f} km\")\n\nDistance: 5847 km\n\n\n\n\n\n22.0.2 bearing(lat1, lon1, lat2, lon2)\nCalculate the initial bearing between two points.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nlat1\nfloat\nStart latitude (degrees)\n\n\nlon1\nfloat\nStart longitude (degrees)\n\n\nlat2\nfloat\nEnd latitude (degrees)\n\n\nlon2\nfloat\nEnd longitude (degrees)\n\n\n\nReturns: Bearing (degrees), range 0-360\n\nfrom openap import geo\n\n# Bearing from Amsterdam to New York\nbrg = geo.bearing(52.31, 4.76, 40.64, -73.78)\nprint(f\"Bearing: {brg:.1f} degrees\")\n\nBearing: 290.6 degrees\n\n\n\n\n\n22.0.3 latlon(lat1, lon1, d, brg, h=0)\nCompute the destination point given a start point, distance, and bearing.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nlat1\nfloat\nStart latitude (degrees)\n\n\nlon1\nfloat\nStart longitude (degrees)\n\n\nd\nfloat\nDistance (meters)\n\n\nbrg\nfloat\nBearing (degrees)\n\n\nh\nfloat\nAltitude (meters). Default: 0\n\n\n\nReturns: Tuple (latitude, longitude) in degrees\n\nfrom openap import geo\n\n# Destination point 1000 km from Amsterdam at bearing 270¬∞ (west)\nlat, lon = geo.latlon(52.31, 4.76, 1000000, 270)\nprint(f\"Destination: {lat:.2f}¬∞, {lon:.2f}¬∞\")\n\nDestination: 51.41¬∞, -9.75¬∞\n\n\n\n\n\n22.0.4 solar_zenith_angle(lat, lon, timestamp)\nCalculate the solar zenith angle at a given location and time.\n\n\n\nParameter\nType\nDescription\n\n\n\n\nlat\nfloat\nLatitude (degrees, -90 to 90)\n\n\nlon\nfloat\nLongitude (degrees, -180 to 180)\n\n\ntimestamp\ndatetime\nUTC datetime or pandas Timestamp (or array)\n\n\n\nReturns: Solar zenith angle (degrees). 0 = sun overhead, 90 = sun at horizon, &gt;90 = nighttime\n\nfrom openap import geo\nfrom datetime import datetime\n\n# Solar zenith angle at Amsterdam on a specific date/time\ntimestamp = datetime(2024, 6, 21, 12, 0, 0)  # Summer solstice, noon UTC\nangle = geo.solar_zenith_angle(52.31, 4.76, timestamp)\nprint(f\"Solar zenith angle: {angle:.1f}¬∞\")\n\nSolar zenith angle: 29.0¬∞\n\n\n\nUsage\nThe geo module can be used in two ways:\n\nModule-level functions (recommended for most use cases):\nfrom openap import geo\nd = geo.distance(lat1, lon1, lat2, lon2)\nClass interface (for advanced users who need specific backends):\nfrom openap import Geo\ng = Geo(backend=\"numpy\")  # or \"cupy\" for GPU\nd = g.distance(lat1, lon1, lat2, lon2)",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>üåç geo</span>"
    ]
  },
  {
    "objectID": "api/contrail.html",
    "href": "api/contrail.html",
    "title": "23¬† ‚òÅÔ∏è contrail",
    "section": "",
    "text": "Contrail formation prediction and radiative forcing calculations.\nModule constants\n\n\n\n\n\n\n\n\nConstant\nValue\nDescription\n\n\n\n\nei_water\n1.2232\nWater vapor emission index (kg/kg fuel)\n\n\nspec_combustion_heat\n43e6\nSpecific combustion heat (J/kg)\n\n\nspec_air_heat_capacity\n1004\nSpecific heat capacity of air (J/(kg*K))\n\n\nDEFAULT_PROPULSION_EFFICIENCY\n0.4\nDefault propulsion efficiency\n\n\n\nSaturation pressure\n\n23.0.1 saturation_pressure_over_water(temperature)\nCalculate saturation vapor pressure over liquid water using the Murphy & Koop (2005) formulation, valid for temperatures from 123 K to 332 K.\nParameters:\n\ntemperature: Air temperature (K). Can be scalar or array.\n\nReturns: Saturation vapor pressure over water (Pa).\nReference: Murphy, D. M. and Koop, T. (2005). Review of the vapour pressures of ice and supercooled water for atmospheric applications. Q. J. R. Meteorol. Soc., 131, 1539-1565.\n\n\n23.0.2 saturation_pressure_over_ice(temperature)\nCalculate saturation vapor pressure over ice using the Murphy & Koop (2005) formulation, valid for temperatures from 110 K to 273 K.\nParameters:\n\ntemperature: Air temperature (K). Can be scalar or array.\n\nReturns: Saturation vapor pressure over ice (Pa).\nReference: Murphy, D. M. and Koop, T. (2005). Review of the vapour pressures of ice and supercooled water for atmospheric applications. Q. J. R. Meteorol. Soc., 131, 1539-1565.\nHumidity\n\n\n23.0.3 relative_humidity(specific_humidity, pressure, temperature, to=\"ice\")\nCalculate relative humidity from specific humidity.\nParameters:\n\nspecific_humidity: Specific humidity (kg/kg)\npressure: Air pressure (Pa)\ntemperature: Air temperature (K)\nto: Reference phase, either ‚Äúice‚Äù or ‚Äúwater‚Äù. Default: ‚Äúice‚Äù\n\nReturns: Relative humidity (dimensionless, where 1.0 = 100%)\n\n\n23.0.4 rhw2rhi(relative_humidity_water, temperature)\nConvert relative humidity with respect to water to relative humidity with respect to ice.\nParameters:\n\nrelative_humidity_water: Relative humidity w.r.t. water (dimensionless)\ntemperature: Air temperature (K)\n\nReturns: Relative humidity w.r.t. ice (dimensionless)\nSchmidt-Appleman criterion\n\n\n23.0.5 critical_temperature_water(pressure, propulsion_efficiency=0.4)\nCalculate critical temperature below which contrails can form (water saturation), based on the Schmidt-Appleman criterion.\nParameters:\n\npressure: Air pressure (Pa). Can be scalar or array.\npropulsion_efficiency: Overall propulsion efficiency (0-1). Default: 0.4. Higher efficiency means higher critical temperature (contrails form more easily).\n\nReturns: Critical temperature (K). Contrails can form when the ambient temperature is below this value.\nReference: Schumann, U. (1996). On conditions for contrail formation from aircraft exhausts. Meteorol. Z., 5, 4-23.\n\n\n23.0.6 critical_temperature_water_and_ice(pressure, propulsion_efficiency=0.4)\nCalculate both water and ice critical temperatures for contrail formation and persistence.\nParameters:\n\npressure: Air pressure (Pa). Scalar only (uses root finding).\npropulsion_efficiency: Overall propulsion efficiency (0-1). Default: 0.4.\n\nReturns: Tuple of (crit_temp_water, crit_temp_ice) in Kelvin. - crit_temp_water: Temperature below which contrails can form - crit_temp_ice: Temperature below which contrails can persist (if ice supersaturation exists)\nReference: Schumann, U. (1996). On conditions for contrail formation from aircraft exhausts. Meteorol. Z., 5, 4-23.\nRadiative forcing\n\n\n23.0.7 rf_shortwave(zenith, tau, tau_c)\nCalculate shortwave (solar) radiative forcing from contrails. Shortwave forcing is typically negative (cooling effect) during daytime.\nParameters:\n\nzenith: Solar zenith angle (degrees). 0 = sun overhead, 90 = horizon, &gt;90 = nighttime\ntau: Contrail optical depth (dimensionless)\ntau_c: Background cirrus optical depth (dimensionless)\n\nReturns: Shortwave radiative forcing (W/m¬≤). Negative values indicate cooling (reflection of incoming solar radiation). Returns 0 for nighttime (zenith &gt; 90).\n\n\n23.0.8 rf_longwave(olr, temperature)\nCalculate longwave (thermal infrared) radiative forcing from contrails. Longwave forcing is typically positive (warming effect).\nParameters:\n\nolr: Outgoing longwave radiation at top of atmosphere (W/m¬≤). Can be obtained from satellite data or reanalysis.\ntemperature: Contrail/ambient temperature (K)\n\nReturns: Longwave radiative forcing (W/m¬≤). Positive values indicate warming (trapping of outgoing thermal radiation).\n\n\n23.0.9 rf_net(zenith, tau, tau_c, olr, temperature)\nCalculate net radiative forcing from contrails by combining shortwave (cooling) and longwave (warming) forcing.\nParameters:\n\nzenith: Solar zenith angle (degrees)\ntau: Contrail optical depth (dimensionless)\ntau_c: Background cirrus optical depth (dimensionless)\nolr: Outgoing longwave radiation (W/m¬≤)\ntemperature: Contrail/ambient temperature (K)\n\nReturns: Net radiative forcing (W/m¬≤). Positive = warming, negative = cooling.\nUtilities\n\n\n23.0.10 contrail_optical_properties(age_hours)\nGet contrail optical properties based on age. Models contrail evolution from young thin trails to aged artificial cirrus.\nOptical property evolution (cumulative values):\n\n\n\nAge (hours)\ntau\nwidth (m)\ntau_c\n\n\n\n\n0-1\n0.40\n500\n0.360\n\n\n1-2\n0.60\n1500\n0.540\n\n\n2-4\n0.68\n3500\n0.612\n\n\n4-6\n0.70\n6500\n0.630\n\n\n6+\n0.71\n10500\n0.639\n\n\n\nParameters:\n\nage_hours: Contrail age in hours. Can be scalar or array.\n\nReturns: Tuple of (tau, width_m, tau_c): - tau: Contrail optical depth (dimensionless) - width_m: Contrail width (meters) - tau_c: Cirrus optical depth (dimensionless)\n\n\n23.0.11 load_olr(filepath, lat, lon, time)\nLoad OLR data from a netCDF file and interpolate to specified locations and times. Requires xarray (optional dependency).\nParameters:\n\nfilepath: Path to netCDF file containing OLR data. Expected variables: ‚Äòolr‚Äô or ‚ÄòOLR‚Äô, with dimensions (time, lat/latitude, lon/longitude)\nlat: Latitude(s) to interpolate (degrees)\nlon: Longitude(s) to interpolate (degrees)\ntime: Timestamp(s) for temporal interpolation. Can be datetime, pandas Timestamp, or array of timestamps\n\nReturns: OLR values (W/m¬≤) at the specified locations and times.\nRaises: ImportError if xarray is not installed.\nExample:\nComputing the critical temperature at typical cruise pressure and checking if contrail formation is possible:\n\nfrom openap import contrail\n\n# Typical cruise pressure (~FL350)\np = 23842  # Pa\n\n# Critical temperature for contrail formation\nT_crit = contrail.critical_temperature_water(p)\nprint(f\"Critical temperature: {T_crit:.1f} K ({T_crit - 273.15:.1f} ¬∞C)\")\n\n# Check contrail formation at different ambient temperatures\nT_ambient = 220  # K (-53¬∞C)\nif T_ambient &lt; T_crit:\n    print(f\"Contrails can form at {T_ambient:.1f} K\")\nelse:\n    print(f\"Contrails cannot form at {T_ambient:.1f} K\")\n\nCritical temperature: 232.3 K (-40.8 ¬∞C)\nContrails can form at 220.0 K",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>‚òÅÔ∏è contrail</span>"
    ]
  },
  {
    "objectID": "api/backends.html",
    "href": "api/backends.html",
    "title": "24¬† üîß Backends",
    "section": "",
    "text": "OpenAP supports three interchangeable computation backends that enable different computational paradigms while maintaining the same API. All performance classes (Thrust, Drag, FuelFlow, Emission) and utility classes (Aero, Geo) accept a backend parameter, allowing you to choose the computational framework that best suits your needs.\nThe backend system abstracts mathematical operations through a common protocol, enabling seamless switching between NumPy‚Äôs numerical computation, CasADi‚Äôs symbolic computation for optimization, and JAX‚Äôs automatic differentiation with GPU acceleration.\nNumpyBackend (default)\nThe default backend uses pure NumPy for numerical computation. It requires no additional dependencies beyond OpenAP‚Äôs core requirements and is suitable for standard aircraft performance calculations, trajectory analysis, and batch processing.\nWhen no backend is explicitly specified, NumpyBackend is automatically used:\n\nfrom openap import FuelFlow\n\nff = FuelFlow(\"A320\")  # Uses NumpyBackend by default\nfuel_flow = ff.enroute(mass=60000, tas=250, alt=30000)\nprint(f\"Fuel flow: {fuel_flow:.2f} kg/s\")\n\nFuel flow: 0.78 kg/s\n\n\nCasadiBackend\nThe CasADi backend enables symbolic computation, automatic differentiation, and seamless integration with nonlinear programming (NLP) solvers such as IPOPT. This backend is essential for trajectory optimization and is used by the openap-top package.\nInstallation:\npip install openap[casadi]\nUsage:\nfrom openap import FuelFlow\nfrom openap.backends import CasadiBackend\n\nff = FuelFlow(\"A320\", backend=CasadiBackend())\nfuel_flow = ff.enroute(mass=60000, tas=250, alt=30000)\nThe symbolic expressions returned can be used directly in CasADi optimization problems, enabling gradient-based trajectory optimization with automatic differentiation.\nJaxBackend\nThe JAX backend provides automatic differentiation, just-in-time (JIT) compilation, and GPU/TPU acceleration support. It‚Äôs ideal for machine learning applications, large-scale batch processing, and research requiring efficient gradient computation.\nInstallation:\npip install openap[jax]\nUsage:\nfrom openap import FuelFlow\nfrom openap.backends import JaxBackend\n\nff = FuelFlow(\"A320\", backend=JaxBackend())\nfuel_flow = ff.enroute(mass=60000, tas=250, alt=30000)\nJAX‚Äôs JIT compilation can significantly accelerate repeated computations, while its automatic differentiation enables efficient gradient-based analysis.\nMathBackend Protocol\nAll backends implement the MathBackend protocol, which defines a common interface for mathematical operations. This ensures consistent behavior across different computational frameworks.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nsqrt(x)\nSquare root\n\n\nexp(x)\nExponential function\n\n\nlog(x)\nNatural logarithm\n\n\npower(x, y)\nPower operation x^y\n\n\nsin(x), cos(x), tan(x)\nTrigonometric functions\n\n\narcsin(x), arccos(x), arctan(x)\nInverse trigonometric functions\n\n\narctan2(y, x)\nTwo-argument arctangent\n\n\nabs(x)\nAbsolute value\n\n\nwhere(cond, x, y)\nConditional selection (if cond then x else y)\n\n\nmaximum(x, y), minimum(x, y)\nElement-wise maximum/minimum\n\n\nclip(x, min, max)\nClip values to range [min, max]\n\n\ninterp(x, xp, fp)\nLinear interpolation\n\n\nlinspace(start, stop, num)\nGenerate evenly spaced values\n\n\nfmod(x, y)\nFloating-point modulo operation\n\n\npi\nMathematical constant œÄ (property)\n\n\n\nConvenience Modules\nFor easier workflow, OpenAP provides convenience modules that automatically configure the backend:\nCasADi convenience module:\nimport openap.casadi as oc\n\nff = oc.FuelFlow(\"A320\")  # Automatically uses CasadiBackend\ndrag = oc.Drag(\"A320\")\nthrust = oc.Thrust(\"A320\")\nJAX convenience module:\nimport openap.jax as oj\n\nff = oj.FuelFlow(\"A320\")  # Automatically uses JaxBackend\ndrag = oj.Drag(\"A320\")\nthrust = oj.Thrust(\"A320\")\nThese convenience modules import all main OpenAP classes pre-configured with the appropriate backend, simplifying code when working exclusively with one computational framework.",
    "crumbs": [
      "üìñ API Reference",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>üîß Backends</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bartel, M., & Young, T. M. (2008). Simplified thrust and fuel\nconsumption models for modern two-shaft turbofan engines. Journal of\nAircraft, 45(4), 1450‚Äì1456.\n\n\nLee, D. S., Fahey, D. W., Skowron, A., Allen, M. R., Burkhardt, U.,\nChen, Q., Doherty, S. J., Freeman, S., Forster, P. M., Fuglestvedt, J.,\net al. (2021). The contribution of global aviation to anthropogenic\nclimate forcing for 2000 to 2018. Atmospheric Environment,\n244, 117834.\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode\ns and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air\ntransport and sustainability research. Aerospace,\n9(7), 383. https://doi.org/10.3390/aerospace9070383\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction\nand phase identification for large automatic dependent\nsurveillance‚Äìbroadcast datasets. Journal of Aerospace Information\nSystems, 14(10), 566‚Äì571. https://doi.org/10.2514/1.I010520\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source\nkinematic aircraft performance model. Transportation Research Part\nC: Emerging Technologies, 98, 118‚Äì138. https://doi.org/10.1016/j.trc.2018.11.009\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft\ndrag polar using open flight surveillance data and a stochastic total\nenergy model. Transportation Research Part C: Emerging\nTechnologies, 114, 391‚Äì404. https://doi.org/10.1016/j.trc.2020.01.026\n\n\nYin, F., Grewe, V., Castino, F., Rao, P., Matthes, S., Dahlmann, K.,\nDietm√ºller, S., Fr√∂mming, C., Yamashita, H., Peter, P., et al. (2023).\nPredicting the climate impact of aviation for en-route emissions: The\nalgorithmic climate change function submodel ACCF 1.0 of EMAC 2.53.\nGeoscientific Model Development, 16(11), 3313‚Äì3334.",
    "crumbs": [
      "References"
    ]
  }
]