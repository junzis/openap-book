[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The OpenAP Handbook",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#synopsis",
    "href": "index.html#synopsis",
    "title": "The OpenAP Handbook",
    "section": "Synopsis",
    "text": "Synopsis\nWelcome to the OpenAP handbook, a comprehensive guide to unlocking the full potential of the OpenAP aircraft performance library. This book is designed to help you navigate the vast capabilities of OpenAP, an open-source initiative that has been revolutionizing air transport research since its inception in 2019.\nThe first part of this book takes you through the core components that form the foundation of OpenAP. From the fundamentals of aircraft and engine data (Chapter 1) to the intricacies of drag and maximum thrust calculations (Chapter 2), kinematic models (Chapter 3), and flight phase identification (Chapter 4), we delve into the key components that make OpenAP an indispensable tool for researchers, developers, and aviation professionals. You will also learn how to harness OpenAP’s trajectory generation capabilities (Chapter 5) and analyze fuel and emission data (Chapter 6).\nThe second part focuses on the Trajectory Optimizer Package (TOP), an extension of OpenAP. Here, you will learn how to generate fuel-optimal and other types of optimal trajectories (Chapter 7). You will discover how to incorporate wind data into your optimizations (Chapter 8). Additionally, you will learn how to use TOP to handle more complex four-dimensional grid costs in your optimization problems, such as contrail formation (Chapter 9).\nEach chapter provides detailed insights into the underlying concepts, methodologies, and best practices, empowering you to make the most of OpenAP. Whether you’re a seasoned expert or new to the field, this manual will help you navigate the OpenAP library effectively. The goal is to equip you with the knowledge and skills necessary to leverage OpenAP in your research. Let’s embark on this journey together and explore the possibilities that OpenAP has to offer.\nEnjoy the reading!\nJunzi",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "The OpenAP Handbook",
    "section": "About the Author",
    "text": "About the Author\nJunzi Sun is an assistant professor at TU Delft, currently working in the CNS/ATM group of the Aerospace Engineering Faculty. He is passionate about open-source, open science, and making air transportation more sustainable.\nHe was born in China and completed his bachelor’s degree in telecommunication in Beijing. After that, he moved to Europe and obtained his master’s degree in aerospace engineering from the Polytechnic University of Catalonia. After working in Spain and France for several years, he pursued doctoral research in the Netherlands, where he obtained his Ph.D. and currently works and lives.\n\nThis online book is created with Quarto. To learn more about Quarto books, visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "openap.html",
    "href": "openap.html",
    "title": "🚀 OpenAP",
    "section": "",
    "text": "Chapters\nThe user guide for OpenAP is organized into the following chapters:",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#chapters",
    "href": "openap.html#chapters",
    "title": "🚀 OpenAP",
    "section": "",
    "text": "Chapter 1: Aircraft and engines\nChapter 2: Drag and thrust\n\nChapter 3: Kinematic models\nChapter 4: Flight phase identification\nChapter 5: Trajectory generation\nChapter 6: Fuel and Emission",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#data",
    "href": "openap.html#data",
    "title": "🚀 OpenAP",
    "section": "Data",
    "text": "Data\nFollow model datasets are all made public, under GPL open-source license:\n\nAircraft data: Collected from open literature.\nEngines data: Primarily from the ICAO emission data bank, including fuel flow and emissions.\nDrag polar data: Exclusively derived from open data (reference).\nKinematic data: Kinematic model (formally WRAP) describe speed, altitude, and vertical rate.\nNavigation data: Airport and waypoints obtained from X-plane.",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#modules",
    "href": "openap.html#modules",
    "title": "🚀 OpenAP",
    "section": "Modules",
    "text": "Modules\nOpenAP Python library includes the following modules, which support a variety of functionalities, including performance models, emission models, trajectory generation, and trajectory optimization:\n\nprop: module for accessing aircraft and engine data\nthrust: module for computing aircraft maximum thrust\ndrag: module for computing aircraft drag\nfuel: module for computing fuel flow\nemission: module for computing aircraft emissions\nkinematic: module for accessing kinematic data\naero: module for common aeronautical conversions\nnav: module for accessing navigation information\nphase: module for determining climb, cruise, descent, level flight\ntraj: module for generating trajectories based on the kinematic model\n\nOther modules that can be installed separately:\n\ntop: a package for generating optimal trajectories (see Trajectory Optimization chapter)",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#install",
    "href": "openap.html#install",
    "title": "🚀 OpenAP",
    "section": "Install",
    "text": "Install\nInstall the stable release from pypi:\npip install --upgrade openap\nOr, you can also install the latest development version from GitHub:\npip install --upgrade git+https://github.com/junzis/openap",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#using-openap",
    "href": "openap.html#using-openap",
    "title": "🚀 OpenAP",
    "section": "Using OpenAP",
    "text": "Using OpenAP\nMost of the functionalities (except aircraft and engine properties) in OpenAP are provided as Python classes. You can import these as follows:\nfrom openap.prop import aircraft, engine\nfrom openap.drag import Drag\nfrom openap.thrust import Thrust\nfrom openap.kinematic import WRAP\nfrom openap.phase import FlightPhase\nfrom openap.gen import FlightGenerator\nfrom openap.fuel import FuelFlow\nfrom openap.emission import Emission\n\n# when opeap-top is installed\nfrom openap.top import CompleteFlight, Climb, Cruise, Descent, MultiPhase\nYou can also import these Classes directly from the openap package as:\nfrom openap import (\n    Drag,\n    Thrust,\n    WRAP,\n    FlightPhase,\n    FlightGenerator,\n    FuelFlow,\n    Emission,\n)",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#contribute",
    "href": "openap.html#contribute",
    "title": "🚀 OpenAP",
    "section": "Contribute",
    "text": "Contribute\nIf you encounter any issues, please file a bug report on the GitHub issue tracker. You are even more welcomed to contribute to the project by submitting a pull request.",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "openap.html#book-and-paper",
    "href": "openap.html#book-and-paper",
    "title": "🚀 OpenAP",
    "section": "Book and Paper",
    "text": "Book and Paper\nThe OpenAP is the one outcome of my PhD research work (2015-2019). The Python library was first published in the following paper: Sun (2022)\nTo cite the paper:\n@article{sun2020openap,\n  title = {OpenAP: An open-source aircraft performance model for air transportation studies and simulations},\n  author = {Sun, Junzi and Hoekstra, Jacco and Ellerbroek, Joost},\n  journal = {Aerospace},\n  volume = {7},\n  number = {8},\n  pages = {104},\n  year = {2020},\n  month = jul,\n  publisher = {Multidisciplinary Digital Publishing Institute},\n  link = {https://doi.org/10.3390/aerospace7080104},\n  doi = {10.3390/aerospace7080104},\n}\n\n\n\n\n\n\nCaution\n\n\n\nThe libaray has evolved significantly since the paper’s publication. Key improvements include:\n\nUpdated aircraft and engine data\nMore accuracte fuel flow and emissions models\nSymbolic implementation for optimization with CasADi\n\n\n\n\n\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air transport and sustainability research. Aerospace, 9(7), 383. https://doi.org/10.3390/aerospace9070383",
    "crumbs": [
      "🚀 OpenAP"
    ]
  },
  {
    "objectID": "aircraft_engine.html",
    "href": "aircraft_engine.html",
    "title": "1  🪬 Aircraft and engines",
    "section": "",
    "text": "1.1 Supported aircraft type codes\nFirst, we need to import the prop package from the OpenAP library.\nfrom openap import prop\nfrom pprint import pprint\nWe can get a list of available aircraft openap.prop.available_aircraft() function:\navaiable_aircraft = prop.available_aircraft()\n\nprint(f\"Supports {len(avaiable_aircraft)} aircraft types\")\nprint(avaiable_aircraft)\n\nSupports 36 aircraft types\n['a19n', 'a20n', 'a21n', 'a318', 'a319', 'a320', 'a321', 'a332', 'a333', 'a343', 'a359', 'a388', 'b37m', 'b38m', 'b39m', 'b3xm', 'b734', 'b737', 'b738', 'b739', 'b744', 'b748', 'b752', 'b763', 'b772', 'b773', 'b77w', 'b788', 'b789', 'c550', 'e145', 'e170', 'e190', 'e195', 'e75l', 'glf6']",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#aircraft-data",
    "href": "aircraft_engine.html#aircraft-data",
    "title": "1  🪬 Aircraft and engines",
    "section": "1.2 Aircraft data",
    "text": "1.2 Aircraft data\nWe can get the parameters for one aircraft using openap.prop.aircraft() function:\n\naircraft = prop.aircraft(\"A320\")\npprint(aircraft)\n\n{'aircraft': 'Airbus A320',\n 'ceiling': 12500,\n 'cruise': {'height': 11000, 'mach': 0.78},\n 'drag': {'cd0': 0.018, 'e': 0.799, 'gears': 0.017, 'k': 0.039},\n 'engine': {'default': 'CFM56-5B4',\n            'mount': 'wing',\n            'number': 2,\n            'options': {'A320-111': 'CFM56-5-A1',\n                        'A320-211': 'CFM56-5-A1',\n                        'A320-212': 'CFM56-5A3',\n                        'A320-214': 'CFM56-5B4',\n                        'A320-215': 'CFM56-5B5',\n                        'A320-216': 'CFM56-5B6',\n                        'A320-231': 'V2500-A1',\n                        'A320-232': 'V2527-A5',\n                        'A320-233': 'V2527E-A5'},\n            'type': 'turbofan'},\n 'flaps': {'Sf/S': 0.17,\n           'area': 21.1,\n           'bf/b': 0.78,\n           'cf/c': 0.176,\n           'lambda_f': 0.9,\n           'type': 'single-slotted'},\n 'fuel': {'engine': 'CFM56-5B4/P', 'fuel_coef': 2.65942225},\n 'fuselage': {'height': 4.14, 'length': 37.57, 'width': 3.95},\n 'limits': {'MFC': 24210,\n            'MLW': 66000,\n            'MMO': 0.82,\n            'MTOW': 78000,\n            'OEW': 42600,\n            'VMO': 350,\n            'ceiling': 12500},\n 'mfc': 24210,\n 'mlw': 66000,\n 'mmo': 0.82,\n 'mtow': 78000,\n 'oew': 42600,\n 'pax': {'high': 170, 'low': 140, 'max': 180},\n 'vmo': 350,\n 'wing': {'area': 124, 'mac': 4.1935, 'span': 35.8, 'sweep': 25, 't/c': None}}",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "aircraft_engine.html#engine-data",
    "href": "aircraft_engine.html#engine-data",
    "title": "1  🪬 Aircraft and engines",
    "section": "1.3 Engine data",
    "text": "1.3 Engine data\nThe engine data can be obtained with openap.prop.engine() function:\n\nengine = prop.engine(\"CFM56-5B4\")\nengine\n\n{'uid': '2CM014',\n 'name': 'CFM56-5B4',\n 'manufacturer': 'CFM International',\n 'type': 'TF',\n 'bpr': 5.9,\n 'pr': 27.1,\n 'max_thrust': 117900,\n 'ei_hc_to': 0.1,\n 'ei_hc_co': 0.1,\n 'ei_hc_app': 0.13,\n 'ei_hc_idl': 3.87,\n 'ei_co_to': 0.5,\n 'ei_co_co': 0.5,\n 'ei_co_app': 2.33,\n 'ei_co_idl': 31.9,\n 'ei_nox_to': 28.7,\n 'ei_nox_co': 23.3,\n 'ei_nox_app': 10.0,\n 'ei_nox_idl': 4.3,\n 'ff_to': 1.166,\n 'ff_co': 0.961,\n 'ff_app': 0.326,\n 'ff_idl': 0.107,\n 'fuel_lto': 421.0,\n 'fuel_c3': 0.0468598,\n 'fuel_c2': 0.202282,\n 'fuel_c1': 0.871899,\n 'fuel_a': 0.587855,\n 'fuel_b': 0.417561,\n 'cruise_thrust': 22241.0,\n 'cruise_sfc': 0.0154,\n 'cruise_mach': 0.8,\n 'cruise_alt': 35000.0,\n 'fuel_ch': 5.2e-07}",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>🪬 Aircraft and engines</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html",
    "href": "drag_thrust.html",
    "title": "2  ☯️ Drag and thrust",
    "section": "",
    "text": "2.1 Compute the aircraft drag\nThe drag calculation is based on the OpenAP’s drag polar model, which is obtained based on open trajectory data and methodology from the paper: Sun et al. (2020).\nKnowing the drag polar coefficients - \\(C_{d0}\\) (zero-lift drag coefficient) and \\(k\\) (lift-induced drag coefficient) - of the aircraft, the drag force can be calculated based on the point-mass aircraft performance model:\n\\[\n\\begin{aligned}\nC_l &= \\frac{L}{1/2~\\rho v^2 S} = \\frac{mg}{1/2~\\rho v^2 S} \\\\\nC_d &= C_{d0} + k C_l^2 \\\\\nD &= C_d \\cdot \\frac{1}{2} \\rho v^2 S\n\\end{aligned}\n\\]\nWhen an aircraft is climbing and descending, the flight path angle is also considered to calculate the lift force. Hence, by including the vertical speed, the estimation of drag can be different.\nAn example calculation using the OpenAP’s drag module is:\nfrom openap.drag import Drag\n\ntypecode = \"A320\"\n\nmass = 62_000  # kg\nTAS = 250  # kts\nALT = 20_000  # ft\nVS = 1000  # ft/min\n\ndrag = Drag(ac=typecode)\n\n# clean configuration\nD = drag.clean(mass=mass, tas=TAS, alt=ALT, vs=VS)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nClean configuration \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:250  ALT:20000  VS:1000 \nClean configuration \n\nTotal drag is 33.0 kN\nThe drag.clean() function estimates the drag force when the aircraft is at the clean configuration, which means no flaps or landing gear are deployed.\nDuring the initial climb and approach, we can also calculate drag considering flaps (providing the flaps setting angle in degrees) and whether the landing gears are extended.\nmass = 62_000  # kg\nTAS = 150  # kts\nALT = 1000  # ft\nVS = 1500  # ft/min\nflap_angle = 20  # degree\n\n# with flaps and landing gears\nD = drag.nonclean(\n    mass=mass,\n    tas=TAS,\n    alt=ALT,\n    flap_angle=flap_angle,\n    vs=VS,\n    landing_gear=True,\n)\n\nprint(f\"\"\"{typecode} at condition: \nMass:{mass}  TAS:{TAS}  ALT:{ALT}  VS:{VS} \nFlap:{flap_angle} deg,  Landing Gear extended \n\nTotal drag is {D//1000} kN\n\"\"\")\n\nA320 at condition: \nMass:62000  TAS:150  ALT:1000  VS:1500 \nFlap:20 deg,  Landing Gear extended \n\nTotal drag is 46.0 kN",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "href": "drag_thrust.html#compute-maximum-aircraft-engine-thrust",
    "title": "2  ☯️ Drag and thrust",
    "section": "2.2 Compute maximum aircraft engine thrust",
    "text": "2.2 Compute maximum aircraft engine thrust\nOpenAP implements the engine thrust model proposed by Bartel & Young (2008). Small adjustments to the model was made to improve the computational efficiency.\nTo calculate the maximum net thrust of an aircraft, we first instantiate the thrust.Thrust object:\n\nfrom openap.thrust import Thrust\n\nthr_a320 = Thrust(ac=\"A320\", eng=\"CFM56-5B4\")\n\nThe function Thrust.takeoff() function is used to calculate maximum thrust during the take-off at different speed (kts) and altitude (ft) conditions, for example:\n\nT = thr_a320.takeoff(tas=100, alt=0)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 200.72 kN\n\n\nThe Thrust.climb() function estimates the maximum net thrust during the climb, which requires TAS (kts), altitude (ft), and rate of climb (ft/min).\nAn example for A320 climbing at 1000 ft/min at 10,000 ft with TAS 250 kts:\n\nT = thr_a320.climb(tas=250, alt=10000, roc=1000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 89.23 kN\n\n\nThe Thrust.cruise() function estimates the maximum net thrust during the cruise at different speeds and altitudes. An example is shown as follows.\n\nT = thr_a320.cruise(tas=300, alt=32000)\nprint(f\"Max thrust: {round(T/1000, 2)} kN\")\n\nMax thrust: 53.68 kN",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "drag_thrust.html#idle-thrust",
    "href": "drag_thrust.html#idle-thrust",
    "title": "2  ☯️ Drag and thrust",
    "section": "2.3 Idle thrust",
    "text": "2.3 Idle thrust\nFurthermore, we can use the Thrust.descent_ide() function to estimate the idle thrust during the descent at different altitude and speed conditions.\nThe idle thrust is modeled as approximately 7% of the maximum thrust at the same altitude and speed.\nAn example is shown as follows:\n\nT = thr_a320.descent_idle(tas=250, alt=10000)\nprint(f\"Idle thrust: {round(T/1000, 2)} kN\")\n\nIdle thrust: 9.31 kN\n\n\n\n\n\n\nBartel, M., & Young, T. M. (2008). Simplified thrust and fuel consumption models for modern two-shaft turbofan engines. Journal of Aircraft, 45(4), 1450–1456.\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft drag polar using open flight surveillance data and a stochastic total energy model. Transportation Research Part C: Emerging Technologies, 114, 391–404. https://doi.org/10.1016/j.trc.2020.01.026",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>☯️ Drag and thrust</span>"
    ]
  },
  {
    "objectID": "kinematic.html",
    "href": "kinematic.html",
    "title": "3  🌯 Kinematic models",
    "section": "",
    "text": "3.1 Parametric models\nFollowing is a list of functions that can be used to access parameters at different phases of flight, for example, flight type code A320:\nfrom openap.kinematic import WRAP\n\nwrap = WRAP(ac=\"A320\")",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#parametric-models",
    "href": "kinematic.html#parametric-models",
    "title": "3  🌯 Kinematic models",
    "section": "",
    "text": "params = wrap.takeoff_speed()\nparams = wrap.takeoff_distance()\nparams = wrap.takeoff_acceleration()\nparams = wrap.initclimb_vcas()\nparams = wrap.initclimb_vs()\nparams = wrap.climb_range()\nparams = wrap.climb_const_vcas()\nparams = wrap.climb_const_mach()\nparams = wrap.climb_cross_alt_concas()\nparams = wrap.climb_cross_alt_conmach()\nparams = wrap.climb_vs_pre_concas()\nparams = wrap.climb_vs_concas()\nparams = wrap.climb_vs_conmach()\nparams = wrap.cruise_range()\nparams = wrap.cruise_alt()\nparams = wrap.cruise_init_alt()\nparams = wrap.cruise_mach()\nparams = wrap.descent_range()\nparams = wrap.descent_const_mach()\nparams = wrap.descent_const_vcas()\nparams = wrap.descent_cross_alt_conmach()\nparams = wrap.descent_cross_alt_concas()\nparams = wrap.descent_vs_conmach()\nparams = wrap.descent_vs_concas()\nparams = wrap.descent_vs_post_concas()\nparams = wrap.finalapp_vcas()\nparams = wrap.finalapp_vs()\nparams = wrap.landing_speed()\nparams = wrap.landing_distance()\nparams = wrap.landing_acceleration()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-normal-distribution",
    "href": "kinematic.html#example-normal-distribution",
    "title": "3  🌯 Kinematic models",
    "section": "3.2 Example, normal distribution",
    "text": "3.2 Example, normal distribution\nLet’s take an example of the take-off distance, which is obtained using the takeoff_distance() function:\n\nwrap.takeoff_distance()\n\n{'default': 1.65,\n 'minimum': 1.06,\n 'maximum': 2.24,\n 'statmodel': 'norm',\n 'statmodel_params': [1.65, 0.36]}\n\n\nHere, we can see that the mean (default) value is 1.65 km, while the minimum and maximum take-off distances are 1.06 km and 2.24 km. The parameter can be described with a normal distribution, with a mean of 1.65 and a standard deviation of 0.36.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\nparams = wrap.takeoff_distance()\n\nmean, std = params[\"statmodel_params\"]\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\ny = stats.norm.pdf(x, mean, std)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"take-off distance (km)\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#example-other-distributions",
    "href": "kinematic.html#example-other-distributions",
    "title": "3  🌯 Kinematic models",
    "section": "3.3 Example, other distributions",
    "text": "3.3 Example, other distributions\nWe can take another example where the distribution is not a normal distribution, such as Mach number during the cruise:\n\nparams = wrap.cruise_mach()\ndisplay(params)\n\nx = np.linspace(params[\"minimum\"], params[\"maximum\"], 100)\n\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\n\ny = model.pdf(x)\n\nplt.figure(figsize=(4, 1.5))\nplt.plot(x, y)\nplt.fill_between(x, 0, y, alpha=0.2)\nplt.ylim(0)\nplt.xlabel(\"curise Mach number\")\nplt.gca().axes.get_yaxis().set_visible(False)\nplt.show()\n\n{'default': 0.78,\n 'minimum': 0.75,\n 'maximum': 0.8,\n 'statmodel': 'beta',\n 'statmodel_params': [17.82, 5.05, 0.62, 0.2]}\n\n\n\n\n\n\n\n\n\nThe plot shows a bete distribution. However, in this example code, we do not need to specify how the model should be constructed. The following code does the trick:\nmodel_class = getattr(stats, params[\"statmodel\"])\nmodel = model_class(*params[\"statmodel_params\"])\nWith this code, we can automatically generate a parametric model using parameters from the wrap.cruise_mach() function.",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "kinematic.html#units",
    "href": "kinematic.html#units",
    "title": "3  🌯 Kinematic models",
    "section": "3.4 Units",
    "text": "3.4 Units\nThe units of kinematic models are all in SI units, hence:\n\ndistance: in km\naltitude: in km\nspeed: in m/s\nacceleration: in m^2/s\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source kinematic aircraft performance model. Transportation Research Part C: Emerging Technologies, 98, 118–138. https://doi.org/10.1016/j.trc.2018.11.009",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>🌯 Kinematic models</span>"
    ]
  },
  {
    "objectID": "flight_phases.html",
    "href": "flight_phases.html",
    "title": "4  ㊙️ Flight phase identification",
    "section": "",
    "text": "4.1 Phase labeling\nWe can use FlightPhase.phaselabel(ts, alt, spd, roc) function to identify the labels of a given set of flight states. The following flight phases are supported:\nNote that the unit for all required parameters is:\nFollowing is an example labeling process based on a real flight:\nimport pandas as pd\nfrom openap.phase import FlightPhase\n\ndf = pd.read_csv(\"assets/data/flight_a319_opensky.csv\", parse_dates=[\"timestamp\"])\n\nts = (df.timestamp - df.timestamp.iloc[0]).dt.total_seconds()  # second\nalt = df.altitude.values  # ft\nspd = df.groundspeed.values  # kts\nroc = df.vertical_rate.values  # ft/min\n\nfp = FlightPhase()\n\nfp.set_trajectory(ts, alt, spd, roc)\n\nlabels = fp.phaselabel()\nprint(labels)\n\n['CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CL', 'CL', 'CR', 'CR', 'CL', 'CR', 'CL', 'CL', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'CR', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'DE', 'NA']\nWe can visualize the identified flight phases:\nimport matplotlib.pyplot as plt\n\nphasecolors = {\n    \"GND\": \"black\",\n    \"CL\": \"green\",\n    \"DE\": \"blue\",\n    \"LVL\": \"cyan\",\n    \"CR\": \"purple\",\n    \"NA\": \"red\",\n}\n\ncolors = [phasecolors[lbl] for lbl in labels]\n\nplt.subplot(311)\nplt.scatter(ts, alt, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"altitude (ft)\")\n\nplt.subplot(312)\nplt.scatter(ts, spd, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"speed (kt)\")\n\nplt.subplot(313)\nplt.scatter(ts, roc, marker=\".\", c=colors, lw=0)\nplt.ylabel(\"roc (fpm)\")\n\nplt.show()",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>㊙️ Flight phase identification</span>"
    ]
  },
  {
    "objectID": "flight_phases.html#phase-labeling",
    "href": "flight_phases.html#phase-labeling",
    "title": "4  ㊙️ Flight phase identification",
    "section": "",
    "text": "GND: on-ground  \nCL:  climb\nDE:  descend\nLVL: level flight\nCR:  cruise\nNA:  unlabeled\n\nts:  timestamp      second\nalt: altitude       ft\nspd: speed          kts\nroc: vertical rate  ft/min\n\n\n\n\n\n\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction and phase identification for large automatic dependent surveillance–broadcast datasets. Journal of Aerospace Information Systems, 14(10), 566–571. https://doi.org/10.2514/1.I010520",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>㊙️ Flight phase identification</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html",
    "href": "trajectory_gen.html",
    "title": "5  💅 Trajectory generation",
    "section": "",
    "text": "5.1 Complete flight\nTo use the flight generator, we need to instantiate the FlightGenerator object by providing the aircraft typecode, as in the following example:\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom openap.gen import FlightGenerator\n\nfgen = FlightGenerator(ac=\"a320\")\nThe following blocks of code are functions for plotting the trajectories later on.\nShow the plot_traj(flight) code\nimport matplotlib\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef plot_traj(flights: pd.DataFrame | list[pd.DataFrame], lw=2):\n    if isinstance(flights, pd.DataFrame):\n        flights = [flights]\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 4))\n\n    for f in flights:\n        ax1.plot(f.t, f.altitude, lw=lw)\n        ax2.plot(f.t, f.groundspeed, lw=lw)\n        ax3.plot(f.t, f.vertical_rate, lw=lw)\n        ax4.plot(f.t, f.s / 1000, lw=lw)\n\n        ax1.set_ylabel(\"altitude (ft)\")\n        ax2.set_ylabel(\"groundspeed (kt)\")\n        ax3.set_ylabel(\"vertical rate (ft/min)\")\n        ax4.set_ylabel(\"distance flown (km)\")\n\n        ax1.set_ylim(-1000, 40_000)\n        ax2.set_ylim(0, 600)\n        ax3.set_ylim(-3000, 3000)\n\n    for ax in (ax1, ax2, ax3, ax4):\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"top\"].set_visible(False)\n        ax.yaxis.set_label_coords(-0.1, 1.05)\n        ax.yaxis.label.set_rotation(0)\n        ax.yaxis.label.set_ha(\"left\")\n        ax.grid()\n\n        plt.tight_layout()\n        plt.show()\nTo generate a complete trajectory, we can call the FlightGenerator.complete() function by specifying the time step size in seconds. The function outputs a pandas dataframe, containing altitude, flight distance, speed, and vertical_rate.\nSee an example as follows:\nflight = fgen.complete(dt=10)\ndisplay(flight)\n\nplot_traj(flight)\n\n\n\n\n\n\n\n\n\nt\nh\ns\nv\nvs\naltitude\nvertical_rate\ngroundspeed\n\n\n\n\n0\n0\n0.0\n0.000000e+00\n0.0\n0.0\n0\n0\n0\n\n\n1\n10\n0.0\n0.000000e+00\n19.3\n0.0\n0\n0\n37\n\n\n2\n20\n0.0\n1.930000e+02\n38.6\n0.0\n0\n0\n75\n\n\n3\n30\n0.0\n5.790000e+02\n57.9\n0.0\n0\n0\n112\n\n\n4\n40\n0.0\n1.158000e+03\n77.2\n0.0\n0\n0\n150\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n681\n6790\n0.0\n1.386008e+06\n59.8\n0.0\n0\n0\n116\n\n\n682\n6800\n0.0\n1.386606e+06\n47.6\n0.0\n0\n0\n92\n\n\n683\n6810\n0.0\n1.387082e+06\n35.4\n0.0\n0\n0\n68\n\n\n684\n6820\n0.0\n1.387436e+06\n23.2\n0.0\n0\n0\n45\n\n\n685\n6830\n0.0\n1.387668e+06\n11.0\n0.0\n0\n0\n21\n\n\n\n\n686 rows × 8 columns\n\n\n\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#flight-segments-at-different-phases",
    "href": "trajectory_gen.html#flight-segments-at-different-phases",
    "title": "5  💅 Trajectory generation",
    "section": "5.2 Flight segments at different phases",
    "text": "5.2 Flight segments at different phases\nWe can also generate partial trajectories for only climb, descent, or cruise segments of the flight. The following are three examples.\n\nflight_climb = fgen.climb(dt=10)\nplot_traj(flight_climb)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_descent = fgen.descent(dt=10)\nplot_traj(flight_descent)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nflight_cruise = fgen.cruise(dt=10)\nplot_traj(flight_cruise)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "href": "trajectory_gen.html#generate-flight-with-specific-parameters",
    "title": "5  💅 Trajectory generation",
    "section": "5.3 Generate flight with specific parameters",
    "text": "5.3 Generate flight with specific parameters\nPreviously, we generated the most typical flight profile based on the default values in the WRAP kinematic model. However, we can customize the generation by providing specific parameters.\nFor example, with the following code, we can specify CAS/Mach setting during the climb and the top of the climb altitude for the trajectory.\n\nflight_climb_with_params = fgen.climb(\n    dt=10,\n    cas_const_cl=280,\n    mach_const_cl=0.78,\n    alt_cr=32000,\n)\n\nplot_traj(flight_climb_with_params)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "href": "trajectory_gen.html#generate-flights-randomly-sampled-using-the-kinematic-model",
    "title": "5  💅 Trajectory generation",
    "section": "5.4 Generate flights randomly sampled using the kinematic model",
    "text": "5.4 Generate flights randomly sampled using the kinematic model\nIn many use cases, we want to generate a wide range of flight trajectories. The FlightGenerator allows such a possibility. We can generate random and yet realistic trajectories like a breeze.\nYou simply need to provide the radom=True argument when generating trajectories. The generator will randomly sample parameters from the proper distribution of each parameter in the WRAP model.\nThe following example shows several randomly generated flights at different flight phases and randomly sampled complete trajectories.\n\nclimb_flights= [fgen.climb(dt=10, random=True) for i in range(5)]\n\nplot_traj(climb_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ndescent_flights = [fgen.descent(dt=10, random=True) for i in range(5)]\n\nplot_traj(descent_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncruise_flights = [fgen.cruise(dt=10, random=True) for i in range(5)]\n\nplot_traj(cruise_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "trajectory_gen.html#add-noise-to-the-flight-data",
    "href": "trajectory_gen.html#add-noise-to-the-flight-data",
    "title": "5  💅 Trajectory generation",
    "section": "5.5 Add noise to the flight data",
    "text": "5.5 Add noise to the flight data\nSometimes, we may also want to add some random noises to the trajectory data. With the FlightGenerator.enable_noise() function, we can make sure Gaussian noises are added to all trajectory points.\nThe noise model is based on ADS-B Version 1 and 2, with a NACv (navigation accuracy category - velocity) value of 3 and a NACp (navigation accuracy category - position) value of 10. More details can be found in Sun (2021, Chapter 9).\n\nfgen.enable_noise()  # enable Gaussian noise in trajectory data\n\ncomplete_flights = [fgen.complete(dt=10, random=True) for i in range(5)]\n\nplot_traj(complete_flights, lw=1)\n\n\n\n\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\n\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode s and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>💅 Trajectory generation</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html",
    "href": "fuel_emission.html",
    "title": "6  🔥 Fuel and Emission",
    "section": "",
    "text": "6.1 Accuracy of the fuel model\nThe accuracy of the fuel estimation is greatly improved in the new OpenAP (v2), which is comparable to the BADA 3 fuel model. This is due to the better tuning using data-driven model, acropole, shared by @JarryGabriel.\nIn best cases, we see errors below 3%, and in the following A320 example shows an accuracy of 1% compared to the QAR data.\nFor the in-depth analysis of the accuracy affected by mass, wind, and other parameters for this flight, please see the example from the traffic library.",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#accuracy-of-the-fuel-model",
    "href": "fuel_emission.html#accuracy-of-the-fuel-model",
    "title": "6  🔥 Fuel and Emission",
    "section": "",
    "text": "fuel estimation accuracy",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "href": "fuel_emission.html#basic-usage-of-the-fuel-and-emission-modules",
    "title": "6  🔥 Fuel and Emission",
    "section": "6.2 Basic usage of the fuel and emission modules",
    "text": "6.2 Basic usage of the fuel and emission modules\n\n6.2.1 Compute aircraft fuel flow:\nTo estimate fuel flow, you need to provide the aircraft type (e.g., ‘A320’) through the openap.FuelFlow object. The fuel flow model is based on: - aircraft’s mass (in kg), - true airspeed (TAS, in kts), - altitude (in ft), - and vertical speed (optional, in ft/min).\n\nfrom openap import FuelFlow\n\n# create a fuel flow model for A320\nfuelflow = FuelFlow(ac='A320')\n\n# estimate fuel flow during cruise\nFF = fuelflow.enroute(mass=60000, tas=230, alt=32000)\n\n# estimate fuel flow at climb, with vertical speed (feet/min)\nFF = fuelflow.enroute(mass=60000, tas=200, alt=20000, vs=1000)\n\n# estimate fuel flow at with a given thrust (e.g., derived from drag model)\nFF = fuelflow.at_thrust(acthr=50000, alt=30000)\n\n# estimate fuel flow at takeoff\nFF = fuelflow.takeoff(tas=100, alt=0, throttle=1)\n\n\n\n6.2.2 Compute aircraft emissions:\nThe emission model is based on the fuel flow and aircraft’s true airspeed (TAS) and altitude. The input fuel flow is in kg/s The emissions include CO2, H2O, NOx, CO, and HC, with units in g/s.\n\nfrom openap import FuelFlow, Emission\n\nfuelflow = FuelFlow(ac=\"A320\")\nemission = Emission(ac=\"A320\")\n\nTAS = 350\nALT = 30000\n\nFF = fuelflow.enroute(mass=60000, tas=TAS, alt=ALT, vs=0)  # kg/s\n\nCO2 = emission.co2(FF)  # g/s\nH2O = emission.h2o(FF)  # g/s\nNOx = emission.nox(FF, tas=TAS, alt=ALT)  # g/s\nCO = emission.co(FF, tas=TAS, alt=ALT)  # g/s\nHC = emission.hc(FF, tas=TAS, alt=ALT)  # g/s",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "href": "fuel_emission.html#estimate-fuel-and-emission-from-flight-data",
    "title": "6  🔥 Fuel and Emission",
    "section": "6.3 Estimate fuel and emission from flight data",
    "text": "6.3 Estimate fuel and emission from flight data\nIn the following example, we estimate the fuel consumption for a given flight trajectory data obtained from the OpenSky Network. The sample data can be downloaded from https://github.com/junzis/openap/tree/master/examples.\nThe following code snippets show how to estimate fuel flow and emissions for this example flight trajectory data.\n\n6.3.1 Data exploration\nFirst, we need to import openap, pandas, and matplotlib libraries.\n\nimport pandas as pd\nimport openap\nimport matplotlib.pyplot as plt\n\nWe also need to define aircraft parameters and import data.\n\nmass_takeoff_assumed = 66300  # kg\n\nfuelflow = openap.FuelFlow(\"A319\")\n\n# Load the data\ndf = pd.read_csv(\n    \"assets/data/flight_a319_opensky.csv\",\n    parse_dates=[\"timestamp\"],\n    dtype={\"icao24\": str},\n)\n\n# Calculate seconds between each timestamp\ndf = df.assign(d_ts=lambda d: d.timestamp.diff().dt.total_seconds().bfill())\n\nLet’s see what are the features in this flight dataframe:\n\ndf\n\n\n\n\n\n\n\n\n\ntimestamp\nicao24\ntypecode\ncallsign\norigin\ndestination\nlatitude\nlongitude\naltitude\ngroundspeed\ntrack\nvertical_rate\nd_ts\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.085861\n2.349666\n8200.0\n255.0\n327.804266\n1920.0\n60.0\n\n\n1\n2018-01-02 19:54:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.153427\n2.310861\n9475.0\n290.0\n9.722018\n960.0\n60.0\n\n\n2\n2018-01-02 19:55:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.233367\n2.361121\n9975.0\n332.0\n23.243919\n640.0\n60.0\n\n\n3\n2018-01-02 19:56:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.319916\n2.418471\n11225.0\n353.0\n23.517962\n2752.0\n60.0\n\n\n4\n2018-01-02 19:57:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n49.411652\n2.478896\n14175.0\n368.0\n23.566915\n3584.0\n60.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n58.978659\n17.706646\n13250.0\n343.0\n24.471621\n-1408.0\n60.0\n\n\n112\n2018-01-02 21:45:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.062826\n17.781088\n11800.0\n326.0\n24.443955\n-1344.0\n60.0\n\n\n113\n2018-01-02 21:46:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.142609\n17.852051\n10400.0\n307.0\n24.397686\n-1216.0\n60.0\n\n\n114\n2018-01-02 21:47:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.217286\n17.918701\n9125.0\n291.0\n24.541618\n-1216.0\n60.0\n\n\n115\n2018-01-02 21:48:00+00:00\n3946e9\na319\nAFR91HL\nLBG\nBMA\n59.289505\n17.990112\n8075.0\n291.0\n28.500577\n-960.0\n60.0\n\n\n\n\n116 rows × 13 columns\n\n\n\n\nLet’s plot the altitude profile of the flight. I will also make the plots more visually appealing.\n\nfrom matplotlib import dates\n\nimport matplotlib\n\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\ndef format_ax(ax):\n    ax.xaxis.set_major_formatter(dates.DateFormatter(\"%H:%M\"))\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.03)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 5), sharex=True)\n\nax1.plot(df.timestamp, df.altitude)\nax2.plot(df.timestamp, df.groundspeed)\nax3.plot(df.timestamp, df.vertical_rate)\n\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"groundspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.3.2 Fuel flow calculation\nNext, we iterate over the timestamp to calculate fuel flow and mass during the flight.\n\nmass_current = mass_takeoff_assumed\n\nfuelflow_every_step = []\nfuel_every_step = []\n\nfor i, row in df.iterrows():\n    ff = fuelflow.enroute(\n        mass=mass_current,\n        tas=row.groundspeed,\n        alt=row.altitude,\n        vs=row.vertical_rate,\n    )\n    fuel = ff * row.d_ts\n    fuelflow_every_step.append(ff)\n    fuel_every_step.append(ff * row.d_ts)\n    mass_current -= fuel\n\ndf = df.assign(fuel_flow=fuelflow_every_step, fuel=fuel_every_step)\n\nThen, we can visualize the fuel flow during the flight.\n\nplt.figure(figsize=(7, 2))\nplt.plot(df.timestamp, df.fuel_flow, color=\"tab:red\")\nplt.ylabel(\"fuel flow (kg/s)\")\nformat_ax(plt.gca())\nplt.show()\n\n\n\n\n\n\n\n\nWith the new dataframe, we can calculate total fuel consumption by summing the fuel consumption at overall time steps:\n\ntotal_fuel = df.fuel.sum().astype(int)\nprint(f\"Total fuel: {total_fuel} kg\")\n\nTotal fuel: 5052 kg\n\n\n\n\n6.3.3 Emission calculation\nThe emission calculations are based on the fuel consumption using the openap.Emission class.\nWe can calculate the emissions for the entire flight and append them as new columns to the dataframe as follows:\n\nemission = openap.Emission(ac=\"A319\")\n\ndf = df.assign(\n    co2_flow=lambda d: emission.co2(d.fuel_flow),\n    h2o_flow=lambda d: emission.h2o(d.fuel_flow),\n    soot_flow=lambda d: emission.soot(d.fuel_flow),\n    sox_flow=lambda d: emission.sox(d.fuel_flow),\n    nox_flow=lambda d: emission.nox(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    co_flow=lambda d: emission.co(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n    hc_flow=lambda d: emission.hc(d.fuel_flow, tas=d.groundspeed, alt=d.altitude),\n)\n\nLet’s visualize the emission flows:\n\nfig, axes = plt.subplots(7, 1, figsize=(5, 7), sharex=True)\n\naxes = axes.flatten()\n\nlabels = dict(\n    co2_flow=\"CO2 (g/s)\",\n    h2o_flow=\"H2O (g/s)\",\n    soot_flow=\"Soot (g/s)\",\n    sox_flow=\"SOx (g/s)\",\n    nox_flow=\"NOx (g/s)\",\n    co_flow=\"CO (g/s)\",\n    hc_flow=\"HC (g/s)\",\n)\n\nfor i, (k, v) in enumerate(labels.items()):\n    axes[i].plot(df.timestamp, df[k], color=\"tab:brown\")\n    axes[i].set_ylabel(v)\n    format_ax(axes[i])\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNote that CO2, H2O, Soot, and SOx are linear correlated to the fuel flow, following the coefficients from the paper Global Mortality Attributable to Aircraft Cruise Emissions.\n\n\n6.3.4 Final data\nThe emissions at each time step are also calculated as follows. Note that we divide values by 1000 to obtain the emissions in kg.\n\ndf = df.eval(\n    \"\"\"\n    co2 = co2_flow * d_ts / 1000\n    h2o = h2o_flow * d_ts / 1000\n    soot = soot_flow * d_ts / 1000\n    sox = sox_flow * d_ts / 1000\n    nox = nox_flow * d_ts / 1000\n    co = co_flow * d_ts / 1000\n    hc = hc_flow * d_ts / 1000\n    \"\"\"\n)\n\nWe can take a look at the final data with fuel flow and emissions columns.\n\ndf[[\"timestamp\", \"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].round(4)\n\n\n\n\n\n\n\n\n\ntimestamp\nfuel\nco2\nh2o\nsoot\nsox\nnox\nco\nhc\n\n\n\n\n0\n2018-01-02 19:53:00+00:00\n81.3691\n257.1265\n100.0840\n0.0024\n0.0976\n1.2232\n0.0993\n0.0027\n\n\n1\n2018-01-02 19:54:00+00:00\n61.1136\n193.1191\n75.1698\n0.0018\n0.0733\n0.7674\n0.1380\n0.0027\n\n\n2\n2018-01-02 19:55:00+00:00\n57.3222\n181.1380\n70.5063\n0.0017\n0.0688\n0.6956\n0.1402\n0.0026\n\n\n3\n2018-01-02 19:56:00+00:00\n88.5218\n279.7288\n108.8818\n0.0027\n0.1062\n1.4456\n0.0554\n0.0025\n\n\n4\n2018-01-02 19:57:00+00:00\n85.7259\n270.8939\n105.4429\n0.0026\n0.1029\n1.3834\n0.0540\n0.0025\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n111\n2018-01-02 21:44:00+00:00\n27.3882\n86.5467\n33.6875\n0.0008\n0.0329\n0.2163\n0.3043\n0.0143\n\n\n112\n2018-01-02 21:45:00+00:00\n26.7537\n84.5418\n32.9071\n0.0008\n0.0321\n0.2061\n0.3411\n0.0170\n\n\n113\n2018-01-02 21:46:00+00:00\n26.5316\n83.8399\n32.6339\n0.0008\n0.0318\n0.2016\n0.3610\n0.0184\n\n\n114\n2018-01-02 21:47:00+00:00\n25.4723\n80.4924\n31.3309\n0.0008\n0.0306\n0.1865\n0.3963\n0.0210\n\n\n115\n2018-01-02 21:48:00+00:00\n28.2236\n89.1865\n34.7150\n0.0008\n0.0339\n0.2214\n0.3331\n0.0165\n\n\n\n\n116 rows × 9 columns\n\n\n\n\nFinally, we can obtain the total fuel consumption and emissions for the entire flight (unit in kg).\n\ndf[[\"fuel\", \"co2\", \"h2o\", \"soot\", \"sox\", \"nox\", \"co\", \"hc\"]].sum().round(2)\n\nfuel     5052.25\nco2     15965.10\nh2o      6214.27\nsoot        0.15\nsox         6.06\nnox        55.09\nco         18.27\nhc          0.46\ndtype: float64",
    "crumbs": [
      "🚀 OpenAP",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>🔥 Fuel and Emission</span>"
    ]
  },
  {
    "objectID": "optimize/index.html",
    "href": "optimize/index.html",
    "title": "🦸 Trajectory Optimizer",
    "section": "",
    "text": "Use cases\nThe following chapters demonstrate various optimization scenarios and practical applications:",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#use-cases",
    "href": "optimize/index.html#use-cases",
    "title": "🦸 Trajectory Optimizer",
    "section": "",
    "text": "Chapter 7: explains how you can easily generate fuel and other simple cost-optimal trajectories.\nChapter 8: provides two approaches to obtaining wind fields and using them in your optimization.\nChapter 9: dives deeper into optimization with more complex 3D or 4D grids.\nChapter 10: provides a concrete example of flight optimization considering contrails.",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#install",
    "href": "optimize/index.html#install",
    "title": "🦸 Trajectory Optimizer",
    "section": "Install",
    "text": "Install\nThe opeanp.top library is designed to be a module inside the openap scope. You can install the most recent release thorugh pip:\npip install --upgrade openap-top\nThis will install openap.top and related dependencies.\nAlternatively, if you want to install the most recent development version (usually it is also recommended to update openap to the latest dev version):\npip install --upgrade git+https://github.com/junzis/openap\npip install --upgrade git+https://github.com/junzis/openap-top",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/index.html#paper",
    "href": "optimize/index.html#paper",
    "title": "🦸 Trajectory Optimizer",
    "section": "Paper",
    "text": "Paper\nThe optimization framework was first published in the following paper: Sun (2022)\nTo cite the paper:\n@article{sun2022top,\n  title = {OpenAP.top: Open Flight Trajectory Optimization for Air Transport and Sustainability Research},\n  author = {Sun, Junzi},\n  journal = {Aerospace},\n  volume = {9},\n  number = {7},\n  pages = {383},\n  year = {2022},\n  month = jul,\n  publisher = {Multidisciplinary Digital Publishing Institute},\n  link = {https://doi.org/10.3390/aerospace9070383},\n  doi = {10.3390/aerospace9070383},\n}\n\n\n\n\n\n\nCaution\n\n\n\nWhile the fundamental principle of trajectory optimization (based on non-linear optimal control) remains unchanged, the software has evolved significantly since the paper’s publication.\nKey improvements include:\n\nEnhanced performance models\nMore robust trajectory generation logic, and better convergence\nOptimized computational performance, much faster 🚀\n\n\n\n\n\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air transport and sustainability research. Aerospace, 9(7), 383. https://doi.org/10.3390/aerospace9070383",
    "crumbs": [
      "🦸 Trajectory Optimizer"
    ]
  },
  {
    "objectID": "optimize/basic.html",
    "href": "optimize/basic.html",
    "title": "7  🍳 Simple optimal flights",
    "section": "",
    "text": "7.1 Quick start\nExample code to generate a fuel-optimal flight between two airports. First, we need to set up a few parameters, including origin, destination, actype, and m0 (initial mass).\nThe initial mass m0 can be the fraction of the maximum take-off mass (between 0 and 1), or it can be the mass in kg (for example, 65000 kg).\nfrom openap import top\n\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\nIn this simple example, we will generate a complete flight using top.CompleteFlight(). We will generate a fuel-optimal flight by setting objective to \"fuel\" in the trajectory generation function.\noptimizer = top.CompleteFlight(actype, origin, destination, m0=m0)\n\nflight = optimizer.trajectory(objective=\"fuel\")\nflight.head()\n\n\n\n\n\n\n\n\n\nts\nx\ny\nh\nlatitude\nlongitude\naltitude\nmach\ntas\nvertical_rate\nheading\nmass\nfuel\n\n\n\n\n0\n0.0\n-652425.011696\n840651.921623\n30.480000\n52.316584\n4.746242\n100.0\n0.3000\n198.38\n1155.0\n129.51\n66300.000000\n323.467557\n\n\n1\n240.0\n-633557.291544\n825095.442439\n1436.228097\n52.198625\n5.049372\n4712.0\n0.5000\n325.34\n1655.0\n137.01\n65976.532443\n331.368938\n\n\n2\n479.0\n-606696.232046\n796275.571353\n3450.725380\n51.969890\n5.489660\n11321.0\n0.6869\n436.31\n2155.0\n137.02\n65645.163505\n336.864499\n\n\n3\n719.0\n-571079.731509\n758059.040224\n6073.971848\n51.664098\n6.066591\n19928.0\n0.7589\n466.37\n1655.0\n137.02\n65308.299006\n310.576620\n\n\n4\n959.0\n-532698.817232\n716876.379079\n8088.469130\n51.331487\n6.679653\n26537.0\n0.7970\n476.69\n1155.0\n137.03\n64997.722386\n270.762600\nIn the previous table, we have the final fuel-optimal trajectory. Next, we can visualize the altitude, speed, and vertical rate.\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# set up the plot styles\nmatplotlib.rc(\"font\", size=11)\nmatplotlib.rc(\"font\", family=\"Ubuntu\")\nmatplotlib.rc(\"lines\", linewidth=2, markersize=8)\nmatplotlib.rc(\"grid\", color=\"darkgray\", linestyle=\":\")\n\n\n# function to make plot nicer\ndef format_ax(ax):\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_label_coords(-0.1, 1.05)\n    ax.yaxis.label.set_rotation(0)\n    ax.yaxis.label.set_ha(\"left\")\n    ax.grid()\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(5, 4), sharex=True)\nax1.plot(flight.ts, flight.altitude)\nax2.plot(flight.ts, flight.tas)\nax3.plot(flight.ts, flight.vertical_rate)\nax1.set_ylim(0, 40000)\nax2.set_ylim(0, 600)\nax3.set_ylim(-3000, 3000)\nax1.set_ylabel(\"altitude (ft)\")\nax2.set_ylabel(\"true airspeed (kts)\")\nax3.set_ylabel(\"vertical rate (ft/min)\")\nax3.set_xlabel(\"time(s)\")\n\nfor ax in (ax1, ax2, ax3):\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/basic.html#other-objective-functions",
    "href": "optimize/basic.html#other-objective-functions",
    "title": "7  🍳 Simple optimal flights",
    "section": "7.2 Other objective functions",
    "text": "7.2 Other objective functions\nInstead of the default objective functions, you can also specify different objective functions as follows:\n# cost index, between 0 - 100\nflight = optimizer.trajectory(objective=\"ci:30\")\n\n# global warming potential\nflight = optimizer.trajectory(objective=\"gwp100\")\n\n# global temperature potential\nflight = optimizer.trajectory(objective=\"gtp100\")\nThe final flight object is a pandas DataFrame.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/basic.html#different-flight-phases",
    "href": "optimize/basic.html#different-flight-phases",
    "title": "7  🍳 Simple optimal flights",
    "section": "7.3 Different flight phases",
    "text": "7.3 Different flight phases\nInstead of generating a complete flight, we can also generate cruise, climb, and descent flights using top.Crusie, top.Climb, and top.Descent classes.\n\ncruise_flight = top.Cruise(actype, origin, destination, m0=m0).trajectory()\n\nclimb_flight = top.Climb(actype, origin, destination, m0=m0).trajectory()\n\ndescent_flight = top.Descent(actype, origin, destination, m0=m0).trajectory()\n\nLet’s visulize these trajectories:\n\nlabels = (\"cruise flight\", \"climb flight\", \"descent flight\")\n\nfig, axes = plt.subplots(3, 3, figsize=(10, 4))\n\nfor i, flight in enumerate([cruise_flight, climb_flight, descent_flight]):\n    ax1, ax2, ax3 = axes[:, i]\n    ax1.plot(flight.ts, flight.altitude)\n    ax2.plot(flight.ts, flight.tas)\n    ax3.plot(flight.ts, flight.vertical_rate)\n    ax1.set_ylabel(\"altitude (ft)\")\n    ax2.set_ylabel(\"true airspeed (kts)\")\n    ax3.set_ylabel(\"vertical rate (ft/min)\")\n    ax1.set_ylim(0, 40000)\n    ax2.set_ylim(0, 600)\n    ax3.set_ylim(-3000, 3000)\n    ax1.set_title(labels[i], pad=20)\n    ax3.set_xlabel(\"time(s)\")\n\nfor ax in axes.flatten():\n    format_ax(ax)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>🍳 Simple optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/wind.html",
    "href": "optimize/wind.html",
    "title": "8  🌪️ Wind optimal flights",
    "section": "",
    "text": "8.1 Obtaining wind with fastmeteo\nIt is also possible to include 3D or 4D wind data in the optimization. The following code provides an example of such a use case. Note that the wind data is obtained using fastmeteo library in this example.\nimport fastmeteo\nimport numpy as np\nimport pandas as pd\nimport openap\n\nfrom openap import top\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\nm0 = 0.85\nNext, we need to get an example wind field data using the fastmeteo library. Note the selected ERA5 data will be cached temporarily at /tmp/era5-zarr.\nactype = \"A320\"\norigin = \"EHAM\"\ndestination = \"LGAV\"\n\n# initial mass as the faction of maximum takeoff mass\nm0 = 0.85\n\n# get the boundary of the wind field\no = openap.nav.airport(origin)\nd = openap.nav.airport(destination)\n\nlatmin = round(min(o[\"lat\"], d[\"lat\"])) - 2\nlatmax = round(max(o[\"lat\"], d[\"lat\"])) + 2\nlonmin = round(min(o[\"lon\"], d[\"lon\"])) - 4\nlonmax = round(max(o[\"lon\"], d[\"lon\"])) + 4\n\n# create the and flatten the wind grid\nlatitudes = np.arange(latmin, latmax, 0.5)\nlongitudes = np.arange(lonmin, lonmax, 1)\naltitudes = np.arange(1000, 46000, 2000)\ntimestamps = pd.date_range(\"2021-05-01 08:00:00\", \"2021-05-01 11:00:00\", freq=\"1H\")\n\nlatitudes, longitudes, altitudes, times = np.meshgrid(\n    latitudes, longitudes, altitudes, timestamps\n)\n\ngrid = pd.DataFrame().assign(\n    latitude=latitudes.flatten(),\n    longitude=longitudes.flatten(),\n    altitude=altitudes.flatten(),\n    timestamp=times.flatten(),\n)\n\n# obtain the wind based on the grid\nfmg = fastmeteo.Grid(local_store=\"/tmp/era5-zarr\")\n\nmeteo_data = fmg.interpolate(grid)\n\ninit local zarr from google arco era5, hour: 2021-05-01 08:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 09:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 10:00:00\nsyncing zarr from google arco-era5, hour: 2021-05-01 11:00:00\nLet’s take a look at the meteorological data we got:\nmeteo_data.head()\n\n\n\n\n\n\n\n\n\nlatitude\nlongitude\naltitude\ntimestamp\nu_component_of_wind\nv_component_of_wind\ntemperature\nspecific_humidity\n\n\n\n\n0\n36.0\n1\n1000\n2021-05-01 08:00:00\n4.133623\n3.570823\n287.546767\n0.006717\n\n\n1\n36.0\n1\n1000\n2021-05-01 09:00:00\n5.019323\n2.913781\n288.905607\n0.006309\n\n\n2\n36.0\n1\n1000\n2021-05-01 10:00:00\n6.375478\n1.566804\n289.427981\n0.005825\n\n\n3\n36.0\n1\n1000\n2021-05-01 11:00:00\n6.242283\n0.733652\n290.577190\n0.005545\n\n\n4\n36.0\n1\n3000\n2021-05-01 08:00:00\n8.573422\n4.150122\n282.324727\n0.006347\nBefore passing this wind field to the optimizer, we need to format it correctly. The wind data needs to be in pandas.DataFrame with the following columns: - ts: timestamp in seconds, with 0 representing the time of departure of the flight - latitude: latitude of all the grid points - longitude: longitude of all the grid points - h: height of the grid points, in meters - u: u component of the wind for each grid point, in m/s - v: v component of the wind for each grid point, in m/s\nwind = (\n    meteo_data.rename(\n        columns={\n            \"u_component_of_wind\": \"u\",\n            \"v_component_of_wind\": \"v\",\n        }\n    )\n    .assign(ts=lambda x: (x.timestamp - x.timestamp.iloc[0]).dt.total_seconds())\n    .eval(\"h=altitude * 0.3048\")\n)[[\"ts\", \"latitude\", \"longitude\", \"h\", \"u\", \"v\"]]\n\nwind.head()\n\n\n\n\n\n\n\n\n\nts\nlatitude\nlongitude\nh\nu\nv\n\n\n\n\n0\n0.0\n36.0\n1\n304.8\n4.133623\n3.570823\n\n\n1\n3600.0\n36.0\n1\n304.8\n5.019323\n2.913781\n\n\n2\n7200.0\n36.0\n1\n304.8\n6.375478\n1.566804\n\n\n3\n10800.0\n36.0\n1\n304.8\n6.242283\n0.733652\n\n\n4\n0.0\n36.0\n1\n914.4\n8.573422\n4.150122\nLast, we can run the optimization with the wind field and visulize the result:\nimport matplotlib.pyplot as plt\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, barb_steps=15)\nplt.show()\nIf you only want to visualize the map:\ntop.vis.map(flight, windfield=wind, barb_steps=15)\nplt.show()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>🌪️ Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/wind.html#using-grid-wind-files",
    "href": "optimize/wind.html#using-grid-wind-files",
    "title": "8  🌪️ Wind optimal flights",
    "section": "8.2 Using grid wind files",
    "text": "8.2 Using grid wind files\nYou can also optimize the trajectory with grid atmospheric data, for example, grib or nc files downloaded from the ECMWF or GFS. In TOP, there is a built-in function top.tools.read_grids() that can be used to process grid data files into a DataFrame for the optimizer.\n\n# read the downloaded ERA5 grib data, the arguments can be a list of files.\nwind = top.tools.read_grids(\"tmp/era5_2021-05-01_0800.grib\")\n\noptimizer = top.CompleteFlight(actype, origin, destination, m0)\noptimizer.enable_wind(wind)\nflight = optimizer.trajectory(objective=\"fuel\")\n\ntop.vis.trajectory(flight, windfield=wind, barb_steps=25)\nplt.show()\n\nIgnoring index file '/home/junzi/arc/workspace/website/openap.dev/optimize/tmp/era5_2021-05-01_0800.grib.5b7b6.idx' incompatible with GRIB file\n\n\n\n\n\n\n\n\n\nSince the grib data from a similar time frame was downloaded, we can observe that the result is similar to the one from the previous section. The advantage is that the code is relatively simple compared to the previous example, which used fastmeteo to download data that covers the region of the flights.\nHowever, this approach requires a large quantity of grid data to be downloaded first. The read_grids() function also loads the entire grid files into RAM, which can be memory intensive if many grid files are loaded.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>🌪️ Wind optimal flights</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html",
    "href": "optimize/costgrid.html",
    "title": "9  🙀 Using cost grids",
    "section": "",
    "text": "9.1 Cost grid in 3D\nTo demonstrate the use of 3D cost in flight optimization, we will first set up an example cost grid. The example flight we want to optimize is still based on the one from previous chapters, flight with the origin of EHAM and the destination of LGAV.\nWe first generate an artificial 2D cost grid using a Gaussian function, with the x range of (-10, 10) and y range of (-5, 5). Then the range is transformed to the longitude and latitude bounds for our flight. The 2D cost grids at different levels are dependent on the altitude, where the higher the altitude, the higher the cost.\nimport numpy as np\nimport pandas as pd\n\n\ndef gaussian(x, y, z):\n    return (\n        np.exp(-((x + 3) ** 2 + (y - 1) ** 2)) + np.exp(-((x - 3) ** 2 + (y + 2) ** 2))\n    ) * z**2\n\n\nx = np.linspace(-10, 10, 40)\ny = np.linspace(-5, 5, 40)\nz = np.linspace(1, 2, 32)\n\nX, Y, Z = np.meshgrid(x, y, z)\ncosts3d = gaussian(X, Y, Z)\ncosts3d = (costs3d - costs3d.min()) / (costs3d.max() - costs3d.min())\n\nlon = np.interp(x, (min(x), max(x)), (-10, 40))\nlat = np.interp(y, (min(y), max(y)), (35, 60))\nalt = np.interp(z, (min(z), max(z)), (0, 40_000))\n\nlons, lats, alts = np.meshgrid(lon, lat, alt)\nWe can visualize the cost grid at different altitude as follows:\nShow the code used for visulization\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 3, figsize=(12, 8), subplot_kw={\"projection\": \"3d\"})\nfor i, ax in enumerate(axes.flatten()):\n    ax.plot_surface(\n        lons[:, :, i * 6],\n        lats[:, :, i * 6],\n        costs3d[:, :, i * 6],\n        edgecolor=\"tab:blue\",\n        lw=0.5,\n        alpha=0.3,\n    )\n    ax.set_zlim(0, 1)\n    flight_level = int(alt[i * 6] // 1000 * 10)\n    ax.set_title(f\"FL{flight_level}\")\n    ax.set_xlabel(\"longitude\")\n    ax.set_ylabel(\"latitude\")\n    ax.set_zlabel(\"cost\", rotation=90)\n\nplt.show()\nWe can construct the cost as a flattened 2D DataFrame. It is important that the DataFrame has the columns height, latitude, longitude. The height unit must be in meters.\nExample of the cost grid as apd.DataFrame:\ndf_cost_3d = pd.DataFrame(\n    np.array([lons, lats, alts, costs3d]).reshape(4, -1).T,\n    columns=[\"longitude\", \"latitude\", \"altitude\", \"cost\"],\n).assign(height=lambda x: x.altitude * 0.3048)\n\ndf_cost_3d\n\n\n\n\n\n\n\n\n\nlongitude\nlatitude\naltitude\ncost\nheight\n\n\n\n\n0\n-10.0\n35.0\n0.000000\n3.158413e-38\n0.000000\n\n\n1\n-10.0\n35.0\n1290.322581\n3.365469e-38\n393.290323\n\n\n2\n-10.0\n35.0\n2580.645161\n3.579098e-38\n786.580645\n\n\n3\n-10.0\n35.0\n3870.967742\n3.799300e-38\n1179.870968\n\n\n4\n-10.0\n35.0\n5161.290323\n4.026075e-38\n1573.161290\n\n\n...\n...\n...\n...\n...\n...\n\n\n51195\n40.0\n60.0\n34838.709677\n1.785139e-43\n10618.838710\n\n\n51196\n40.0\n60.0\n36129.032258\n1.872056e-43\n11012.129032\n\n\n51197\n40.0\n60.0\n37419.354839\n1.960458e-43\n11405.419355\n\n\n51198\n40.0\n60.0\n38709.677419\n2.050347e-43\n11798.709677\n\n\n51199\n40.0\n60.0\n40000.000000\n2.141721e-43\n12192.000000\n\n\n\n\n51200 rows × 5 columns\nWith this grid cost, we need to define an interpolant based on this grid and an objective function which is a combination of the grid cost and fuel cost.\nfrom openap import top, aero\n\noptimizer = top.CompleteFlight(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\n# optimizer.setup(debug=True)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost_3d)\n\n\ndef objective(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(x, u, dt, time_dependent=True, **kwargs)\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost + fuel_cost * 2\n\n\n# generate optimal flight trajectory\n# interpolant is passed to trajectory(), and internally used by obj_grid()\nflight = optimizer.trajectory(objective=objective, interpolant=interpolant)\nOnce the optimization is complete, we can visualize the trajetory with the builtin vis.trajectory() function:\ntop.vis.trajectory(flight)\nplt.show()\nWe can create visualization code so that the trajectory is plotted along the cost grid at different altitudes. In the following figure, you can see the flight avoided the regions with highest cost, while maintaining a small detour to avoid excess fuel consumption.\nShow the function flight_level_cost_3d() used for visulization\ndef flight_level_cost_3d(flight, df_cost):\n    from cartopy import crs as ccrs\n    from cartopy.feature import BORDERS\n\n    proj = ccrs.PlateCarree()\n\n    fig, axes = plt.subplots(\n        3,\n        2,\n        figsize=(9, 9),\n        subplot_kw=dict(\n            projection=ccrs.TransverseMercator(\n                central_longitude=15, central_latitude=45\n            )\n        ),\n    )\n\n    for i, ax in enumerate(axes.flatten()):\n        ax.set_extent([-10, 40, 32, 60])\n        ax.add_feature(BORDERS, lw=0.5, color=\"gray\")\n        ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n\n        h = df_cost.height.unique()[i * 6]\n        fl = int(h / 0.3048 // 1000 * 10)\n\n        df_cost_pivot = df_cost.query(f\"height=={h}\").pivot(\n            index=\"latitude\", columns=\"longitude\", values=\"cost\"\n        )\n\n        lat, lon, val = (\n            df_cost_pivot.index.values,\n            df_cost_pivot.columns.values,\n            df_cost_pivot.values,\n        )\n\n        ax.contourf(\n            lon, lat, val, transform=proj, alpha=0.8, cmap=\"Reds\", vmin=0, vmax=1\n        )\n\n        ax.text(0.03, 0.9, f\"FL{fl}\", transform=ax.transAxes, fontsize=14)\n\n        ax.plot(flight.longitude, flight.latitude, color=\"k\", lw=1, transform=proj)\n\n        for r, p in (flight.iloc[[0, -1]]).iterrows():\n            ax.scatter(p.longitude, p.latitude, c=\"k\", transform=proj)\n\n    plt.tight_layout()\n    plt.show()\nflight_level_cost_3d(flight, df_cost_3d)\nNext, we modify the combined objective (grid and fuel) so that the weight of the grid cost is higher. And we can see that the optimized trajectory takes a longer detour to avoid regions with high grid cost with more fuel burnt.\ndef objective_2(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(x, u, dt, time_dependent=True, **kwargs)\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost * 2 + fuel_cost\n\n\nflight_2 = optimizer.trajectory(objective=objective_2, interpolant=interpolant)\n\nflight_level_cost_3d(flight_2, df_cost_3d)",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>🙀 Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html#cost-grid-in-3d",
    "href": "optimize/costgrid.html#cost-grid-in-3d",
    "title": "9  🙀 Using cost grids",
    "section": "",
    "text": "Note\n\n\n\nThere is also a built-in logic that raises a warning if the maximum height is higher than 20,000, which can be a common mistake between ft and meters when referring to the altitude.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>🙀 Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/costgrid.html#cost-grid-in-4d",
    "href": "optimize/costgrid.html#cost-grid-in-4d",
    "title": "9  🙀 Using cost grids",
    "section": "9.2 Cost grid in 4D",
    "text": "9.2 Cost grid in 4D\nThe usage of 4D cost grid is similar to 3D cost grid. The only difference is that the 4D cost grid includes a time dimension.\nIn the following example, we extend the 3D cost grid by adding a time dimension. The time dimension can be represented as a sequence of 3D cost grids at different time steps.\n\nimport numpy as np\nimport pandas as pd\n\n\ndef gaussian(x, y, z, t):\n    return (\n        np.exp(-((x + 3 - i) ** 2 + (y - 1) ** 2))\n        + np.exp(-((x - 3 + i / 2) ** 2 + (y + 2) ** 2))\n    ) * z**2\n\n\nx = np.linspace(-8, 8, 40)\ny = np.linspace(-4, 4, 40)\nz = np.linspace(1, 2, 32)\nX, Y, Z = np.meshgrid(x, y, z)\n\n# add the time dimension\nts = np.arange(0, 8 * 1800, 1800)  # every 30 minutes\ncosts4d = np.zeros((len(x), len(y), len(z), len(ts)))\n\nfor i, ts_ in enumerate(ts):\n    costs3d = gaussian(X, Y, Z, ts)\n    costs4d[:, :, :, i] = costs3d\n\ncosts4d = (costs4d - costs4d.min()) / (costs4d.max() - costs4d.min())\n\n# scale the x,y to lon,lat bound\nlon = np.interp(x, (min(x), max(x)), (-10, 40))\nlat = np.interp(y, (min(y), max(y)), (35, 60))\nalt = np.interp(z, (min(z), max(z)), (0, 40_000))\n\nlons, lats, alts, tss = np.meshgrid(lon, lat, alt, ts)\n\nThe 4D cost grid can be visualized at different time steps and altitudes as follows. Each rows represent the cost grid at different flight levels, and each column represents the cost grid at different time steps.\n\n\nShow the code used for visulization\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(4, 4, figsize=(16, 18), subplot_kw={\"projection\": \"3d\"})\nfor i, ax in enumerate(axes.flatten()):\n    ax.plot_surface(\n        lons[:, :, i // 4 * 6, i % 4 * 2],\n        lats[:, :, i // 4 * 6, i % 4 * 2],\n        costs4d[:, :, i // 4 * 6, i % 4 * 2],\n        edgecolor=\"tab:blue\",\n        lw=0.5,\n        alpha=0.3,\n    )\n    ax.set_zlim(0, 1)\n    flight_level = int(alt[i // 4 * 6] // 1000 * 10)\n    time = ts[i % 4 * 2] / 1800 / 2\n    ax.set_title(f\"FL{flight_level} | {int(time)}h\")\n    ax.set_xlabel(\"longitude\")\n    ax.set_ylabel(\"latitude\")\n    ax.set_zlabel(\"cost\", rotation=90)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nSimilar to the 3D cost grid, we can construct the 4D cost grid as a pd.DataFrame. The DataFrame has the columns height, latitude, longitude, and ts. The height unit must be in meters.\n\ndf_cost_4d = pd.DataFrame(\n    np.array([lons, lats, alts, tss, costs4d]).reshape(5, -1).T,\n    columns=[\"longitude\", \"latitude\", \"altitude\", \"ts\", \"cost\"],\n).assign(height=lambda x: x.altitude * 0.3048)\n\ndf_cost_4d\n\n\n\n\n\n\n\n\n\nlongitude\nlatitude\naltitude\nts\ncost\nheight\n\n\n\n\n0\n-10.0\n35.0\n0.0\n0.0\n4.836940e-23\n0.0\n\n\n1\n-10.0\n35.0\n0.0\n1800.0\n8.078512e-28\n0.0\n\n\n2\n-10.0\n35.0\n0.0\n3600.0\n1.826010e-33\n0.0\n\n\n3\n-10.0\n35.0\n0.0\n5400.0\n5.615118e-40\n0.0\n\n\n4\n-10.0\n35.0\n0.0\n7200.0\n3.049747e-38\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n409595\n40.0\n60.0\n40000.0\n5400.0\n1.995862e-32\n12192.0\n\n\n409596\n40.0\n60.0\n40000.0\n7200.0\n6.490450e-26\n12192.0\n\n\n409597\n40.0\n60.0\n40000.0\n9000.0\n2.871462e-20\n12192.0\n\n\n409598\n40.0\n60.0\n40000.0\n10800.0\n1.719263e-15\n12192.0\n\n\n409599\n40.0\n60.0\n40000.0\n12600.0\n1.393133e-11\n12192.0\n\n\n\n\n409600 rows × 6 columns\n\n\n\n\nWith the 4D cost grid, we can again define an interpolant based on this grid and an objective function which is a combination of the grid cost and fuel cost.\n\nfrom openap import top, aero\n\noptimizer = top.CompleteFlight(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\n# optimizer.setup(debug=True)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost_4d)\n\n\ndef objective(x, u, dt, **kwargs):\n    \"\"\"The final objective is the compound of grid cost and fuel\"\"\"\n    grid_cost = optimizer.obj_grid_cost(\n        x, u, dt, n_dim=4, time_dependent=True, **kwargs\n    )\n    fuel_cost = optimizer.obj_fuel(x, u, dt, **kwargs)\n    return grid_cost + fuel_cost * 2\n\n\n# generate the flight trajectory\n# interpolant is passed to trajectory(), and internally used by obj_grid()\nflight = optimizer.trajectory(objective=objective, interpolant=interpolant)\n\nOnce the optimization is complete, we can visualize the trajetory with the builtin vis.trajectory() function:\n\ntop.vis.trajectory(flight)\nplt.show()\n\n\n\n\n\n\n\n\nWe can create visualization code so that the trajectory is plotted along the cost grid at different altitudes and time steps. In the following figure, you can see the flight avoided the regions with highest cost, while maintaining a small detour to avoid excess fuel consumption. This is similar to the 3D cost grid, but with the added time dimension.\n\n\nShow the function flight_level_cost_4d() used for visulization\ndef flight_level_cost_4d(flight, df_cost):\n    from cartopy import crs as ccrs\n    from cartopy.feature import BORDERS\n\n    proj = ccrs.PlateCarree()\n\n    fig, axes = plt.subplots(\n        3,\n        2,\n        figsize=(9, 9),\n        subplot_kw=dict(\n            projection=ccrs.TransverseMercator(\n                central_longitude=15, central_latitude=45\n            )\n        ),\n    )\n\n    for i, ax in enumerate(axes.flatten()):\n        ax.set_extent([-10, 40, 32, 60])\n        ax.add_feature(BORDERS, lw=0.5, color=\"gray\")\n        ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n\n        df_cost_pivot = df_cost.query(\n            f\"height=={df_cost.height.max()} and ts=={i*1800}\"\n        ).pivot(index=\"latitude\", columns=\"longitude\", values=\"cost\")\n\n        lat, lon, val = (\n            df_cost_pivot.index.values,\n            df_cost_pivot.columns.values,\n            df_cost_pivot.values,\n        )\n\n        ax.contourf(lon, lat, val, transform=proj, alpha=0.7, cmap=\"Purples\")\n\n        current = flight.query(f\"{i*1800}&lt;ts&lt;{i*1800+600}\").iloc[0]\n\n        ax.text(\n            0.03, 0.9, f\"Time={int(current.ts)}s\", transform=ax.transAxes, fontsize=14\n        )\n\n        ax.scatter(current.longitude, current.latitude, color=\"r\", lw=5, transform=proj)\n\n        ax.plot(flight.longitude, flight.latitude, color=\"k\", lw=1, transform=proj)\n\n        for r, p in flight.iloc[[0, -1]].iterrows():\n            ax.scatter(p.longitude, p.latitude, c=\"k\", transform=proj)\n\n    plt.tight_layout()\n    plt.show()\n\n\n\nflight_level_cost_4d(flight, df_cost_4d)",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>🙀 Using cost grids</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html",
    "href": "optimize/contrails.html",
    "title": "10  🥠 Contrails",
    "section": "",
    "text": "10.1 Building the cost grid\nIn the previous chapter, we have built a cost grid that represents the cost of flying in a certain region. Here we want to construct a cost grid that represents the climate cost of contrails and CO2 emissions, which are converted to temperature response based on their effective radiative forcing (ERF) in W/m2.\nThe source of the example data is obtained from the paper Yin et al. (2023). The data is based on the ECMWF data and is used to calculate the contrail temperature response (ATR20) in K/km. The data is available in the netCDF format and is stored in the 3D grid of latitude, longitude, and pressure level.\nFirst, we will download the associated data with the paper using the following code:\nNext, we will read the data and convert it to a cost grid. We will use only the data from December 18, 2015 as example, which is also the date used in the paper.\nimport xarray as xr\n\nds = xr.open_dataset(\"tmp/contrail.nc\").sel(time=\"2015-12-18\")\nIn this dataset, the levels are defined using L31 model from ECMWF. In order to convert the pressure levels to height, we use the following corresponding pressure altitude in hPa, which will be used to calculate the height in m:\nL31 level to pressure in hPa\nlevel_pressure = [\n    0.0000,\n    10.0000,\n    30.0000,\n    50.0000,\n    70.0000,\n    90.0787,\n    110.6606,\n    132.3968,\n    155.7909,\n    181.1544,\n    208.6494,\n    238.3258,\n    270.1530,\n    304.0465,\n    339.8891,\n    377.5467,\n    416.8789,\n    457.7442,\n    500.0000,\n    543.4970,\n    588.0685,\n    633.5144,\n    679.5799,\n    725.9285,\n    772.1102,\n    817.5241,\n    861.3757,\n    902.6287,\n    939.9520,\n    971.6610,\n    995.6532,\n    1009.3396,\n]\nThe following code will convert the contrail temperature response to a cost grid.\nimport openap\nimport pandas as pd\nimport numpy as np\n\ndf = (\n    ds.to_dataframe()\n    .reset_index()\n    .assign(lev=lambda x: x.lev.astype(int))\n    .merge(\n        pd.DataFrame(level_pressure, columns=[\"hPa\"]).reset_index(names=\"lev\"),\n        on=\"lev\",\n    )\n    .assign(height=lambda x: openap.aero.h_isa(x.hPa * 100).round(-2))\n    .assign(longitude=lambda x: ((x.lon + 180) % 360 - 180))\n    .query(\"height&lt;15000\")\n)\n\ndf_cost_world = df.rename(\n    columns={\n        \"lat\": \"latitude\",\n        \"atr20_contrail\": \"cost\",\n    }\n)[[\"time\", \"latitude\", \"longitude\", \"hPa\", \"height\", \"cost\"]]\n\ndf_cost_world.head()\n\n\n\n\n\n\n\n\n\ntime\nlatitude\nlongitude\nhPa\nheight\ncost\n\n\n\n\n6\n2015-12-18\n87.8638\n0.0\n132.3968\n14400.0\n0.000000e+00\n\n\n7\n2015-12-18\n87.8638\n0.0\n155.7909\n13400.0\n0.000000e+00\n\n\n8\n2015-12-18\n87.8638\n0.0\n181.1544\n12400.0\n9.405122e-13\n\n\n9\n2015-12-18\n87.8638\n0.0\n208.6494\n11500.0\n8.791347e-13\n\n\n10\n2015-12-18\n87.8638\n0.0\n238.3258\n10700.0\n7.871002e-13\nBefore we use the data for optimization, let’s reproduce the example from the paper with the cost grid for Europe at 250 hPa, which is approximately 10,700m. The selected EU region is defined as 30-70 latitude and -20 to 40 longitude.\nimport matplotlib.pyplot as plt\nfrom cartopy import crs as ccrs\nfrom cartopy.feature import BORDERS\n\nproj = ccrs.TransverseMercator(central_longitude=10, central_latitude=50)\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4), subplot_kw=dict(projection=proj))\n\ndf_cost_eu_250hpa = (\n    df_cost_world.query(\"height==10700\")\n    .query(\"-20&lt;longitude&lt;40 and 30&lt;latitude&lt;70\")\n    .sort_values([\"latitude\", \"longitude\"])\n)\n\nhours = [0, 12]\n\nfor ax, hour in zip(axes, hours):\n    df_cost_pivot = df_cost_eu_250hpa.query(f\"time.dt.hour=={hour}\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n\n    ax.set_extent([-20, 40, 28, 70])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n    ax.gridlines(draw_labels=True, lw=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\")\n\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost_eu_250hpa.cost.max(),\n        vmax=df_cost_eu_250hpa.cost.max(),\n    )",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>🥠 Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#building-the-cost-grid",
    "href": "optimize/contrails.html#building-the-cost-grid",
    "title": "10  🥠 Contrails",
    "section": "",
    "text": "import urllib\n\nurllib.request.urlretrieve('https://opendap.4tu.nl/thredds/fileServer/data2/djht/bea8a3fe-e34c-4598-9f94-c5a5c63348e5/1/contrail_original.nc', 'tmp/contrail.nc')\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA few things to pay attention to: - longitude from ECMWF data is in the range of 0 to 360, we need to convert it to -180 to 180. - The height is in hPa, we need to convert it to m. - We will only use the data below 15,000m (below FL500). - The cost dataframe must contain the following minimum columns: ‘latitude’, ‘longitude’, ‘height’, ‘cost’.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>🥠 Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#the-contrail-grid",
    "href": "optimize/contrails.html#the-contrail-grid",
    "title": "10  🥠 Contrails",
    "section": "10.2 The contrail grid",
    "text": "10.2 The contrail grid\nSince the grid is sparse in the time dimension, with data at 00:00, 06:00, 12:00, and 18:00, we will only use the data at 12:00 for the optimization, which simplifies the cost grid to 3D. We will also smooth the grid using a Gaussian filter.\n\n\n\n\n\n\nNote\n\n\n\nIt is also practical to smooth the grid, most importantly the vertical axis, so that the optimization can be more stable. The Gaussian filter helps to prevent sharp discontinuities in the cost grid, thus improving the gradient calculation.\n\n\n\nfrom scipy.ndimage import gaussian_filter\n\ndf_cost = df_cost_world.query(\n    \"-20&lt;longitude&lt;40 and 30&lt;latitude&lt;70 and time.dt.hour==12\"\n).sort_values([\"height\", \"latitude\", \"longitude\"])\n\ncost = df_cost.cost.values.reshape(\n    df_cost.height.nunique(),\n    df_cost.latitude.nunique(),\n    df_cost.longitude.nunique(),\n)\n\ncost_ = gaussian_filter(cost, sigma=1, mode=\"nearest\")\ndf_cost = df_cost.assign(cost=cost_.flatten())\n\nNext, we can plot the smoothed cost grid for different heights.\n\nfig, axes = plt.subplots(3, 3, figsize=(12, 10), subplot_kw=dict(projection=proj))\n\nheights = df_cost.height.unique()\nskip_levels = 15\n\nfor i, ax in enumerate(axes.flatten()):\n    df_cost_pivot = df_cost.query(f\"height=={heights[skip_levels+i]}\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n\n    ax.set_extent([-20, 40, 28, 70])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"110m\", lw=0.5, color=\"gray\")\n    ax.gridlines(\n        draw_labels=False, linewidth=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\"\n    )\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost.cost.quantile(0.99),\n        vmax=df_cost.cost.quantile(0.99),\n    )\n\n    fl = heights[skip_levels + i] / openap.aero.ft // 1000 * 10\n\n    ax.text(0.03, 0.9, f\"FL{int(fl)}\", transform=ax.transAxes, fontsize=14)\n\nplt.tight_layout()",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>🥠 Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#optimization-for-both-contrail-and-co2",
    "href": "optimize/contrails.html#optimization-for-both-contrail-and-co2",
    "title": "10  🥠 Contrails",
    "section": "10.3 Optimization for both contrail and CO2",
    "text": "10.3 Optimization for both contrail and CO2\nNow we can use the cost grid to optimize a trajectory. Again, we use the example flight from Amsterdam (EHAM) to Athens (LGAV).\nThe final cost function is the combination of temperature response (ATR20) from both contrails and CO2 emissions.\nThe unit of the contrail temperature response from the paper is in K/km; however, the optimizer requires the cost to be divided by time, thus we need to convert the unit to K/s. In this case, we first define the cost to be not time-dependent. Then, we multiply the cost by the true airspeed of the aircraft with a conversion factor of 1e-3, which is the speed of the aircraft in km/s.\nFor the CO2 emissions, we use the conversion factor of 7.03e-15 K/kg to convert the fuel flow (kg/s) to temperature response (K/s).\nIn addition to the default combined effect of contrail and CO2, we will build a fuel optimal trajectory as a comparison. The fuel optimal trajectory is obtained by setting the contrail cost to zero.\n\nfrom openap import top\n\noptimizer = top.Cruise(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\n\nflight_fuel_optimal = optimizer.trajectory(objective=\"fuel\")\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost)\n\nresults = {}\n\nscenarios = {\n    \"default\": [1, 1],\n    \"fuel optimal\": [0, 1],\n}\n\n\ndef objective(x, u, dt, **kwargs):\n    scale_contrail = kwargs.get(\"scale_contrail\", 1)\n    scale_co2 = kwargs.get(\"scale_co2\", 1)\n\n    xp, yp, h, m, ts = x[0], x[1], x[2], x[3], x[4]\n    mach, vs, psi = u[0], u[1], u[2]\n    vtas = openap.casadi.aero.mach2tas(mach, h)\n    contrail_cost = (\n        optimizer.obj_grid_cost(x, u, dt, n_dim=3, time_dependent=False, **kwargs)\n        * vtas\n        * 1e-3\n    ) * scale_contrail\n    co2_cost = optimizer.obj_fuel(x, u, dt, **kwargs) * 7.03e-15 * scale_co2\n    return contrail_cost + co2_cost\n\n\nfor scenario, weights in scenarios.items():\n    print(scenario)\n    flight = optimizer.trajectory(\n        objective=objective,\n        interpolant=interpolant,\n        initial_guess=flight_fuel_optimal,\n        h_min=25_000 * openap.aero.ft,\n        scale_contrail=weights[0],\n        scale_co2=weights[1],\n        return_failed=True,\n    )\n    results[scenario] = flight\n\ndefault\nfuel optimal\n\n\nNext we can visualize the final flight trajectory. Note that the cost grid at FL350 is shown in the background.\n\n\nShow the code of plot_flight() used for visulization\ndef plot_flight(results, df_cost, scenarios=None):\n    proj = ccrs.TransverseMercator(central_longitude=10, central_latitude=50)\n\n    fig = plt.figure(figsize=(12, 5))\n\n    ax = fig.add_subplot(1, 2, 1)\n\n    for scenario, flight in results.items():\n        ax.plot(flight.ts, flight.altitude, lw=2)\n        ax.set_ylim(0, 40000)\n    ax.set_xlabel(\"Time [s]\")\n    ax.set_ylabel(\"Altitude [ft]\")\n\n    ax = plt.subplot(1, 2, 2, projection=proj)\n\n    df_cost_pivot = df_cost.query(\"height==10700\").pivot(\n        index=\"latitude\", columns=\"longitude\", values=\"cost\"\n    )\n    lat, lon, val = (\n        df_cost_pivot.index.values,\n        df_cost_pivot.columns.values,\n        df_cost_pivot.values,\n    )\n    ax.set_extent([0, 30, 35, 55])\n    ax.add_feature(BORDERS, lw=0.5, edgecolor=\"gray\")\n    ax.coastlines(resolution=\"50m\", lw=0.5, color=\"gray\")\n    ax.gridlines(\n        draw_labels=False, linewidth=0.5, color=\"gray\", alpha=0.5, linestyle=\"--\"\n    )\n    ax.contourf(\n        lon,\n        lat,\n        val,\n        cmap=\"RdBu_r\",\n        levels=100,\n        transform=ccrs.PlateCarree(),\n        vmin=-df_cost.cost.max() * 0.7,\n        vmax=df_cost.cost.max() * 0.7,\n    )\n\n    fl = 350\n\n    ax.text(\n        0.05,\n        0.95,\n        f\"FL{int(fl)}\",\n        transform=ax.transAxes,\n        fontsize=14,\n        ha=\"left\",\n        va=\"top\",\n    )\n\n    for scenario, flight in results.items():\n        ax.plot(\n            flight.longitude,\n            flight.latitude,\n            transform=ccrs.PlateCarree(),\n            lw=2,\n            label=f\"{scenario} | fuel: {int(flight.fuel.sum())} kg\",\n        )\n\n    for r, p in flight.iloc[[0, -1]].iterrows():\n        ax.scatter(\n            p.longitude,\n            p.latitude,\n            c=\"k\",\n            transform=ccrs.PlateCarree(),\n        )\n\n    ax.legend()\n    plt.tight_layout()\n    plt.show()\n\n\n\nplot_flight(results, df_cost)",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>🥠 Contrails</span>"
    ]
  },
  {
    "objectID": "optimize/contrails.html#uncertainties-that-makes-or-breaks-the-optimization",
    "href": "optimize/contrails.html#uncertainties-that-makes-or-breaks-the-optimization",
    "title": "10  🥠 Contrails",
    "section": "10.4 Uncertainties that makes or breaks the optimization",
    "text": "10.4 Uncertainties that makes or breaks the optimization\n\n\nCode\nextra_fuel = int(\n    (results[\"default\"].fuel.sum() - results[\"fuel optimal\"].fuel.sum()).round(-1)\n)\nextra_fuel_percent = int(\n    (\n        (\n            (results[\"default\"].fuel.sum() - results[\"fuel optimal\"].fuel.sum())\n            / results[\"fuel optimal\"].fuel.sum()\n        )\n        * 100\n    ).round()\n)\n\n\nIn the previous example, we can see that the optimal trajectory considering both contrail and CO2 climate effects differs largely from the fuel optimal trajectory. A large deviation is observed in both the altitude and the route to avoid regions with high contrail cost.\nThis deviation costs about 690 kg of fuel, which accounts for about 10% extra fuel when compared to the optimal case. This is a significant amount of fuel, both in terms of cost and excess CO2 emissions.\nIn recent studies regarding operational contrail mitigation, we often miss the fact that the contrail cost is highly uncertain. In the paper The contribution of global aviation to anthropogenic climate forcing for 2000 to 2018 Lee et al. (2021), the authors have pointed out that the uncertainties in the effective radiative forcing caused by contrail cirrus can be between 17 and 98 mW/m2. This is a huge range, but many studies only consider the mean value of 57.4.\nThis large scale of uncertainties can lead to completely different optimal trajectories. In the following example, we will show how the optimization results can be affected by the uncertainties in the contrail cost.\nFirst of all, different scenarios and scaling factors for contrail and CO2 are defined as follows:\n\nmore_scenarios = {\n    \"default\": [1, 1],\n    \"fuel optimal\": [0, 1],\n    \"lo_contrail_high_co2\": [0.293, 1.166],\n    \"lo_contrail_lo_co2\": [0.293, 0.816],\n    \"hi_contrail_lo_co2\": [1.707, 0.816],\n    \"hi_contrail_hi_co2\": [1.707, 1.166],\n}\n\nIn the above scenarios, for example, lo_contrail_high_co2 refers to scaling the contrail impact to a lower bound of 29.3% of the default value, while the CO2 cost is scaled to the upper bound of 116.6% of the default value. In this case, the contrail has a significantly lower impact than what has been assumed in the default case, while the CO2 cost is slightly higher.\nThe following code will run the optimization for all the scenarios and visualize the results.\n\nfrom openap import top\n\noptimizer = top.Cruise(\"A320\", \"EHAM\", \"LGAV\", m0=0.85)\noptimizer.setup(debug=False, max_iteration=2000)\n\ninterpolant = top.tools.interpolant_from_dataframe(df_cost)\n\nmore_results = {}\n\nfor scenario, weights in more_scenarios.items():\n    print(scenario)\n    flight = optimizer.trajectory(\n        objective=objective,\n        interpolant=interpolant,\n        initial_guess=flight_fuel_optimal,\n        h_min=25_000 * openap.aero.ft,\n        scale_contrail=weights[0],\n        scale_co2=weights[1],\n        return_failed=True,\n    )\n    more_results[scenario] = flight\n\ndefault\nfuel optimal\nlo_contrail_high_co2\nlo_contrail_lo_co2\nhi_contrail_lo_co2\nhi_contrail_hi_co2\n\n\n\nplot_flight(more_results, df_cost)\n\n\n\n\n\n\n\n\nWhat we can see based on these results is that the optimal trajectory can be very different depending on the uncertainties in the contrail cost. In the case of lo_contrail_high_co2, the optimal trajectory is much closer to the fuel optimal trajectory, as the contrail cost is significantly lower than the default value. In the case of hi_contrail_lo_co2, it has the highest deviation from the fuel optimal trajectory.\nGiven the large uncertainties in the contrail cost, without a better understanding of the uncertainties, pushing operations to perform deviations caused by contrails may come with a large cost in terms of fuel and CO2 emissions.\n\n\n\n\nLee, D. S., Fahey, D. W., Skowron, A., Allen, M. R., Burkhardt, U., Chen, Q., Doherty, S. J., Freeman, S., Forster, P. M., Fuglestvedt, J., et al. (2021). The contribution of global aviation to anthropogenic climate forcing for 2000 to 2018. Atmospheric Environment, 244, 117834.\n\n\nYin, F., Grewe, V., Castino, F., Rao, P., Matthes, S., Dahlmann, K., Dietmüller, S., Frömming, C., Yamashita, H., Peter, P., et al. (2023). Predicting the climate impact of aviation for en-route emissions: The algorithmic climate change function submodel ACCF 1.0 of EMAC 2.53. Geoscientific Model Development, 16(11), 3313–3334.",
    "crumbs": [
      "🦸 Trajectory Optimizer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>🥠 Contrails</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bartel, M., & Young, T. M. (2008). Simplified thrust and fuel\nconsumption models for modern two-shaft turbofan engines. Journal of\nAircraft, 45(4), 1450–1456.\n\n\nLee, D. S., Fahey, D. W., Skowron, A., Allen, M. R., Burkhardt, U.,\nChen, Q., Doherty, S. J., Freeman, S., Forster, P. M., Fuglestvedt, J.,\net al. (2021). The contribution of global aviation to anthropogenic\nclimate forcing for 2000 to 2018. Atmospheric Environment,\n244, 117834.\n\n\nSun, J. (2021). The 1090 megahertz riddle: A guide to decoding mode\ns and ADS-b signals (2nd ed.). TU Delft OPEN Publishing. https://doi.org/10.34641/mg.11\n\n\nSun, J. (2022). OpenAP. Top: Open flight trajectory optimization for air\ntransport and sustainability research. Aerospace,\n9(7), 383. https://doi.org/10.3390/aerospace9070383\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2017). Flight extraction\nand phase identification for large automatic dependent\nsurveillance–broadcast datasets. Journal of Aerospace Information\nSystems, 14(10), 566–571. https://doi.org/10.2514/1.I010520\n\n\nSun, J., Ellerbroek, J., & Hoekstra, J. (2019). WRAP: An open-source\nkinematic aircraft performance model. Transportation Research Part\nC: Emerging Technologies, 98, 118–138. https://doi.org/10.1016/j.trc.2018.11.009\n\n\nSun, J., Hoekstra, J., & Ellerbroek, J. (2020). Estimating aircraft\ndrag polar using open flight surveillance data and a stochastic total\nenergy model. Transportation Research Part C: Emerging\nTechnologies, 114, 391–404. https://doi.org/10.1016/j.trc.2020.01.026\n\n\nYin, F., Grewe, V., Castino, F., Rao, P., Matthes, S., Dahlmann, K.,\nDietmüller, S., Frömming, C., Yamashita, H., Peter, P., et al. (2023).\nPredicting the climate impact of aviation for en-route emissions: The\nalgorithmic climate change function submodel ACCF 1.0 of EMAC 2.53.\nGeoscientific Model Development, 16(11), 3313–3334.",
    "crumbs": [
      "References"
    ]
  }
]